<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Test_Iterative_Task.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "doctest.h"
#include "../Main/Scheduler.h"
#include "../Main/IterativeTask.h"
#include &lt;memory&gt;

<span style = "background-color:#dfd">TEST_CASE("Unit Test Of Iterative Task Handler") {</span>
    Scheduler s;

<span style = "background-color:#dfd">    SUBCASE("Push Iterative Task") {</span>
        // Create and add a new iterative task to the handler
<span style = "background-color:#dfd">        std::shared_ptr&lt;IterativeTask&gt; newTask = std::make_shared&lt;IterativeTask&gt;(Task(0, PrioritiesLevel::HIGHER, 2), 2, 2);
        s.getIterativeTaskHandler().pushIterativeTask(newTask);</span>

        // Wait for 1 second to allow for potential task processing
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(1));</span>

        // Verify that the task has been added to the min heap
<span style = "background-color:#dfd">        CHECK_EQ(s.getIterativeTaskHandler().getMinHeap().size(), 1);</span>

        // Remove the task from the handler
<span style = "background-color:#dfd">        s.getIterativeTaskHandler().popIterativeTask();</span>

        // Re-add the task to verify its behavior when it's the only one in the heap
<span style = "background-color:#dfd">        s.getIterativeTaskHandler().pushIterativeTask(newTask);
        CHECK_EQ(s.getIterativeTaskHandler().getMinHeap().size(), 0);
    }</span>

<span style = "background-color:#dfd">    SUBCASE("Pop Iterative Task") {</span>
        // Create and add a new iterative task to the handler
<span style = "background-color:#dfd">        std::shared_ptr&lt;IterativeTask&gt; newTask = std::make_shared&lt;IterativeTask&gt;(Task(0, PrioritiesLevel::HIGHER, 2), 4, 2);
        s.getIterativeTaskHandler().pushIterativeTask(newTask);</span>

        // Wait for 1 second to allow for potential task processing
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(1));</span>

        // Remove the task from the handler
<span style = "background-color:#dfd">        s.getIterativeTaskHandler().popIterativeTask();</span>

        // Verify that the task has been removed from the scheduler's queue
<span style = "background-color:#dfd">        CHECK_EQ(s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 0);</span>

        // Try to remove a task when none are left, expecting an exception
<span style = "background-color:#dfd">        CHECK_THROWS(s.getIterativeTaskHandler().popIterativeTask());
    }</span>

<span style = "background-color:#dfd">    SUBCASE("Check Time Function") {</span>
        // Create and add a new iterative task to the handler
<span style = "background-color:#dfd">        std::shared_ptr&lt;IterativeTask&gt; newTask = std::make_shared&lt;IterativeTask&gt;(Task(0, PrioritiesLevel::HIGHER, 2), 4, 1);
        s.getIterativeTaskHandler().pushIterativeTask(newTask);</span>

        // Create and start a thread to run the checkTime function
<span style = "background-color:#dfd">        std::thread t([&amp;s]() {
            s.getIterativeTaskHandler().checkTime();
            });</span>

        // Wait for 2 seconds to allow the checkTime function to execute
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(2));</span>

        // Verify that the task is still present in the min heap
<span style = "background-color:#dfd">        CHECK_EQ(s.getIterativeTaskHandler().getMinHeap().size(), 1);</span>

        // Remove the task from the handler
<span style = "background-color:#dfd">        s.getIterativeTaskHandler().popIterativeTask();
        s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.pop();</span>

        // Detach the thread after verification
<span style = "background-color:#dfd">        t.detach();
    }
}</span>

<span style = "background-color:#dfd">TEST_CASE("System Test Of Iterative Task Handler") {</span>
    Scheduler s;

<span style = "background-color:#dfd">    SUBCASE("Iterative Task Handling") {</span>
        // Create and insert a new iterative task into the scheduler
<span style = "background-color:#dfd">        std::shared_ptr&lt;IterativeTask&gt; newTask = std::make_shared&lt;IterativeTask&gt;(Task(0, PrioritiesLevel::HIGHER, 2), 2, 0);
        s.insertTask(newTask);</span>

        // Create and start a thread to run the checkTime function
<span style = "background-color:#dfd">        std::thread t([&amp;s]() {
            s.getIterativeTaskHandler().checkTime();
            });</span>

        // Wait for 3 seconds to allow the checkTime function to execute
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(3));</span>

        // Verify that the task was processed and is no longer in the min heap
<span style = "background-color:#dfd">        CHECK_EQ(s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 2);
        CHECK_EQ(s.getIterativeTaskHandler().getMinHeap().size(), 0);</span>

        // Remove the processed tasks from the scheduler's queue
<span style = "background-color:#dfd">        s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.pop();
        s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.pop();</span>

        // Detach the thread after verification
<span style = "background-color:#dfd">        t.detach();
    }</span>

<span style = "background-color:#dfd">    SUBCASE("Iterative Task with Zero Iterations") {</span>
        // Create and insert a new iterative task with zero iterations
<span style = "background-color:#dfd">        std::shared_ptr&lt;IterativeTask&gt; newTask = std::make_shared&lt;IterativeTask&gt;(Task(0, PrioritiesLevel::HIGHER, 2), 0, 0);
        s.insertTask(newTask);</span>

        // Verify that the task is present in the queue
<span style = "background-color:#dfd">        CHECK_EQ(s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 1);
        CHECK_EQ(s.getIterativeTaskHandler().getMinHeap().size(), 0);</span>

        // Remove the task from the scheduler's queue
<span style = "background-color:#dfd">        s.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.pop();
    }</span>

<span style = "background-color:#dfd">}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>