<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>WebSocketSession.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">

#include "WebSocketSession.h"
#include &lt;iostream&gt;
#include "Task.h"
#include "Scheduler.h"
#include "TaskFactory.h"
#include &lt;nlohmann/json.hpp&gt;  // For JSON parsing

using json = nlohmann::json;

// Modify the constructor to take a socket and move it into the WebSocket stream
WebSocketSession::WebSocketSession(boost::asio::ip::tcp::socket socket)
<span style = "background-color:#fdd">	: ws_(std::move(socket)) {
}</span>

<span style = "background-color:#fdd">boost::asio::ip::tcp::socket&amp; WebSocketSession::get_socket() {
	return ws_.next_layer();
}</span>

<span style = "background-color:#fdd">void WebSocketSession::start() {</span>
	// Accept the WebSocket handshake
<span style = "background-color:#fdd">	ws_.async_accept([self = shared_from_this()](beast::error_code ec) {
		if (!ec) {
			self-&gt;do_read();
		}</span>
		else {
<span style = "background-color:#fdd">			std::cerr &lt;&lt; "WebSocket accept error: " &lt;&lt; ec.message() &lt;&lt; std::endl;</span>
		}
<span style = "background-color:#fdd">		});
}</span>

<span style = "background-color:#fdd">void WebSocketSession::do_read() {</span>
	// Read data from the WebSocket
<span style = "background-color:#fdd">	ws_.async_read(buffer_, [self = shared_from_this()](beast::error_code ec, std::size_t bytes_transferred) {
		if (!ec) {</span>
			// Handle the received message (convert buffer to string)
<span style = "background-color:#fdd">			std::string message = beast::buffers_to_string(self-&gt;buffer_.data());</span>

			// Log or handle the message as needed
<span style = "background-color:#fdd">			std::cout &lt;&lt; "Received: " &lt;&lt; message &lt;&lt; std::endl;</span>

			// Parse the message as JSON
<span style = "background-color:#fdd">			json task_json = json::parse(message);
			if (task_json.contains("priority") &amp;&amp; task_json.contains("runningTime")) {
				TaskFactory::createTask(task_json);</span>
				// Check boundaries before accessing JSON fields

<span style = "background-color:#fdd">				std::string priority = task_json["priority"].get&lt;std::string&gt;();
				int runningTime = task_json["runningTime"].get&lt;int&gt;();  // Expecting an integer</span>

				// Create a new Task and insert it into the scheduler

				//std::shared_ptr&lt;Task&gt; newTask(new Task(Scheduler::taskIds++, priority, runningTime));
				//Scheduler::insertTask(newTask);
<span style = "background-color:#fdd">				std::cout &lt;&lt; "Sending a response\n";</span>

				// Prepare and send a response to the client
<span style = "background-color:#fdd">				std::string response = "Task with priority " + priority + " and running time " +</span>
					std::to_string(runningTime) + " received and scheduled.";

				// Use 'self' instead of 'this' to call the member function
<span style = "background-color:#fdd">				self-&gt;send_response(response);
			}</span>

			// Clear the buffer
<span style = "background-color:#fdd">			self-&gt;buffer_.consume(bytes_transferred);</span>

			// Continue reading
<span style = "background-color:#fdd">			self-&gt;do_read();
		}</span>
		else {
<span style = "background-color:#fdd">			std::cerr &lt;&lt; "WebSocket read error: " &lt;&lt; ec.message() &lt;&lt; std::endl;</span>
		}
<span style = "background-color:#fdd">		});
}</span>

<span style = "background-color:#fdd">void WebSocketSession::send_response(const std::string&amp; response) {</span>
	// Ensure response is valid
<span style = "background-color:#fdd">	if (response.empty()) {
		std::cerr &lt;&lt; "Error: Empty response string" &lt;&lt; std::endl;
		return;</span>
	}

<span style = "background-color:#fdd">	ws_.text(ws_.got_text());
	std::cout &lt;&lt; "---- send response in action ----" &lt;&lt; std::endl;</span>

	try {
		// Synchronous write
<span style = "background-color:#fdd">		ws_.write(net::buffer(response));</span>

<span style = "background-color:#fdd">		std::cout &lt;&lt; "Successfully wrote " &lt;&lt; response.size() &lt;&lt; " bytes" &lt;&lt; std::endl;</span>
	}
<span style = "background-color:#fdd">	catch (const std::exception&amp; e) {
		std::cerr &lt;&lt; "Write Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
	}</span>

	// Continue reading after writing
	//do_read();
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void WebSocketSession::do_write(const std::string&amp; message) {</span>
	// Write data to the WebSocket
<span style = "background-color:#fdd">	ws_.async_write(net::buffer(message), [self = shared_from_this()](beast::error_code ec, std::size_t /*bytes_transferred*/) {
		if (ec) {
			std::cerr &lt;&lt; "WebSocket write error: " &lt;&lt; ec.message() &lt;&lt; std::endl;</span>
		}
<span style = "background-color:#fdd">		});
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>