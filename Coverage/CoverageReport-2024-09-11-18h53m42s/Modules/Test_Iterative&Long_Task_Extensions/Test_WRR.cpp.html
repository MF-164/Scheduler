<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Test_WRR.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "doctest.h"
#include "Scheduler.h"
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;memory&gt;
#include "WeightRoundRobinScheduler.h"
#include "Consts.h"

using namespace std;

<span style = "background-color:#dfd">TEST_CASE("Test Weighted Round Robin scheduler") {</span>
    Scheduler scheduler;
<span style = "background-color:#dfd">    WeightRoundRobinScheduler WRRscheduler;</span>

    SUBCASE("Insert tasks into the correct queue based on priority") {

        shared_ptr&lt;Task&gt; higherTask(new Task(1, PrioritiesLevel::HIGHER, 5));
        shared_ptr&lt;Task&gt; middleTask(new Task(2, PrioritiesLevel::MIDDLE, 10));
        shared_ptr&lt;Task&gt; lowerTask(new Task(3, PrioritiesLevel::LOWER, 15));

        scheduler.insertTask(higherTask);
        scheduler.insertTask(middleTask);
        scheduler.insertTask(lowerTask);

        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 1);
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::MIDDLE].queue.size(), 1);
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::LOWER].queue.size(), 1);
    }

    SUBCASE("Test the running tasks is according to the Qs") {

        shared_ptr&lt;Task&gt; higherTask(new Task(1, PrioritiesLevel::HIGHER, 2));
        shared_ptr&lt;Task&gt; middleTask(new Task(2, PrioritiesLevel::MIDDLE, 2));
        shared_ptr&lt;Task&gt; lowerTask(new Task(3, PrioritiesLevel::LOWER, 2));

        scheduler.insertTask(higherTask);
        scheduler.insertTask(middleTask);
        scheduler.insertTask(lowerTask);

        // Start the scheduler in a new thread
        std::thread WRRThread([&amp;scheduler]() {
            scheduler.getWrrQueuesScheduler().weightRoundRobinFunction();
            });
        // Allow some time for tasks to be processed
        std::this_thread::sleep_for(std::chrono::seconds(2));

        // Detach the thread to finish execution
        WRRThread.detach();

        // The first task suppose to be from the higher Q
        cout &lt;&lt; "the Higher Q size: " &lt;&lt; scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size() &lt;&lt; endl;
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 0);

        // Allow some time for tasks to be processed
        std::this_thread::sleep_for(std::chrono::seconds(2));

        // The second task suppose to be from the middle Q
        cout &lt;&lt; "the middle Q size: " &lt;&lt; scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::MIDDLE].queue.size() &lt;&lt; endl;
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::MIDDLE].queue.size(), 0);

    }

    SUBCASE("Test the weight calculation") {

        shared_ptr&lt;Task&gt; higherTask1(new Task(1, PrioritiesLevel::HIGHER, 1));
        shared_ptr&lt;Task&gt; higherTask2(new Task(2, PrioritiesLevel::HIGHER, 1));
        shared_ptr&lt;Task&gt; higherTask3(new Task(3, PrioritiesLevel::HIGHER, 1));
        shared_ptr&lt;Task&gt; middleTask(new Task(4, PrioritiesLevel::MIDDLE, 1));
        shared_ptr&lt;Task&gt; lowerTask1(new Task(5, PrioritiesLevel::LOWER, 1));
        shared_ptr&lt;Task&gt; lowerTask2(new Task(6, PrioritiesLevel::LOWER, 1));

        scheduler.insertTask(higherTask1);
        scheduler.insertTask(higherTask2);
        scheduler.insertTask(higherTask3);
        scheduler.insertTask(middleTask);
        scheduler.insertTask(lowerTask1);
        scheduler.insertTask(lowerTask2);

        // Start the scheduler in a new thread
        std::thread WRRThread([&amp;scheduler]() {
            scheduler.getWrrQueuesScheduler().weightRoundRobinFunction();
            });
        // By the right calculating the weight of the higher Q = 3 tasks for executing
        // let 3 tasks from the higher Q to run:
        std::this_thread::sleep_for(std::chrono::seconds(4));

        // Detach the thread to finish execution
        WRRThread.detach();

        // The higher Q suppose to be empty
        cout &lt;&lt; "the Higher Q size: " &lt;&lt; scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size() &lt;&lt; endl;
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::HIGHER].queue.size(), 0);

        // Allow some time for tasks to be processed
        std::this_thread::sleep_for(std::chrono::seconds(2));

        //// The second task suppose to be from the middle Q
        cout &lt;&lt; "the middle Q size: " &lt;&lt; scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::MIDDLE].queue.size() &lt;&lt; endl;
        CHECK_EQ(scheduler.getWrrQueuesScheduler().getWrrQueues()[PrioritiesLevel::MIDDLE].queue.size(), 0);

    }

<span style = "background-color:#dfd">    SUBCASE("Test task status change after execution") {
        shared_ptr&lt;Task&gt; higherTask(new Task(1, PrioritiesLevel::HIGHER, 1));
        scheduler.insertTask(higherTask);</span>

<span style = "background-color:#dfd">        std::thread WRRThread([&amp;scheduler]() {
            scheduler.getWrrQueuesScheduler().weightRoundRobinFunction();
            });
        std::this_thread::sleep_for(std::chrono::seconds(3));</span>

<span style = "background-color:#dfd">        WRRThread.detach();</span>

        // Check that task status is updated after execution
<span style = "background-color:#dfd">        CHECK_EQ(higherTask-&gt;getStatus(), TaskStatus::COMPLETED);
    }</span>

<span style = "background-color:#dfd">    SUBCASE("Test dynamic task addition during execution") {
        shared_ptr&lt;Task&gt; higherTask(new Task(1, PrioritiesLevel::HIGHER, 1));
        scheduler.insertTask(higherTask);</span>

        // Start the scheduler in a new thread
<span style = "background-color:#dfd">        std::thread WRRThread([&amp;scheduler]() {
            scheduler.getWrrQueuesScheduler().weightRoundRobinFunction();
            });</span>

        // Add new task while scheduler is running
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(1));
        shared_ptr&lt;Task&gt; middleTask(new Task(2, PrioritiesLevel::MIDDLE, 1));
        scheduler.insertTask(middleTask);</span>

<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(3));
        WRRThread.detach();</span>

        // Check that the dynamically added task is executed
<span style = "background-color:#dfd">        CHECK_EQ(middleTask-&gt;getStatus(), TaskStatus::COMPLETED);
    }</span>

<span style = "background-color:#dfd">}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>