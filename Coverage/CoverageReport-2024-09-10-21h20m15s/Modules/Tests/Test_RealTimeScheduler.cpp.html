<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Test_RealTimeScheduler.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "doctest.h"
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;memory&gt;
#include "../Main/Scheduler.h"
#include "../Main/RealTimeScheduler.h"

<span style = "background-color:#dfd">TEST_CASE("Test RealTimeScheduler::realTimeSchedulerFunction") {</span>
	Scheduler scheduler;

<span style = "background-color:#dfd">	SUBCASE("Successful Execution of Real-Time Tasks") {
		shared_ptr&lt;Task&gt; task1(new Task(Scheduler::taskIds++, PrioritiesLevel::CRITICAL, 2));
		shared_ptr&lt;Task&gt; task2(new Task(Scheduler::taskIds++, PrioritiesLevel::CRITICAL, 3));</span>

<span style = "background-color:#dfd">		scheduler.insertTask(task1);
		scheduler.insertTask(task2);</span>
		//scheduler.getRealTimeScheduler().realTimeSchedulerFunction();
<span style = "background-color:#dfd">		std::thread schedulerThread(&amp;RealTimeScheduler::realTimeSchedulerFunction, &amp;scheduler.getRealTimeScheduler());</span>
		// Give some time for tasks to be executed
<span style = "background-color:#dfd">		std::this_thread::sleep_for(std::chrono::seconds(15));</span>

<span style = "background-color:#dfd">		schedulerThread.detach();  // We detach instead of join to avoid infinite loop</span>

<span style = "background-color:#dfd">		CHECK_EQ(scheduler.getRealTimeScheduler().getRealTimeQueue().size(), 0);
		CHECK_EQ(task1-&gt;getStatus(), TaskStatus::COMPLETED);
		CHECK_EQ(task2-&gt;getStatus(), TaskStatus::COMPLETED);</span>
		// Here you might want to add more checks to verify task execution
<span style = "background-color:#dfd">	}</span>

<span style = "background-color:#dfd">	SUBCASE("Empty Real-Time Queue - Blocking Behavior") {</span>
		// Start the real-time scheduler in a separate thread
<span style = "background-color:#dfd">		std::thread schedulerThread([&amp;scheduler]() {
			scheduler.getRealTimeScheduler().realTimeSchedulerFunction();
			});</span>

		// Give some time for the scheduler to attempt to execute tasks (should be blocking on an empty queue)
<span style = "background-color:#dfd">		std::this_thread::sleep_for(std::chrono::seconds(3));</span>

		// Since no tasks are added, the queue should remain empty
<span style = "background-color:#dfd">		CHECK_EQ(scheduler.getRealTimeScheduler().getRealTimeQueue().size(), 0);</span>

		// Detach the thread to prevent blocking the test case
<span style = "background-color:#dfd">		schedulerThread.detach();
	}
	SUBCASE("Test RealTimeScheduler Destructor") {</span>
		{
<span style = "background-color:#dfd">			RealTimeScheduler rts;
			shared_ptr&lt;Task&gt; task1(new Task(1, PrioritiesLevel::CRITICAL, 2));
			shared_ptr&lt;Task&gt; task2(new Task(2, PrioritiesLevel::CRITICAL, 3));
			rts.addTask(task1);
			rts.addTask(task2);</span>

<span style = "background-color:#dfd">			CHECK_EQ(rts.getRealTimeQueue().size(), 2);
		} // RealTimeScheduler goes out of scope here, destructor is called</span>

		// We can't directly check the queue size after destruction,
		// but we can verify that the destructor didn't crash
<span style = "background-color:#dfd">		CHECK(true); // If we reach here, destructor completed without crashing
	}
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>