<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>doctest.h</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// ====================================================================== lgtm [cpp/missing-header-guard]
// == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==
// ======================================================================
//
// doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD
//
// Copyright (c) 2016-2023 Viktor Kirilov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// The documentation can be found at the library's page:
// https://github.com/doctest/doctest/blob/master/doc/markdown/readme.md
//
// =================================================================================================
// =================================================================================================
// =================================================================================================
//
// The library is heavily influenced by Catch - https://github.com/catchorg/Catch2
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/catchorg/Catch2/blob/master/LICENSE.txt
//
// The concept of subcases (sections in Catch) and expression decomposition are from there.
// Some parts of the code are taken directly:
// - stringification - the detection of "ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;)" and StringMaker&lt;&gt;
// - the Approx() helper class for floating point comparison
// - colors in the console
// - breaking into a debugger
// - signal / SEH handling
// - timer
// - XmlWriter class - thanks to Phil Nash for allowing the direct reuse (AKA copy/paste)
//
// The expression decomposing templates are taken from lest - https://github.com/martinmoene/lest
// which uses the Boost Software License - Version 1.0
// see here - https://github.com/martinmoene/lest/blob/master/LICENSE.txt
//
// =================================================================================================
// =================================================================================================
// =================================================================================================

#ifndef DOCTEST_LIBRARY_INCLUDED
#define DOCTEST_LIBRARY_INCLUDED

// =================================================================================================
// == VERSION ======================================================================================
// =================================================================================================

#define DOCTEST_VERSION_MAJOR 2
#define DOCTEST_VERSION_MINOR 4
#define DOCTEST_VERSION_PATCH 11

// util we need here
#define DOCTEST_TOSTR_IMPL(x) #x
#define DOCTEST_TOSTR(x) DOCTEST_TOSTR_IMPL(x)

#define DOCTEST_VERSION_STR                                                                        \
    DOCTEST_TOSTR(DOCTEST_VERSION_MAJOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_MINOR) "."                                                       \
    DOCTEST_TOSTR(DOCTEST_VERSION_PATCH)

#define DOCTEST_VERSION                                                                            \
    (DOCTEST_VERSION_MAJOR * 10000 + DOCTEST_VERSION_MINOR * 100 + DOCTEST_VERSION_PATCH)

// =================================================================================================
// == COMPILER VERSION =============================================================================
// =================================================================================================

// ideas for the version stuff are taken from here: https://github.com/cxxstuff/cxx_detect

#ifdef _MSC_VER
#define DOCTEST_CPLUSPLUS _MSVC_LANG
#else
#define DOCTEST_CPLUSPLUS __cplusplus
#endif

#define DOCTEST_COMPILER(MAJOR, MINOR, PATCH) ((MAJOR)*10000000 + (MINOR)*100000 + (PATCH))

// GCC/Clang and GCC/MSVC are mutually exclusive, but Clang/MSVC are not because of clang-cl...
#if defined(_MSC_VER) &amp;&amp; defined(_MSC_FULL_VER)
#if _MSC_VER == _MSC_FULL_VER / 10000
#define DOCTEST_MSVC DOCTEST_COMPILER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)
#else // MSVC
#define DOCTEST_MSVC                                                                               \
    DOCTEST_COMPILER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)
#endif // MSVC
#endif // MSVC
#if defined(__clang__) &amp;&amp; defined(__clang_minor__) &amp;&amp; defined(__clang_patchlevel__)
#define DOCTEST_CLANG DOCTEST_COMPILER(__clang_major__, __clang_minor__, __clang_patchlevel__)
#elif defined(__GNUC__) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; defined(__GNUC_PATCHLEVEL__) &amp;&amp;              \
        !defined(__INTEL_COMPILER)
#define DOCTEST_GCC DOCTEST_COMPILER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#endif // GCC
#if defined(__INTEL_COMPILER)
#define DOCTEST_ICC DOCTEST_COMPILER(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif // ICC

#ifndef DOCTEST_MSVC
#define DOCTEST_MSVC 0
#endif // DOCTEST_MSVC
#ifndef DOCTEST_CLANG
#define DOCTEST_CLANG 0
#endif // DOCTEST_CLANG
#ifndef DOCTEST_GCC
#define DOCTEST_GCC 0
#endif // DOCTEST_GCC
#ifndef DOCTEST_ICC
#define DOCTEST_ICC 0
#endif // DOCTEST_ICC

// =================================================================================================
// == COMPILER WARNINGS HELPERS ====================================================================
// =================================================================================================

#if DOCTEST_CLANG &amp;&amp; !DOCTEST_ICC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH _Pragma("clang diagnostic push")
#define DOCTEST_CLANG_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(clang diagnostic ignored w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP _Pragma("clang diagnostic pop")
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)                                                \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH DOCTEST_CLANG_SUPPRESS_WARNING(w)
#else // DOCTEST_CLANG
#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
#define DOCTEST_CLANG_SUPPRESS_WARNING(w)
#define DOCTEST_CLANG_SUPPRESS_WARNING_POP
#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_CLANG

#if DOCTEST_GCC
#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH _Pragma("GCC diagnostic push")
#define DOCTEST_GCC_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(GCC diagnostic ignored w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP _Pragma("GCC diagnostic pop")
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH DOCTEST_GCC_SUPPRESS_WARNING(w)
#else // DOCTEST_GCC
#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH
#define DOCTEST_GCC_SUPPRESS_WARNING(w)
#define DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_GCC

#if DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH __pragma(warning(push))
#define DOCTEST_MSVC_SUPPRESS_WARNING(w) __pragma(warning(disable : w))
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP __pragma(warning(pop))
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)                                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH DOCTEST_MSVC_SUPPRESS_WARNING(w)
#else // DOCTEST_MSVC
#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
#define DOCTEST_MSVC_SUPPRESS_WARNING(w)
#define DOCTEST_MSVC_SUPPRESS_WARNING_POP
#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)
#endif // DOCTEST_MSVC

// =================================================================================================
// == COMPILER WARNINGS ============================================================================
// =================================================================================================

// both the header and the implementation suppress all of these,
// so it only makes sense to aggregate them like so
#define DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH                                                      \
    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH                                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wunknown-pragmas")                                            \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wweak-vtables")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wpadded")                                                     \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-prototypes")                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat")                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat-pedantic")                                      \
                                                                                                   \
    DOCTEST_GCC_SUPPRESS_WARNING_PUSH                                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wunknown-pragmas")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wpragmas")                                                      \
    DOCTEST_GCC_SUPPRESS_WARNING("-Weffc++")                                                       \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-overflow")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-aliasing")                                              \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-declarations")                                         \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wuseless-cast")                                                 \
    DOCTEST_GCC_SUPPRESS_WARNING("-Wnoexcept")                                                     \
                                                                                                   \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    /* these 4 also disabled globally via cmake: */                                                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4514) /* unreferenced inline function has been removed */        \
    DOCTEST_MSVC_SUPPRESS_WARNING(4571) /* SEH related */                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(4710) /* function not inlined */                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(4711) /* function selected for inline expansion*/                \
    /* common ones */                                                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4616) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4619) /* invalid compiler warning */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4996) /* The compiler encountered a deprecated declaration */    \
    DOCTEST_MSVC_SUPPRESS_WARNING(4706) /* assignment within conditional expression */             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4512) /* 'class' : assignment operator could not be generated */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(4127) /* conditional expression is constant */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4640) /* construction of local static object not thread-safe */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5264) /* 'variable-name': 'const' variable is not used */        \
    /* static analysis */                                                                          \
    DOCTEST_MSVC_SUPPRESS_WARNING(26439) /* Function may not throw. Declare it 'noexcept' */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(26495) /* Always initialize a member variable */                 \
    DOCTEST_MSVC_SUPPRESS_WARNING(26451) /* Arithmetic overflow ... */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(26444) /* Avoid unnamed objects with custom ctor and dtor... */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(26812) /* Prefer 'enum class' over 'enum' */

#define DOCTEST_SUPPRESS_COMMON_WARNINGS_POP                                                       \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                             \
    DOCTEST_GCC_SUPPRESS_WARNING_POP                                                               \
    DOCTEST_MSVC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdeprecated")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wctor-dtor-privacy")
DOCTEST_GCC_SUPPRESS_WARNING("-Wnon-virtual-dtor")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-promo")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4623) // default constructor was implicitly defined as deleted

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN                                 \
    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4548) /* before comma no effect; expected side - effect */       \
    DOCTEST_MSVC_SUPPRESS_WARNING(4265) /* virtual functions, but destructor is not virtual */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4986) /* exception specification does not match previous */      \
    DOCTEST_MSVC_SUPPRESS_WARNING(4350) /* 'member1' called instead of 'member2' */                \
    DOCTEST_MSVC_SUPPRESS_WARNING(4668) /* not defined as a preprocessor macro */                  \
    DOCTEST_MSVC_SUPPRESS_WARNING(4365) /* signed/unsigned mismatch */                             \
    DOCTEST_MSVC_SUPPRESS_WARNING(4774) /* format string not a string literal */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(4820) /* padding */                                              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4625) /* copy constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4626) /* assignment operator was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5027) /* move assignment operator implicitly deleted */          \
    DOCTEST_MSVC_SUPPRESS_WARNING(5026) /* move constructor was implicitly deleted */              \
    DOCTEST_MSVC_SUPPRESS_WARNING(4623) /* default constructor was implicitly deleted */           \
    DOCTEST_MSVC_SUPPRESS_WARNING(5039) /* pointer to pot. throwing function passed to extern C */ \
    DOCTEST_MSVC_SUPPRESS_WARNING(5045) /* Spectre mitigation for memory load */                   \
    DOCTEST_MSVC_SUPPRESS_WARNING(5105) /* macro producing 'defined' has undefined behavior */     \
    DOCTEST_MSVC_SUPPRESS_WARNING(4738) /* storing float result in memory, loss of performance */  \
    DOCTEST_MSVC_SUPPRESS_WARNING(5262) /* implicit fall-through */

#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END DOCTEST_MSVC_SUPPRESS_WARNING_POP

// =================================================================================================
// == FEATURE DETECTION ============================================================================
// =================================================================================================

// general compiler feature support table: https://en.cppreference.com/w/cpp/compiler_support
// MSVC C++11 feature support table: https://msdn.microsoft.com/en-us/library/hh567368.aspx
// GCC C++11 feature support table: https://gcc.gnu.org/projects/cxx-status.html
// MSVC version table:
// https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering
// MSVC++ 14.3 (17) _MSC_VER == 1930 (Visual Studio 2022)
// MSVC++ 14.2 (16) _MSC_VER == 1920 (Visual Studio 2019)
// MSVC++ 14.1 (15) _MSC_VER == 1910 (Visual Studio 2017)
// MSVC++ 14.0      _MSC_VER == 1900 (Visual Studio 2015)
// MSVC++ 12.0      _MSC_VER == 1800 (Visual Studio 2013)
// MSVC++ 11.0      _MSC_VER == 1700 (Visual Studio 2012)
// MSVC++ 10.0      _MSC_VER == 1600 (Visual Studio 2010)
// MSVC++ 9.0       _MSC_VER == 1500 (Visual Studio 2008)
// MSVC++ 8.0       _MSC_VER == 1400 (Visual Studio 2005)

// Universal Windows Platform support
#if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_WINDOWS_SEH
#endif // WINAPI_FAMILY
#if DOCTEST_MSVC &amp;&amp; !defined(DOCTEST_CONFIG_WINDOWS_SEH)
#define DOCTEST_CONFIG_WINDOWS_SEH
#endif // MSVC
#if defined(DOCTEST_CONFIG_NO_WINDOWS_SEH) &amp;&amp; defined(DOCTEST_CONFIG_WINDOWS_SEH)
#undef DOCTEST_CONFIG_WINDOWS_SEH
#endif // DOCTEST_CONFIG_NO_WINDOWS_SEH

#if !defined(_WIN32) &amp;&amp; !defined(__QNX__) &amp;&amp; !defined(DOCTEST_CONFIG_POSIX_SIGNALS) &amp;&amp;             \
        !defined(__EMSCRIPTEN__) &amp;&amp; !defined(__wasi__)
#define DOCTEST_CONFIG_POSIX_SIGNALS
#endif // _WIN32
#if defined(DOCTEST_CONFIG_NO_POSIX_SIGNALS) &amp;&amp; defined(DOCTEST_CONFIG_POSIX_SIGNALS)
#undef DOCTEST_CONFIG_POSIX_SIGNALS
#endif // DOCTEST_CONFIG_NO_POSIX_SIGNALS

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#if !defined(__cpp_exceptions) &amp;&amp; !defined(__EXCEPTIONS) &amp;&amp; !defined(_CPPUNWIND)                   \
        || defined(__wasi__)
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // no exceptions
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
#define DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#if defined(DOCTEST_CONFIG_NO_EXCEPTIONS) &amp;&amp; !defined(DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS)
#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS &amp;&amp; !DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef __wasi__
#define DOCTEST_CONFIG_NO_MULTITHREADING
#endif

#if defined(DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN) &amp;&amp; !defined(DOCTEST_CONFIG_IMPLEMENT)
#define DOCTEST_CONFIG_IMPLEMENT
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

#if defined(_WIN32) || defined(__CYGWIN__)
#if DOCTEST_MSVC
#define DOCTEST_SYMBOL_EXPORT __declspec(dllexport)
#define DOCTEST_SYMBOL_IMPORT __declspec(dllimport)
#else // MSVC
#define DOCTEST_SYMBOL_EXPORT __attribute__((dllexport))
#define DOCTEST_SYMBOL_IMPORT __attribute__((dllimport))
#endif // MSVC
#else  // _WIN32
#define DOCTEST_SYMBOL_EXPORT __attribute__((visibility("default")))
#define DOCTEST_SYMBOL_IMPORT
#endif // _WIN32

#ifdef DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#ifdef DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_EXPORT
#else // DOCTEST_CONFIG_IMPLEMENT
#define DOCTEST_INTERFACE DOCTEST_SYMBOL_IMPORT
#endif // DOCTEST_CONFIG_IMPLEMENT
#else  // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL
#define DOCTEST_INTERFACE
#endif // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL

// needed for extern template instantiations
// see https://github.com/fmtlib/fmt/issues/2228
#if DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL
#define DOCTEST_INTERFACE_DEF DOCTEST_INTERFACE
#else // DOCTEST_MSVC
#define DOCTEST_INTERFACE_DECL DOCTEST_INTERFACE
#define DOCTEST_INTERFACE_DEF
#endif // DOCTEST_MSVC

#define DOCTEST_EMPTY

#if DOCTEST_MSVC
#define DOCTEST_NOINLINE __declspec(noinline)
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#elif DOCTEST_CLANG &amp;&amp; DOCTEST_CLANG &lt; DOCTEST_COMPILER(3, 5, 0)
#define DOCTEST_NOINLINE
#define DOCTEST_UNUSED
#define DOCTEST_ALIGNMENT(x)
#else
#define DOCTEST_NOINLINE __attribute__((noinline))
#define DOCTEST_UNUSED __attribute__((unused))
#define DOCTEST_ALIGNMENT(x) __attribute__((aligned(x)))
#endif

#ifdef DOCTEST_CONFIG_NO_CONTRADICTING_INLINE
#define DOCTEST_INLINE_NOINLINE inline
#else
#define DOCTEST_INLINE_NOINLINE inline DOCTEST_NOINLINE
#endif

#ifndef DOCTEST_NORETURN
#if DOCTEST_MSVC &amp;&amp; (DOCTEST_MSVC &lt; DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NORETURN
#else // DOCTEST_MSVC
#define DOCTEST_NORETURN [[noreturn]]
#endif // DOCTEST_MSVC
#endif // DOCTEST_NORETURN

#ifndef DOCTEST_NOEXCEPT
#if DOCTEST_MSVC &amp;&amp; (DOCTEST_MSVC &lt; DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_NOEXCEPT
#else // DOCTEST_MSVC
#define DOCTEST_NOEXCEPT noexcept
#endif // DOCTEST_MSVC
#endif // DOCTEST_NOEXCEPT

#ifndef DOCTEST_CONSTEXPR
#if DOCTEST_MSVC &amp;&amp; (DOCTEST_MSVC &lt; DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_CONSTEXPR const
#define DOCTEST_CONSTEXPR_FUNC inline
#else // DOCTEST_MSVC
#define DOCTEST_CONSTEXPR constexpr
#define DOCTEST_CONSTEXPR_FUNC constexpr
#endif // DOCTEST_MSVC
#endif // DOCTEST_CONSTEXPR

#ifndef DOCTEST_NO_SANITIZE_INTEGER
#if DOCTEST_CLANG &gt;= DOCTEST_COMPILER(3, 7, 0)
#define DOCTEST_NO_SANITIZE_INTEGER __attribute__((no_sanitize("integer")))
#else
#define DOCTEST_NO_SANITIZE_INTEGER
#endif
#endif // DOCTEST_NO_SANITIZE_INTEGER

// =================================================================================================
// == FEATURE DETECTION END ========================================================================
// =================================================================================================

#define DOCTEST_DECLARE_INTERFACE(name)                                                            \
    virtual ~name();                                                                               \
    name() = default;                                                                              \
    name(const name&amp;) = delete;                                                                    \
    name(name&amp;&amp;) = delete;                                                                         \
    name&amp; operator=(const name&amp;) = delete;                                                         \
    name&amp; operator=(name&amp;&amp;) = delete;

#define DOCTEST_DEFINE_INTERFACE(name)                                                             \
    name::~name() = default;

// internal macros for string concatenation and anonymous variable name generation
#define DOCTEST_CAT_IMPL(s1, s2) s1##s2
#define DOCTEST_CAT(s1, s2) DOCTEST_CAT_IMPL(s1, s2)
#ifdef __COUNTER__ // not standard and may be missing for some compilers
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __COUNTER__)
#else // __COUNTER__
#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __LINE__)
#endif // __COUNTER__

#ifndef DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x&amp;
#else // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE
#define DOCTEST_REF_WRAP(x) x
#endif // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE

// not using __APPLE__ because... this is how Catch does it
#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
#define DOCTEST_PLATFORM_MAC
#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
#define DOCTEST_PLATFORM_IPHONE
#elif defined(_WIN32)
#define DOCTEST_PLATFORM_WINDOWS
#elif defined(__wasi__)
#define DOCTEST_PLATFORM_WASI
#else // DOCTEST_PLATFORM
#define DOCTEST_PLATFORM_LINUX
#endif // DOCTEST_PLATFORM

namespace doctest {
    namespace detail {
<span style = "background-color:#dfd">        static DOCTEST_CONSTEXPR int consume(const int*, int) noexcept { return 0; }</span>
    }
}

#define DOCTEST_GLOBAL_NO_WARNINGS(var, ...)                                                         \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wglobal-constructors")                                \
    static const int var = doctest::detail::consume(&amp;var, __VA_ARGS__);                              \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#ifndef DOCTEST_BREAK_INTO_DEBUGGER
// should probably take a look at https://github.com/scottt/debugbreak
#ifdef DOCTEST_PLATFORM_LINUX
#if defined(__GNUC__) &amp;&amp; (defined(__i386) || defined(__x86_64))
// Break at the location of the failing check if possible
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#else
#include &lt;signal.h&gt;
#define DOCTEST_BREAK_INTO_DEBUGGER() raise(SIGTRAP)
#endif
#elif defined(DOCTEST_PLATFORM_MAC)
#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64__) || defined(__i386)
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\n" : :) // NOLINT(hicpp-no-assembler)
#elif defined(__ppc__) || defined(__ppc64__)
// https://www.cocoawithlove.com/2008/03/break-into-debugger.html
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n": : : "memory","r0","r3","r4") // NOLINT(hicpp-no-assembler)
#else
#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("brk #0"); // NOLINT(hicpp-no-assembler)
#endif
#elif DOCTEST_MSVC
#define DOCTEST_BREAK_INTO_DEBUGGER() __debugbreak()
#elif defined(__MINGW32__)
DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wredundant-decls")
extern "C" __declspec(dllimport) void __stdcall DebugBreak();
DOCTEST_GCC_SUPPRESS_WARNING_POP
#define DOCTEST_BREAK_INTO_DEBUGGER() ::DebugBreak()
#else // linux
#define DOCTEST_BREAK_INTO_DEBUGGER() (static_cast&lt;void&gt;(0))
#endif // linux
#endif // DOCTEST_BREAK_INTO_DEBUGGER

// this is kept here for backwards compatibility since the config option was changed
#ifdef DOCTEST_CONFIG_USE_IOSFWD
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // DOCTEST_CONFIG_USE_IOSFWD

// for clang - always include ciso646 (which drags some std stuff) because
// we want to check if we are using libc++ with the _LIBCPP_VERSION macro in
// which case we don't want to forward declare stuff from std - for reference:
// https://github.com/doctest/doctest/issues/126
// https://github.com/doctest/doctest/issues/356
#if DOCTEST_CLANG
#include &lt;ciso646&gt;
#endif // clang

#ifdef _LIBCPP_VERSION
#ifndef DOCTEST_CONFIG_USE_STD_HEADERS
#define DOCTEST_CONFIG_USE_STD_HEADERS
#endif
#endif // _LIBCPP_VERSION

#ifdef DOCTEST_CONFIG_USE_STD_HEADERS
#ifndef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN
#include &lt;cstddef&gt;
#include &lt;ostream&gt;
#include &lt;istream&gt;
DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END
#else // DOCTEST_CONFIG_USE_STD_HEADERS

// Forward declaring 'X' in namespace std is not permitted by the C++ Standard.
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4643)

namespace std { // NOLINT(cert-dcl58-cpp)
    typedef decltype(nullptr) nullptr_t; // NOLINT(modernize-use-using)
    typedef decltype(sizeof(void*)) size_t; // NOLINT(modernize-use-using)
    template &lt;class charT&gt;
    struct char_traits;
    template &lt;&gt;
    struct char_traits&lt;char&gt;;
    template &lt;class charT, class traits&gt;
    class basic_ostream; // NOLINT(fuchsia-virtual-inheritance)
    typedef basic_ostream&lt;char, char_traits&lt;char&gt;&gt; ostream; // NOLINT(modernize-use-using)
    template&lt;class traits&gt;
    // NOLINTNEXTLINE
    basic_ostream&lt;char, traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char, traits&gt;&amp;, const char*);
    template &lt;class charT, class traits&gt;
    class basic_istream;
    typedef basic_istream&lt;char, char_traits&lt;char&gt;&gt; istream; // NOLINT(modernize-use-using)
    template &lt;class... Types&gt;
    class tuple;
#if DOCTEST_MSVC &gt;= DOCTEST_COMPILER(19, 20, 0)
    // see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
    template &lt;class Ty&gt;
    class allocator;
    template &lt;class Elem, class Traits, class Alloc&gt;
    class basic_string;
    using string = basic_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;;
#endif // VS 2019
} // namespace std

DOCTEST_MSVC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_USE_STD_HEADERS

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#include &lt;type_traits&gt;
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

namespace doctest {

    using std::size_t;

    DOCTEST_INTERFACE extern bool is_running_in_test;

#ifndef DOCTEST_CONFIG_STRING_SIZE_TYPE
#define DOCTEST_CONFIG_STRING_SIZE_TYPE unsigned
#endif

    // A 24 byte string class (can be as small as 17 for x64 and 13 for x86) that can hold strings with length
    // of up to 23 chars on the stack before going on the heap - the last byte of the buffer is used for:
    // - "is small" bit - the highest bit - if "0" then it is small - otherwise its "1" (128)
    // - if small - capacity left before going on the heap - using the lowest 5 bits
    // - if small - 2 bits are left unused - the second and third highest ones
    // - if small - acts as a null terminator if strlen() is 23 (24 including the null terminator)
    //              and the "is small" bit remains "0" ("as well as the capacity left") so its OK
    // Idea taken from this lecture about the string implementation of facebook/folly - fbstring
    // https://www.youtube.com/watch?v=kPR8h4-qZdk
    // TODO:
    // - optimizations - like not deleting memory unnecessarily in operator= and etc.
    // - resize/reserve/clear
    // - replace
    // - back/front
    // - iterator stuff
    // - find &amp; friends
    // - push_back/pop_back
    // - assign/insert/erase
    // - relational operators as free functions - taking const char* as one of the params
    class DOCTEST_INTERFACE String
    {
    public:
        using size_type = DOCTEST_CONFIG_STRING_SIZE_TYPE;

    private:
        static DOCTEST_CONSTEXPR size_type len = 24;      //!OCLINT avoid private static members
        static DOCTEST_CONSTEXPR size_type last = len - 1; //!OCLINT avoid private static members

        struct view // len should be more than sizeof(view) - because of the final byte for flags
        {
            char* ptr;
            size_type size;
            size_type capacity;
        };

        union
        {
            char buf[len]; // NOLINT(*-avoid-c-arrays)
            view data;
        };

        char* allocate(size_type sz);

<span style = "background-color:#dfd">        bool isOnStack() const noexcept { return (buf[last] &amp; 128) == 0; }</span>
        void setOnHeap() noexcept;
        void setLast(size_type in = last) noexcept;
        void setSize(size_type sz) noexcept;

        void copy(const String&amp; other);

    public:
        static DOCTEST_CONSTEXPR size_type npos = static_cast&lt;size_type&gt;(-1);

        String() noexcept;
        ~String();

        // cppcheck-suppress noExplicitConstructor
        String(const char* in);
        String(const char* in, size_type in_size);

        String(std::istream&amp; in, size_type in_size);

        String(const String&amp; other);
        String&amp; operator=(const String&amp; other);

        String&amp; operator+=(const String&amp; other);

        String(String&amp;&amp; other) noexcept;
        String&amp; operator=(String&amp;&amp; other) noexcept;

        char  operator[](size_type i) const;
        char&amp; operator[](size_type i);

        // the only functions I'm willing to leave in the interface - available for inlining
<span style = "background-color:#dfd">        const char* c_str() const { return const_cast&lt;String*&gt;(this)-&gt;c_str(); } // NOLINT
        char* c_str() {
            if (isOnStack()) {
                return reinterpret_cast&lt;char*&gt;(buf);</span>
            }
<span style = "background-color:#dfd">            return data.ptr;
        }</span>

        size_type size() const;
        size_type capacity() const;

        String substr(size_type pos, size_type cnt = npos)&amp;&amp;;
        String substr(size_type pos, size_type cnt = npos) const&amp;;

        size_type find(char ch, size_type pos = 0) const;
        size_type rfind(char ch, size_type pos = npos) const;

        int compare(const char* other, bool no_case = false) const;
        int compare(const String&amp; other, bool no_case = false) const;

        friend DOCTEST_INTERFACE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const String&amp; in);
    };

    DOCTEST_INTERFACE String operator+(const String&amp; lhs, const String&amp; rhs);

    DOCTEST_INTERFACE bool operator==(const String&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator!=(const String&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator&lt;(const String&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator&gt;(const String&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator&lt;=(const String&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator&gt;=(const String&amp; lhs, const String&amp; rhs);

    class DOCTEST_INTERFACE Contains {
    public:
        explicit Contains(const String&amp; string);

        bool checkWith(const String&amp; other) const;

        String string;
    };

    DOCTEST_INTERFACE String toString(const Contains&amp; in);

    DOCTEST_INTERFACE bool operator==(const String&amp; lhs, const Contains&amp; rhs);
    DOCTEST_INTERFACE bool operator==(const Contains&amp; lhs, const String&amp; rhs);
    DOCTEST_INTERFACE bool operator!=(const String&amp; lhs, const Contains&amp; rhs);
    DOCTEST_INTERFACE bool operator!=(const Contains&amp; lhs, const String&amp; rhs);

    namespace Color {
        enum Enum
        {
            None = 0,
            White,
            Red,
            Green,
            Blue,
            Cyan,
            Yellow,
            Grey,

            Bright = 0x10,

            BrightRed = Bright | Red,
            BrightGreen = Bright | Green,
            LightGrey = Bright | Grey,
            BrightWhite = Bright | White
        };

        DOCTEST_INTERFACE std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Color::Enum code);
    } // namespace Color

    namespace assertType {
        enum Enum
        {
            // macro traits

            is_warn = 1,
            is_check = 2 * is_warn,
            is_require = 2 * is_check,

            is_normal = 2 * is_require,
            is_throws = 2 * is_normal,
            is_throws_as = 2 * is_throws,
            is_throws_with = 2 * is_throws_as,
            is_nothrow = 2 * is_throws_with,

            is_false = 2 * is_nothrow,
            is_unary = 2 * is_false, // not checked anywhere - used just to distinguish the types

            is_eq = 2 * is_unary,
            is_ne = 2 * is_eq,

            is_lt = 2 * is_ne,
            is_gt = 2 * is_lt,

            is_ge = 2 * is_gt,
            is_le = 2 * is_ge,

            // macro types

            DT_WARN = is_normal | is_warn,
            DT_CHECK = is_normal | is_check,
            DT_REQUIRE = is_normal | is_require,

            DT_WARN_FALSE = is_normal | is_false | is_warn,
            DT_CHECK_FALSE = is_normal | is_false | is_check,
            DT_REQUIRE_FALSE = is_normal | is_false | is_require,

            DT_WARN_THROWS = is_throws | is_warn,
            DT_CHECK_THROWS = is_throws | is_check,
            DT_REQUIRE_THROWS = is_throws | is_require,

            DT_WARN_THROWS_AS = is_throws_as | is_warn,
            DT_CHECK_THROWS_AS = is_throws_as | is_check,
            DT_REQUIRE_THROWS_AS = is_throws_as | is_require,

            DT_WARN_THROWS_WITH = is_throws_with | is_warn,
            DT_CHECK_THROWS_WITH = is_throws_with | is_check,
            DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,

            DT_WARN_THROWS_WITH_AS = is_throws_with | is_throws_as | is_warn,
            DT_CHECK_THROWS_WITH_AS = is_throws_with | is_throws_as | is_check,
            DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,

            DT_WARN_NOTHROW = is_nothrow | is_warn,
            DT_CHECK_NOTHROW = is_nothrow | is_check,
            DT_REQUIRE_NOTHROW = is_nothrow | is_require,

            DT_WARN_EQ = is_normal | is_eq | is_warn,
            DT_CHECK_EQ = is_normal | is_eq | is_check,
            DT_REQUIRE_EQ = is_normal | is_eq | is_require,

            DT_WARN_NE = is_normal | is_ne | is_warn,
            DT_CHECK_NE = is_normal | is_ne | is_check,
            DT_REQUIRE_NE = is_normal | is_ne | is_require,

            DT_WARN_GT = is_normal | is_gt | is_warn,
            DT_CHECK_GT = is_normal | is_gt | is_check,
            DT_REQUIRE_GT = is_normal | is_gt | is_require,

            DT_WARN_LT = is_normal | is_lt | is_warn,
            DT_CHECK_LT = is_normal | is_lt | is_check,
            DT_REQUIRE_LT = is_normal | is_lt | is_require,

            DT_WARN_GE = is_normal | is_ge | is_warn,
            DT_CHECK_GE = is_normal | is_ge | is_check,
            DT_REQUIRE_GE = is_normal | is_ge | is_require,

            DT_WARN_LE = is_normal | is_le | is_warn,
            DT_CHECK_LE = is_normal | is_le | is_check,
            DT_REQUIRE_LE = is_normal | is_le | is_require,

            DT_WARN_UNARY = is_normal | is_unary | is_warn,
            DT_CHECK_UNARY = is_normal | is_unary | is_check,
            DT_REQUIRE_UNARY = is_normal | is_unary | is_require,

            DT_WARN_UNARY_FALSE = is_normal | is_false | is_unary | is_warn,
            DT_CHECK_UNARY_FALSE = is_normal | is_false | is_unary | is_check,
            DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,
        };
    } // namespace assertType

    DOCTEST_INTERFACE const char* assertString(assertType::Enum at);
    DOCTEST_INTERFACE const char* failureString(assertType::Enum at);
    DOCTEST_INTERFACE const char* skipPathFromFilename(const char* file);

    struct DOCTEST_INTERFACE TestCaseData
    {
        String      m_file;       // the file in which the test was registered (using String - see #350)
        unsigned    m_line;       // the line where the test was registered
        const char* m_name;       // name of the test case
        const char* m_test_suite; // the test suite in which the test was added
        const char* m_description;
        bool        m_skip;
        bool        m_no_breaks;
        bool        m_no_output;
        bool        m_may_fail;
        bool        m_should_fail;
        int         m_expected_failures;
        double      m_timeout;
    };

    struct DOCTEST_INTERFACE AssertData
    {
        // common - for all asserts
        const TestCaseData* m_test_case;
        assertType::Enum    m_at;
        const char* m_file;
        int                 m_line;
        const char* m_expr;
        bool                m_failed;

        // exception-related - for all asserts
        bool   m_threw;
        String m_exception;

        // for normal asserts
        String m_decomp;

        // for specific exception-related asserts
        bool           m_threw_as;
        const char* m_exception_type;

        class DOCTEST_INTERFACE StringContains {
        private:
            Contains content;
            bool isContains;

        public:
<span style = "background-color:#dfd">            StringContains(const String&amp; str) : content(str), isContains(false) { }</span>
<span style = "background-color:#fdd">            StringContains(Contains cntn) : content(static_cast&lt;Contains&amp;&amp;&gt;(cntn)), isContains(true) { }</span>

<span style = "background-color:#fdd">            bool check(const String&amp; str) { return isContains ? (content == str) : (content.string == str); }</span>

            operator const String&amp; () const { return content.string; }

<span style = "background-color:#fdd">            const char* c_str() const { return content.string.c_str(); }</span>
        } m_exception_string;

        AssertData(assertType::Enum at, const char* file, int line, const char* expr,
            const char* exception_type, const StringContains&amp; exception_string);
    };

    struct DOCTEST_INTERFACE MessageData
    {
        String           m_string;
        const char* m_file;
        int              m_line;
        assertType::Enum m_severity;
    };

    struct DOCTEST_INTERFACE SubcaseSignature
    {
        String      m_name;
        const char* m_file;
        int         m_line;

        bool operator==(const SubcaseSignature&amp; other) const;
        bool operator&lt;(const SubcaseSignature&amp; other) const;
    };

    struct DOCTEST_INTERFACE IContextScope
    {
<span style = "background-color:#fdd">        DOCTEST_DECLARE_INTERFACE(IContextScope)</span>
            virtual void stringify(std::ostream*) const = 0;
    };

    namespace detail {
        struct DOCTEST_INTERFACE TestCase;
    } // namespace detail

    struct ContextOptions //!OCLINT too many fields
    {
        std::ostream* cout = nullptr; // stdout stream
        String        binary_name;    // the test binary name

        const detail::TestCase* currentTest = nullptr;

        // == parameters from the command line
        String   out;       // output filename
        String   order_by;  // how tests should be ordered
        unsigned rand_seed; // the seed for rand ordering

        unsigned first; // the first (matching) test to be executed
        unsigned last;  // the last (matching) test to be executed

        int abort_after;           // stop tests after this many failed assertions
        int subcase_filter_levels; // apply the subcase filters for the first N levels

        bool success;              // include successful assertions in output
        bool case_sensitive;       // if filtering should be case sensitive
        bool exit;                 // if the program should be exited after the tests are ran/whatever
        bool duration;             // print the time duration of each test case
        bool minimal;              // minimal console output (only test failures)
        bool quiet;                // no console output
        bool no_throw;             // to skip exceptions-related assertion macros
        bool no_exitcode;          // if the framework should return 0 as the exitcode
        bool no_run;               // to not run the tests at all (can be done with an "*" exclude)
        bool no_intro;             // to not print the intro of the framework
        bool no_version;           // to not print the version of the framework
        bool no_colors;            // if output to the console should be colorized
        bool force_colors;         // forces the use of colors even when a tty cannot be detected
        bool no_breaks;            // to not break into the debugger
        bool no_skip;              // don't skip test cases which are marked to be skipped
        bool gnu_file_line;        // if line numbers should be surrounded with :x: and not (x):
        bool no_path_in_filenames; // if the path to files should be removed from the output
        bool no_line_numbers;      // if source code line numbers should be omitted from the output
        bool no_debug_output;      // no output in the debug console when a debugger is attached
        bool no_skipped_summary;   // don't print "skipped" in the summary !!! UNDOCUMENTED !!!
        bool no_time_in_output;    // omit any time/timestamps from output !!! UNDOCUMENTED !!!

        bool help;             // to print the help
        bool version;          // to print the version
        bool count;            // if only the count of matching tests is to be retrieved
        bool list_test_cases;  // to list all tests matching the filters
        bool list_test_suites; // to list all suites matching the filters
        bool list_reporters;   // lists all registered reporters
    };

    namespace detail {
        namespace types {
#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
            using namespace std;
#else
            template &lt;bool COND, typename T = void&gt;
            struct enable_if { };

            template &lt;typename T&gt;
            struct enable_if&lt;true, T&gt; { using type = T; };

            struct true_type { static DOCTEST_CONSTEXPR bool value = true; };
            struct false_type { static DOCTEST_CONSTEXPR bool value = false; };

            template &lt;typename T&gt; struct remove_reference { using type = T; };
            template &lt;typename T&gt; struct remove_reference&lt;T&amp;&gt; { using type = T; };
            template &lt;typename T&gt; struct remove_reference&lt;T&amp;&amp;&gt; { using type = T; };

            template &lt;typename T&gt; struct is_rvalue_reference : false_type { };
            template &lt;typename T&gt; struct is_rvalue_reference&lt;T&amp;&amp;&gt; : true_type { };

            template&lt;typename T&gt; struct remove_const { using type = T; };
            template &lt;typename T&gt; struct remove_const&lt;const T&gt; { using type = T; };

            // Compiler intrinsics
            template &lt;typename T&gt; struct is_enum { static DOCTEST_CONSTEXPR bool value = __is_enum(T); };
            template &lt;typename T&gt; struct underlying_type { using type = __underlying_type(T); };

            template &lt;typename T&gt; struct is_pointer : false_type { };
            template &lt;typename T&gt; struct is_pointer&lt;T*&gt; : true_type { };

            template &lt;typename T&gt; struct is_array : false_type { };
            // NOLINTNEXTLINE(*-avoid-c-arrays)
            template &lt;typename T, size_t SIZE&gt; struct is_array&lt;T[SIZE]&gt; : true_type { };
#endif
        }

        // &lt;utility&gt;
        template &lt;typename T&gt;
        T&amp;&amp; declval();

        template &lt;class T&gt;
<span style = "background-color:#dfd">        DOCTEST_CONSTEXPR_FUNC T&amp;&amp; forward(typename types::remove_reference&lt;T&gt;::type&amp; t) DOCTEST_NOEXCEPT {
            return static_cast&lt;T&amp;&amp;&gt;(t);
        }</span>

        template &lt;class T&gt;
        DOCTEST_CONSTEXPR_FUNC T&amp;&amp; forward(typename types::remove_reference&lt;T&gt;::type&amp;&amp; t) DOCTEST_NOEXCEPT {
            return static_cast&lt;T&amp;&amp;&gt;(t);
        }

        template &lt;typename T&gt;
        struct deferred_false : types::false_type { };

        // MSVS 2015 :(
#if !DOCTEST_CLANG &amp;&amp; defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1900
        template &lt;typename T, typename = void&gt;
        struct has_global_insertion_operator : types::false_type { };

        template &lt;typename T&gt;
        struct has_global_insertion_operator&lt;T, decltype(::operator&lt;&lt;(declval&lt;std::ostream&amp;&gt;(), declval&lt;const T&amp;&gt;()), void())&gt; : types::true_type { };

        template &lt;typename T, typename = void&gt;
        struct has_insertion_operator { static DOCTEST_CONSTEXPR bool value = has_global_insertion_operator&lt;T&gt;::value; };

        template &lt;typename T, bool global&gt;
        struct insert_hack;

        template &lt;typename T&gt;
        struct insert_hack&lt;T, true&gt; {
            static void insert(std::ostream&amp; os, const T&amp; t) { ::operator&lt;&lt;(os, t); }
        };

        template &lt;typename T&gt;
        struct insert_hack&lt;T, false&gt; {
            static void insert(std::ostream&amp; os, const T&amp; t) { operator&lt;&lt;(os, t); }
        };

        template &lt;typename T&gt;
        using insert_hack_t = insert_hack&lt;T, has_global_insertion_operator&lt;T&gt;::value&gt;;
#else
        template &lt;typename T, typename = void&gt;
        struct has_insertion_operator : types::false_type { };
#endif

        template &lt;typename T&gt;
        struct has_insertion_operator&lt;T, decltype(operator&lt;&lt;(declval&lt;std::ostream&amp;&gt;(), declval&lt;const T&amp;&gt;()), void())&gt; : types::true_type { };

        template &lt;typename T&gt;
        struct should_stringify_as_underlying_type {
            static DOCTEST_CONSTEXPR bool value = detail::types::is_enum&lt;T&gt;::value &amp;&amp; !doctest::detail::has_insertion_operator&lt;T&gt;::value;
        };

        DOCTEST_INTERFACE std::ostream* tlssPush();
        DOCTEST_INTERFACE String tlssPop();

        template &lt;bool C&gt;
        struct StringMakerBase {
            template &lt;typename T&gt;
            static String convert(const DOCTEST_REF_WRAP(T)) {
#ifdef DOCTEST_CONFIG_REQUIRE_STRINGIFICATION_FOR_ALL_USED_TYPES
                static_assert(deferred_false&lt;T&gt;::value, "No stringification detected for type T. See string conversion manual");
#endif
                return "{?}";
            }
        };

        template &lt;typename T&gt;
        struct filldata;

        template &lt;typename T&gt;
<span style = "background-color:#fdd">        void filloss(std::ostream* stream, const T&amp; in) {
            filldata&lt;T&gt;::fill(stream, in);
        }</span>

        template &lt;typename T, size_t N&gt;
        void filloss(std::ostream* stream, const T(&amp;in)[N]) { // NOLINT(*-avoid-c-arrays)
            // T[N], T(&amp;)[N], T(&amp;&amp;)[N] have same behaviour.
            // Hence remove reference.
            filloss&lt;typename types::remove_reference&lt;decltype(in)&gt;::type&gt;(stream, in);
        }

        template &lt;typename T&gt;
<span style = "background-color:#fdd">        String toStream(const T&amp; in) {
            std::ostream* stream = tlssPush();
            filloss(stream, in);
            return tlssPop();
        }</span>

        template &lt;&gt;
        struct StringMakerBase&lt;true&gt; {
            template &lt;typename T&gt;
<span style = "background-color:#fdd">            static String convert(const DOCTEST_REF_WRAP(T) in) {
                return toStream(in);
            }</span>
        };
    } // namespace detail

    template &lt;typename T&gt;
    struct StringMaker : public detail::StringMakerBase&lt;
        detail::has_insertion_operator&lt;T&gt;::value || detail::types::is_pointer&lt;T&gt;::value || detail::types::is_array&lt;T&gt;::value&gt;
    {};

#ifndef DOCTEST_STRINGIFY
#ifdef DOCTEST_CONFIG_DOUBLE_STRINGIFY
#define DOCTEST_STRINGIFY(...) toString(toString(__VA_ARGS__))
#else
#define DOCTEST_STRINGIFY(...) toString(__VA_ARGS__)
#endif
#endif

    template &lt;typename T&gt;
    String toString() {
#if DOCTEST_CLANG == 0 &amp;&amp; DOCTEST_GCC == 0 &amp;&amp; DOCTEST_ICC == 0
        String ret = __FUNCSIG__; // class doctest::String __cdecl doctest::toString&lt;TYPE&gt;(void)
        String::size_type beginPos = ret.find('&lt;');
        return ret.substr(beginPos + 1, ret.size() - beginPos - static_cast&lt;String::size_type&gt;(sizeof("&gt;(void)")));
#else
        String ret = __PRETTY_FUNCTION__; // doctest::String toString() [with T = TYPE]
        String::size_type begin = ret.find('=') + 2;
        return ret.substr(begin, ret.size() - begin - 1);
#endif
    }

    template &lt;typename T, typename detail::types::enable_if&lt;!detail::should_stringify_as_underlying_type&lt;T&gt;::value, bool&gt;::type = true&gt;
<span style = "background-color:#fdd">    String toString(const DOCTEST_REF_WRAP(T) value) {
        return StringMaker&lt;T&gt;::convert(value);
    }</span>

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    DOCTEST_INTERFACE String toString(const char* in);
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC &gt;= DOCTEST_COMPILER(19, 20, 0)
    // see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
    DOCTEST_INTERFACE String toString(const std::string&amp; in);
#endif // VS 2019

    DOCTEST_INTERFACE String toString(String in);

    DOCTEST_INTERFACE String toString(std::nullptr_t);

    DOCTEST_INTERFACE String toString(bool in);

    DOCTEST_INTERFACE String toString(float in);
    DOCTEST_INTERFACE String toString(double in);
    DOCTEST_INTERFACE String toString(double long in);

    DOCTEST_INTERFACE String toString(char in);
    DOCTEST_INTERFACE String toString(char signed in);
    DOCTEST_INTERFACE String toString(char unsigned in);
    DOCTEST_INTERFACE String toString(short in);
    DOCTEST_INTERFACE String toString(short unsigned in);
    DOCTEST_INTERFACE String toString(signed in);
    DOCTEST_INTERFACE String toString(unsigned in);
    DOCTEST_INTERFACE String toString(long in);
    DOCTEST_INTERFACE String toString(long unsigned in);
    DOCTEST_INTERFACE String toString(long long in);
    DOCTEST_INTERFACE String toString(long long unsigned in);

    template &lt;typename T, typename detail::types::enable_if&lt;detail::should_stringify_as_underlying_type&lt;T&gt;::value, bool&gt;::type = true&gt;
    String toString(const DOCTEST_REF_WRAP(T) value) {
        using UT = typename detail::types::underlying_type&lt;T&gt;::type;
        return (DOCTEST_STRINGIFY(static_cast&lt;UT&gt;(value)));
    }

    namespace detail {
        template &lt;typename T&gt;
        struct filldata
        {
<span style = "background-color:#fdd">            static void fill(std::ostream* stream, const T&amp; in) {</span>
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1900
                insert_hack_t&lt;T&gt;::insert(*stream, in);
#else
<span style = "background-color:#fdd">                operator&lt;&lt;(*stream, in);</span>
#endif
<span style = "background-color:#fdd">            }</span>
        };

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
            // NOLINTBEGIN(*-avoid-c-arrays)
            template &lt;typename T, size_t N&gt;
        struct filldata&lt;T[N]&gt; {
            static void fill(std::ostream* stream, const T(&amp;in)[N]) {
                *stream &lt;&lt; "[";
                for (size_t i = 0; i &lt; N; i++) {
                    if (i != 0) { *stream &lt;&lt; ", "; }
                    *stream &lt;&lt; (DOCTEST_STRINGIFY(in[i]));
                }
                *stream &lt;&lt; "]";
            }
        };
        // NOLINTEND(*-avoid-c-arrays)
        DOCTEST_MSVC_SUPPRESS_WARNING_POP

            // Specialized since we don't want the terminating null byte!
        // NOLINTBEGIN(*-avoid-c-arrays)
            template &lt;size_t N&gt;
        struct filldata&lt;const char[N]&gt; {
            static void fill(std::ostream* stream, const char(&amp;in)[N]) {
                *stream &lt;&lt; String(in, in[N - 1] ? N : N - 1);
            } // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)
        };
        // NOLINTEND(*-avoid-c-arrays)

        template &lt;&gt;
        struct filldata&lt;const void*&gt; {
            static void fill(std::ostream* stream, const void* in);
        };

        template &lt;typename T&gt;
        struct filldata&lt;T*&gt; {
            DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4180)
<span style = "background-color:#fdd">                static void fill(std::ostream* stream, const T* in) {</span>
                DOCTEST_MSVC_SUPPRESS_WARNING_POP
                    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wmicrosoft-cast")
<span style = "background-color:#fdd">                    filldata&lt;const void*&gt;::fill(stream,</span>
#if DOCTEST_GCC == 0 || DOCTEST_GCC &gt;= DOCTEST_COMPILER(4, 9, 0)
                        reinterpret_cast&lt;const void*&gt;(in)
#else
                        * reinterpret_cast&lt;const void* const*&gt;(&amp;in)
#endif
                    );
                DOCTEST_CLANG_SUPPRESS_WARNING_POP
<span style = "background-color:#fdd">            }</span>
        };
    }

    struct DOCTEST_INTERFACE Approx
    {
        Approx(double value);

        Approx operator()(double value) const;

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
        template &lt;typename T&gt;
        explicit Approx(const T&amp; value,
            typename detail::types::enable_if&lt;std::is_constructible&lt;double, T&gt;::value&gt;::type* =
            static_cast&lt;T*&gt;(nullptr)) {
            *this = static_cast&lt;double&gt;(value);
        }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

        Approx&amp; epsilon(double newEpsilon);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
        template &lt;typename T&gt;
        typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value, Approx&amp;&gt;::type epsilon(
            const T&amp; newEpsilon) {
            m_epsilon = static_cast&lt;double&gt;(newEpsilon);
            return *this;
        }
#endif //  DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

        Approx&amp; scale(double newScale);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
        template &lt;typename T&gt;
        typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value, Approx&amp;&gt;::type scale(
            const T&amp; newScale) {
            m_scale = static_cast&lt;double&gt;(newScale);
            return *this;
        }
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

        // clang-format off
        DOCTEST_INTERFACE friend bool operator==(double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator==(const Approx&amp; lhs, double rhs);
        DOCTEST_INTERFACE friend bool operator!=(double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator!=(const Approx&amp; lhs, double rhs);
        DOCTEST_INTERFACE friend bool operator&lt;=(double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator&lt;=(const Approx&amp; lhs, double rhs);
        DOCTEST_INTERFACE friend bool operator&gt;=(double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator&gt;=(const Approx&amp; lhs, double rhs);
        DOCTEST_INTERFACE friend bool operator&lt; (double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator&lt; (const Approx&amp; lhs, double rhs);
        DOCTEST_INTERFACE friend bool operator&gt; (double lhs, const Approx&amp; rhs);
        DOCTEST_INTERFACE friend bool operator&gt; (const Approx&amp; lhs, double rhs);

#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS
#define DOCTEST_APPROX_PREFIX \
    template &lt;typename T&gt; friend typename std::enable_if&lt;std::is_constructible&lt;double, T&gt;::value, bool&gt;::type

        DOCTEST_APPROX_PREFIX operator==(const T&amp; lhs, const Approx&amp; rhs) { return operator==(static_cast&lt;double&gt;(lhs), rhs); }
        DOCTEST_APPROX_PREFIX operator==(const Approx&amp; lhs, const T&amp; rhs) { return operator==(rhs, lhs); }
        DOCTEST_APPROX_PREFIX operator!=(const T&amp; lhs, const Approx&amp; rhs) { return !operator==(lhs, rhs); }
        DOCTEST_APPROX_PREFIX operator!=(const Approx&amp; lhs, const T&amp; rhs) { return !operator==(rhs, lhs); }
        DOCTEST_APPROX_PREFIX operator&lt;=(const T&amp; lhs, const Approx&amp; rhs) { return static_cast&lt;double&gt;(lhs) &lt; rhs.m_value || lhs == rhs; }
        DOCTEST_APPROX_PREFIX operator&lt;=(const Approx&amp; lhs, const T&amp; rhs) { return lhs.m_value &lt; static_cast&lt;double&gt;(rhs) || lhs == rhs; }
        DOCTEST_APPROX_PREFIX operator&gt;=(const T&amp; lhs, const Approx&amp; rhs) { return static_cast&lt;double&gt;(lhs) &gt; rhs.m_value || lhs == rhs; }
        DOCTEST_APPROX_PREFIX operator&gt;=(const Approx&amp; lhs, const T&amp; rhs) { return lhs.m_value &gt; static_cast&lt;double&gt;(rhs) || lhs == rhs; }
        DOCTEST_APPROX_PREFIX operator&lt; (const T&amp; lhs, const Approx&amp; rhs) { return static_cast&lt;double&gt;(lhs) &lt; rhs.m_value &amp;&amp; lhs != rhs; }
        DOCTEST_APPROX_PREFIX operator&lt; (const Approx&amp; lhs, const T&amp; rhs) { return lhs.m_value &lt; static_cast&lt;double&gt;(rhs) &amp;&amp; lhs != rhs; }
        DOCTEST_APPROX_PREFIX operator&gt; (const T&amp; lhs, const Approx&amp; rhs) { return static_cast&lt;double&gt;(lhs) &gt; rhs.m_value &amp;&amp; lhs != rhs; }
        DOCTEST_APPROX_PREFIX operator&gt; (const Approx&amp; lhs, const T&amp; rhs) { return lhs.m_value &gt; static_cast&lt;double&gt;(rhs) &amp;&amp; lhs != rhs; }
#undef DOCTEST_APPROX_PREFIX
#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS

        // clang-format on

        double m_epsilon;
        double m_scale;
        double m_value;
    };

    DOCTEST_INTERFACE String toString(const Approx&amp; in);

    DOCTEST_INTERFACE const ContextOptions* getContextOptions();

    template &lt;typename F&gt;
    struct DOCTEST_INTERFACE_DECL IsNaN
    {
        F value; bool flipped;
<span style = "background-color:#fdd">        IsNaN(F f, bool flip = false) : value(f), flipped(flip) { }
        IsNaN&lt;F&gt; operator!() const { return { value, !flipped }; }</span>
        operator bool() const;
    };
#ifndef __MINGW32__
    extern template struct DOCTEST_INTERFACE_DECL IsNaN&lt;float&gt;;
    extern template struct DOCTEST_INTERFACE_DECL IsNaN&lt;double&gt;;
    extern template struct DOCTEST_INTERFACE_DECL IsNaN&lt;long double&gt;;
#endif
    DOCTEST_INTERFACE String toString(IsNaN&lt;float&gt; in);
    DOCTEST_INTERFACE String toString(IsNaN&lt;double&gt; in);
    DOCTEST_INTERFACE String toString(IsNaN&lt;double long&gt; in);

#ifndef DOCTEST_CONFIG_DISABLE

    namespace detail {
        // clang-format off
#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
        template&lt;class T&gt;               struct decay_array { using type = T; };
        template&lt;class T, unsigned N&gt;   struct decay_array&lt;T[N]&gt; { using type = T*; };
        template&lt;class T&gt;               struct decay_array&lt;T[]&gt; { using type = T*; };

        template&lt;class T&gt;   struct not_char_pointer { static DOCTEST_CONSTEXPR int value = 1; };
        template&lt;&gt;          struct not_char_pointer&lt;char*&gt; { static DOCTEST_CONSTEXPR int value = 0; };
        template&lt;&gt;          struct not_char_pointer&lt;const char*&gt; { static DOCTEST_CONSTEXPR int value = 0; };

        template&lt;class T&gt; struct can_use_op : public not_char_pointer&lt;typename decay_array&lt;T&gt;::type&gt; {};
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
        // clang-format on

        struct DOCTEST_INTERFACE TestFailureException
        {
        };

        DOCTEST_INTERFACE bool checkIfShouldThrow(assertType::Enum at);

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
        DOCTEST_NORETURN
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
            DOCTEST_INTERFACE void throwException();

        struct DOCTEST_INTERFACE Subcase
        {
            SubcaseSignature m_signature;
<span style = "background-color:#dfd">            bool             m_entered = false;</span>

            Subcase(const String&amp; name, const char* file, int line);
            Subcase(const Subcase&amp;) = delete;
            Subcase(Subcase&amp;&amp;) = delete;
            Subcase&amp; operator=(const Subcase&amp;) = delete;
            Subcase&amp; operator=(Subcase&amp;&amp;) = delete;
            ~Subcase();

            operator bool() const;

        private:
            bool checkFilters();
        };

        template &lt;typename L, typename R&gt;
        String stringifyBinaryExpr(const DOCTEST_REF_WRAP(L) lhs, const char* op,
<span style = "background-color:#fdd">            const DOCTEST_REF_WRAP(R) rhs) {
            return (DOCTEST_STRINGIFY(lhs)) + op + (DOCTEST_STRINGIFY(rhs));
        }</span>

#if DOCTEST_CLANG &amp;&amp; DOCTEST_CLANG &lt; DOCTEST_COMPILER(3, 6, 0)
        DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-comparison")
#endif

            // This will check if there is any way it could find a operator like member or friend and uses it.
            // If not it doesn't find the operator or if the operator at global scope is defined after
            // this template, the template won't be instantiated due to SFINAE. Once the template is not
            // instantiated it can look for global operator using normal conversions.
#ifdef __NVCC__
#define SFINAE_OP(ret,op) ret
#else
#define SFINAE_OP(ret,op) decltype((void)(doctest::detail::declval&lt;L&gt;() op doctest::detail::declval&lt;R&gt;()),ret{})
#endif

#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(op, op_str, op_macro)                              \
    template &lt;typename R&gt;                                                                          \
    DOCTEST_NOINLINE SFINAE_OP(Result,op) operator op(R&amp;&amp; rhs) {                                   \
    bool res = op_macro(doctest::detail::forward&lt;const L&gt;(lhs), doctest::detail::forward&lt;R&gt;(rhs)); \
        if(m_at &amp; assertType::is_false)                                                            \
            res = !res;                                                                            \
        if(!res || doctest::getContextOptions()-&gt;success)                                          \
            return Result(res, stringifyBinaryExpr(lhs, op_str, rhs));                             \
        return Result(res);                                                                        \
    }

    // more checks could be added - like in Catch:
    // https://github.com/catchorg/Catch2/pull/1480/files
    // https://github.com/catchorg/Catch2/pull/1481/files
#define DOCTEST_FORBIT_EXPRESSION(rt, op)                                                          \
    template &lt;typename R&gt;                                                                          \
    rt&amp; operator op(const R&amp;) {                                                                    \
        static_assert(deferred_false&lt;R&gt;::value,                                                    \
                      "Expression Too Complex Please Rewrite As Binary Comparison!");              \
        return *this;                                                                              \
    }

            struct DOCTEST_INTERFACE Result // NOLINT(*-member-init)
        {
            bool   m_passed;
            String m_decomp;

            Result() = default; // TODO: Why do we need this? (To remove NOLINT)
            Result(bool passed, const String&amp; decomposition = String());

            // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
            DOCTEST_FORBIT_EXPRESSION(Result, &amp;)
                DOCTEST_FORBIT_EXPRESSION(Result, ^)
                DOCTEST_FORBIT_EXPRESSION(Result, | )
                DOCTEST_FORBIT_EXPRESSION(Result, &amp;&amp;)
                DOCTEST_FORBIT_EXPRESSION(Result, || )
                DOCTEST_FORBIT_EXPRESSION(Result, == )
                DOCTEST_FORBIT_EXPRESSION(Result, != )
                DOCTEST_FORBIT_EXPRESSION(Result, &lt; )
                DOCTEST_FORBIT_EXPRESSION(Result, &gt; )
                DOCTEST_FORBIT_EXPRESSION(Result, &lt;= )
                DOCTEST_FORBIT_EXPRESSION(Result, &gt;= )
                DOCTEST_FORBIT_EXPRESSION(Result, =)
                DOCTEST_FORBIT_EXPRESSION(Result, +=)
                DOCTEST_FORBIT_EXPRESSION(Result, -=)
                DOCTEST_FORBIT_EXPRESSION(Result, *=)
                DOCTEST_FORBIT_EXPRESSION(Result, /=)
                DOCTEST_FORBIT_EXPRESSION(Result, %=)
                DOCTEST_FORBIT_EXPRESSION(Result, &lt;&lt;=)
                DOCTEST_FORBIT_EXPRESSION(Result, &gt;&gt;=)
                DOCTEST_FORBIT_EXPRESSION(Result, &amp;=)
                DOCTEST_FORBIT_EXPRESSION(Result, ^=)
                DOCTEST_FORBIT_EXPRESSION(Result, |=)
        };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

        DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
            DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
            DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-compare")
            //DOCTEST_CLANG_SUPPRESS_WARNING("-Wdouble-promotion")
            //DOCTEST_CLANG_SUPPRESS_WARNING("-Wconversion")
            //DOCTEST_CLANG_SUPPRESS_WARNING("-Wfloat-equal")

            DOCTEST_GCC_SUPPRESS_WARNING_PUSH
            DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
            DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-compare")
            //DOCTEST_GCC_SUPPRESS_WARNING("-Wdouble-promotion")
            //DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
            //DOCTEST_GCC_SUPPRESS_WARNING("-Wfloat-equal")

            DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
            // https://stackoverflow.com/questions/39479163 what's the difference between 4018 and 4389
            DOCTEST_MSVC_SUPPRESS_WARNING(4388) // signed/unsigned mismatch
            DOCTEST_MSVC_SUPPRESS_WARNING(4389) // 'operator' : signed/unsigned mismatch
            DOCTEST_MSVC_SUPPRESS_WARNING(4018) // 'expression' : signed/unsigned mismatch
            //DOCTEST_MSVC_SUPPRESS_WARNING(4805) // 'operation' : unsafe mix of type 'type' and type 'type' in operation

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

    // clang-format off
#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE bool
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_COMPARISON_RETURN_TYPE typename types::enable_if&lt;can_use_op&lt;L&gt;::value || can_use_op&lt;R&gt;::value, bool&gt;::type
            inline bool eq(const char* lhs, const char* rhs) { return String(lhs) == String(rhs); }
        inline bool ne(const char* lhs, const char* rhs) { return String(lhs) != String(rhs); }
        inline bool lt(const char* lhs, const char* rhs) { return String(lhs) &lt; String(rhs); }
        inline bool gt(const char* lhs, const char* rhs) { return String(lhs) &gt; String(rhs); }
        inline bool le(const char* lhs, const char* rhs) { return String(lhs) &lt;= String(rhs); }
        inline bool ge(const char* lhs, const char* rhs) { return String(lhs) &gt;= String(rhs); }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
        // clang-format on

#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template &lt;typename L, typename R&gt;                                                              \
    DOCTEST_COMPARISON_RETURN_TYPE name(const DOCTEST_REF_WRAP(L) lhs,                             \
                                        const DOCTEST_REF_WRAP(R) rhs) {                           \
        return lhs op rhs;                                                                         \
    }

<span style = "background-color:#dfd">        DOCTEST_RELATIONAL_OP(eq, == )</span>
            DOCTEST_RELATIONAL_OP(ne, != )
            DOCTEST_RELATIONAL_OP(lt, &lt; )
            DOCTEST_RELATIONAL_OP(gt, &gt; )
            DOCTEST_RELATIONAL_OP(le, &lt;= )
            DOCTEST_RELATIONAL_OP(ge, &gt;= )

#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) l == r
#define DOCTEST_CMP_NE(l, r) l != r
#define DOCTEST_CMP_GT(l, r) l &gt; r
#define DOCTEST_CMP_LT(l, r) l &lt; r
#define DOCTEST_CMP_GE(l, r) l &gt;= r
#define DOCTEST_CMP_LE(l, r) l &lt;= r
#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
#define DOCTEST_CMP_EQ(l, r) eq(l, r)
#define DOCTEST_CMP_NE(l, r) ne(l, r)
#define DOCTEST_CMP_GT(l, r) gt(l, r)
#define DOCTEST_CMP_LT(l, r) lt(l, r)
#define DOCTEST_CMP_GE(l, r) ge(l, r)
#define DOCTEST_CMP_LE(l, r) le(l, r)
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

            template &lt;typename L&gt;
        // cppcheck-suppress copyCtorAndEqOperator
        struct Expression_lhs
        {
            L                lhs;
            assertType::Enum m_at;

            explicit Expression_lhs(L&amp;&amp; in, assertType::Enum at)
<span style = "background-color:#dfd">                : lhs(static_cast&lt;L&amp;&amp;&gt;(in))
                , m_at(at) {}</span>

            DOCTEST_NOINLINE operator Result() {
                // this is needed only for MSVC 2015
                DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4800) // 'int': forcing value to bool
                    bool res = static_cast&lt;bool&gt;(lhs);
                DOCTEST_MSVC_SUPPRESS_WARNING_POP
                    if (m_at &amp; assertType::is_false) { //!OCLINT bitwise operator in conditional
                        res = !res;
                    }

                if (!res || getContextOptions()-&gt;success) {
                    return { res, (DOCTEST_STRINGIFY(lhs)) };
                }
                return { res };
            }

            /* This is required for user-defined conversions from Expression_lhs to L */
            operator L() const { return lhs; }

            // clang-format off
<span style = "background-color:#dfd">            DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(== , " == ", DOCTEST_CMP_EQ) //!OCLINT bitwise operator in conditional
                DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(!= , " != ", DOCTEST_CMP_NE) //!OCLINT bitwise operator in conditional</span>
                DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(&gt; , " &gt;  ", DOCTEST_CMP_GT) //!OCLINT bitwise operator in conditional
                DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(&lt; , " &lt;  ", DOCTEST_CMP_LT) //!OCLINT bitwise operator in conditional
                DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(&gt;= , " &gt;= ", DOCTEST_CMP_GE) //!OCLINT bitwise operator in conditional
                DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(&lt;= , " &lt;= ", DOCTEST_CMP_LE) //!OCLINT bitwise operator in conditional
                // clang-format on

                // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &amp;)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, | )
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &amp;&amp;)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, || )
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, =)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, +=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, -=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, *=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, /=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, %=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &lt;&lt;=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &gt;&gt;=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &amp;=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^=)
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |=)
                // these 2 are unfortunate because they should be allowed - they have higher precedence over the comparisons, but the
                // ExpressionDecomposer class uses the left shift operator to capture the left operand of the binary expression...
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &lt;&lt; )
                DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &gt;&gt; )
        };

#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

        DOCTEST_CLANG_SUPPRESS_WARNING_POP
            DOCTEST_MSVC_SUPPRESS_WARNING_POP
            DOCTEST_GCC_SUPPRESS_WARNING_POP

#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION

#if DOCTEST_CLANG &amp;&amp; DOCTEST_CLANG &lt; DOCTEST_COMPILER(3, 6, 0)
            DOCTEST_CLANG_SUPPRESS_WARNING_POP
#endif

            struct DOCTEST_INTERFACE ExpressionDecomposer
        {
            assertType::Enum m_at;

            ExpressionDecomposer(assertType::Enum at);

            // The right operator for capturing expressions is "&lt;=" instead of "&lt;&lt;" (based on the operator precedence table)
            // but then there will be warnings from GCC about "-Wparentheses" and since "_Pragma()" is problematic this will stay for now...
            // https://github.com/catchorg/Catch2/issues/870
            // https://github.com/catchorg/Catch2/issues/565
            template &lt;typename L&gt;
<span style = "background-color:#dfd">            Expression_lhs&lt;L&gt; operator&lt;&lt;(L&amp;&amp; operand) {
                return Expression_lhs&lt;L&gt;(static_cast&lt;L&amp;&amp;&gt;(operand), m_at);
            }</span>

            template &lt;typename L, typename types::enable_if&lt;!doctest::detail::types::is_rvalue_reference&lt;L&gt;::value, void &gt;::type* = nullptr&gt;
            Expression_lhs&lt;const L&amp;&gt; operator&lt;&lt;(const L&amp; operand) {
                return Expression_lhs&lt;const L&amp;&gt;(operand, m_at);
            }
        };

        struct DOCTEST_INTERFACE TestSuite
        {
            const char* m_test_suite = nullptr;
            const char* m_description = nullptr;
            bool        m_skip = false;
            bool        m_no_breaks = false;
            bool        m_no_output = false;
            bool        m_may_fail = false;
            bool        m_should_fail = false;
            int         m_expected_failures = 0;
            double      m_timeout = 0;

            TestSuite&amp; operator*(const char* in);

            template &lt;typename T&gt;
            TestSuite&amp; operator*(const T&amp; in) {
                in.fill(*this);
                return *this;
            }
        };

        using funcType = void (*)();

        struct DOCTEST_INTERFACE TestCase : public TestCaseData
        {
            funcType m_test; // a function pointer to the test case

            String m_type; // for templated test cases - gets appended to the real name
            int m_template_id; // an ID used to distinguish between the different versions of a templated test case
            String m_full_name; // contains the name (only for templated test cases!) + the template type

            TestCase(funcType test, const char* file, unsigned line, const TestSuite&amp; test_suite,
                const String&amp; type = String(), int template_id = -1);

            TestCase(const TestCase&amp; other);
            TestCase(TestCase&amp;&amp;) = delete;

            DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
                TestCase&amp; operator=(const TestCase&amp; other);
            DOCTEST_MSVC_SUPPRESS_WARNING_POP

                TestCase&amp; operator=(TestCase&amp;&amp;) = delete;

            TestCase&amp; operator*(const char* in);

            template &lt;typename T&gt;
            TestCase&amp; operator*(const T&amp; in) {
                in.fill(*this);
                return *this;
            }

            bool operator&lt;(const TestCase&amp; other) const;

            ~TestCase() = default;
        };

        // forward declarations of functions used by the macros
        DOCTEST_INTERFACE int  regTest(const TestCase&amp; tc);
        DOCTEST_INTERFACE int  setTestSuite(const TestSuite&amp; ts);
        DOCTEST_INTERFACE bool isDebuggerActive();

        template&lt;typename T&gt;
        int instantiationHelper(const T&amp;) { return 0; }

        namespace binaryAssertComparison {
            enum Enum
            {
                eq = 0,
                ne,
                gt,
                lt,
                ge,
                le
            };
        } // namespace binaryAssertComparison

        // clang-format off
        template &lt;int, class L, class R&gt; struct RelationalComparator { bool operator()(const DOCTEST_REF_WRAP(L), const DOCTEST_REF_WRAP(R)) const { return false; } };

#define DOCTEST_BINARY_RELATIONAL_OP(n, op) \
    template &lt;class L, class R&gt; struct RelationalComparator&lt;n, L, R&gt; { bool operator()(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) const { return op(lhs, rhs); } };
        // clang-format on

<span style = "background-color:#dfd">        DOCTEST_BINARY_RELATIONAL_OP(0, doctest::detail::eq)</span>
            DOCTEST_BINARY_RELATIONAL_OP(1, doctest::detail::ne)
            DOCTEST_BINARY_RELATIONAL_OP(2, doctest::detail::gt)
            DOCTEST_BINARY_RELATIONAL_OP(3, doctest::detail::lt)
            DOCTEST_BINARY_RELATIONAL_OP(4, doctest::detail::ge)
            DOCTEST_BINARY_RELATIONAL_OP(5, doctest::detail::le)

            struct DOCTEST_INTERFACE ResultBuilder : public AssertData
        {
            ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                const char* exception_type = "", const String&amp; exception_string = "");

            ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
                const char* exception_type, const Contains&amp; exception_string);

            void setResult(const Result&amp; res);

            template &lt;int comparison, typename L, typename R&gt;
            DOCTEST_NOINLINE bool binary_assert(const DOCTEST_REF_WRAP(L) lhs,
<span style = "background-color:#dfd">                const DOCTEST_REF_WRAP(R) rhs) {
                m_failed = !RelationalComparator&lt;comparison, L, R&gt;()(lhs, rhs);
                if (m_failed || getContextOptions()-&gt;success) {</span>
<span style = "background-color:#fdd">                    m_decomp = stringifyBinaryExpr(lhs, ", ", rhs);</span>
                }
<span style = "background-color:#dfd">                return !m_failed;
            }</span>

            template &lt;typename L&gt;
            DOCTEST_NOINLINE bool unary_assert(const DOCTEST_REF_WRAP(L) val) {
                m_failed = !val;

                if (m_at &amp; assertType::is_false) { //!OCLINT bitwise operator in conditional
                    m_failed = !m_failed;
                }

                if (m_failed || getContextOptions()-&gt;success) {
                    m_decomp = (DOCTEST_STRINGIFY(val));
                }

                return !m_failed;
            }

            void translateException();

            bool log();
            void react() const;
        };

        namespace assertAction {
            enum Enum
            {
                nothing = 0,
                dbgbreak = 1,
                shouldthrow = 2
            };
        } // namespace assertAction

        DOCTEST_INTERFACE void failed_out_of_a_testing_context(const AssertData&amp; ad);

        DOCTEST_INTERFACE bool decomp_assert(assertType::Enum at, const char* file, int line,
            const char* expr, const Result&amp; result);

#define DOCTEST_ASSERT_OUT_OF_TESTS(decomp)                                                        \
    do {                                                                                           \
        if(!is_running_in_test) {                                                                  \
            if(failed) {                                                                           \
                ResultBuilder rb(at, file, line, expr);                                            \
                rb.m_failed = failed;                                                              \
                rb.m_decomp = decomp;                                                              \
                failed_out_of_a_testing_context(rb);                                               \
                if(isDebuggerActive() &amp;&amp; !getContextOptions()-&gt;no_breaks)                          \
                    DOCTEST_BREAK_INTO_DEBUGGER();                                                 \
                if(checkIfShouldThrow(at))                                                         \
                    throwException();                                                              \
            }                                                                                      \
            return !failed;                                                                        \
        }                                                                                          \
    } while(false)

#define DOCTEST_ASSERT_IN_TESTS(decomp)                                                            \
    ResultBuilder rb(at, file, line, expr);                                                        \
    rb.m_failed = failed;                                                                          \
    if(rb.m_failed || getContextOptions()-&gt;success)                                                \
        rb.m_decomp = decomp;                                                                      \
    if(rb.log())                                                                                   \
        DOCTEST_BREAK_INTO_DEBUGGER();                                                             \
    if(rb.m_failed &amp;&amp; checkIfShouldThrow(at))                                                      \
    throwException()

        template &lt;int comparison, typename L, typename R&gt;
        DOCTEST_NOINLINE bool binary_assert(assertType::Enum at, const char* file, int line,
            const char* expr, const DOCTEST_REF_WRAP(L) lhs,
            const DOCTEST_REF_WRAP(R) rhs) {
            bool failed = !RelationalComparator&lt;comparison, L, R&gt;()(lhs, rhs);

            // ###################################################################################
            // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
            // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
            // ###################################################################################
            DOCTEST_ASSERT_OUT_OF_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
            DOCTEST_ASSERT_IN_TESTS(stringifyBinaryExpr(lhs, ", ", rhs));
            return !failed;
        }

        template &lt;typename L&gt;
        DOCTEST_NOINLINE bool unary_assert(assertType::Enum at, const char* file, int line,
            const char* expr, const DOCTEST_REF_WRAP(L) val) {
            bool failed = !val;

            if (at &amp; assertType::is_false) //!OCLINT bitwise operator in conditional
                failed = !failed;

            // ###################################################################################
            // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
            // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
            // ###################################################################################
            DOCTEST_ASSERT_OUT_OF_TESTS((DOCTEST_STRINGIFY(val)));
            DOCTEST_ASSERT_IN_TESTS((DOCTEST_STRINGIFY(val)));
            return !failed;
        }

        struct DOCTEST_INTERFACE IExceptionTranslator
        {
            DOCTEST_DECLARE_INTERFACE(IExceptionTranslator)
                virtual bool translate(String&amp;) const = 0;
        };

        template &lt;typename T&gt;
        class ExceptionTranslator : public IExceptionTranslator //!OCLINT destructor of virtual class
        {
        public:
            explicit ExceptionTranslator(String(*translateFunction)(T))
                : m_translateFunction(translateFunction) {}

            bool translate(String&amp; res) const override {
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                try {
                    throw; // lgtm [cpp/rethrow-no-exception]
                    // cppcheck-suppress catchExceptionByValue
                }
                catch (const T&amp; ex) {
                    res = m_translateFunction(ex); //!OCLINT parameter reassignment
                    return true;
                }
                catch (...) {}         //!OCLINT -  empty catch statement
#endif                              // DOCTEST_CONFIG_NO_EXCEPTIONS
                static_cast&lt;void&gt;(res); // to silence -Wunused-parameter
                return false;
            }

        private:
            String(*m_translateFunction)(T);
        };

        DOCTEST_INTERFACE void registerExceptionTranslatorImpl(const IExceptionTranslator* et);

        // ContextScope base class used to allow implementing methods of ContextScope
        // that don't depend on the template parameter in doctest.cpp.
        struct DOCTEST_INTERFACE ContextScopeBase : public IContextScope {
            ContextScopeBase(const ContextScopeBase&amp;) = delete;

            ContextScopeBase&amp; operator=(const ContextScopeBase&amp;) = delete;
            ContextScopeBase&amp; operator=(ContextScopeBase&amp;&amp;) = delete;

<span style = "background-color:#fdd">            ~ContextScopeBase() override = default;</span>

        protected:
            ContextScopeBase();
            ContextScopeBase(ContextScopeBase&amp;&amp; other) noexcept;

            void destroy();
<span style = "background-color:#fdd">            bool need_to_destroy{ true };</span>
        };

        template &lt;typename L&gt; class ContextScope : public ContextScopeBase
        {
            L lambda_;

        public:
            explicit ContextScope(const L&amp; lambda) : lambda_(lambda) {}
            explicit ContextScope(L&amp;&amp; lambda) : lambda_(static_cast&lt;L&amp;&amp;&gt;(lambda)) { }

            ContextScope(const ContextScope&amp;) = delete;
            ContextScope(ContextScope&amp;&amp;) noexcept = default;

            ContextScope&amp; operator=(const ContextScope&amp;) = delete;
            ContextScope&amp; operator=(ContextScope&amp;&amp;) = delete;

            void stringify(std::ostream* s) const override { lambda_(s); }

            ~ContextScope() override {
                if (need_to_destroy) {
                    destroy();
                }
            }
        };

        struct DOCTEST_INTERFACE MessageBuilder : public MessageData
        {
            std::ostream* m_stream;
<span style = "background-color:#fdd">            bool          logged = false;</span>

            MessageBuilder(const char* file, int line, assertType::Enum severity);

            MessageBuilder(const MessageBuilder&amp;) = delete;
            MessageBuilder(MessageBuilder&amp;&amp;) = delete;

            MessageBuilder&amp; operator=(const MessageBuilder&amp;) = delete;
            MessageBuilder&amp; operator=(MessageBuilder&amp;&amp;) = delete;

            ~MessageBuilder();

            // the preferred way of chaining parameters for stringification
            DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4866)
                template &lt;typename T&gt;
            MessageBuilder&amp; operator,(const T&amp; in) {
                *m_stream &lt;&lt; (DOCTEST_STRINGIFY(in));
                return *this;
            }
            DOCTEST_MSVC_SUPPRESS_WARNING_POP

                // kept here just for backwards-compatibility - the comma operator should be preferred now
                template &lt;typename T&gt;
            MessageBuilder&amp; operator&lt;&lt;(const T&amp; in) { return this-&gt;operator,(in); }

            // the `,` operator has the lowest operator precedence - if `&lt;&lt;` is used by the user then
            // the `,` operator will be called last which is not what we want and thus the `*` operator
            // is used first (has higher operator precedence compared to `&lt;&lt;`) so that we guarantee that
            // an operator of the MessageBuilder class is called first before the rest of the parameters
            template &lt;typename T&gt;
            MessageBuilder&amp; operator*(const T&amp; in) { return this-&gt;operator,(in); }

            bool log();
            void react();
        };

        template &lt;typename L&gt;
        ContextScope&lt;L&gt; MakeContextScope(const L&amp; lambda) {
            return ContextScope&lt;L&gt;(lambda);
        }
    } // namespace detail

#define DOCTEST_DEFINE_DECORATOR(name, type, def)                                                  \
    struct name                                                                                    \
    {                                                                                              \
        type data;                                                                                 \
        name(type in = def)                                                                        \
                : data(in) {}                                                                      \
        void fill(detail::TestCase&amp; state) const { state.DOCTEST_CAT(m_, name) = data; }           \
        void fill(detail::TestSuite&amp; state) const { state.DOCTEST_CAT(m_, name) = data; }          \
    }

    DOCTEST_DEFINE_DECORATOR(test_suite, const char*, "");
    DOCTEST_DEFINE_DECORATOR(description, const char*, "");
    DOCTEST_DEFINE_DECORATOR(skip, bool, true);
    DOCTEST_DEFINE_DECORATOR(no_breaks, bool, true);
    DOCTEST_DEFINE_DECORATOR(no_output, bool, true);
    DOCTEST_DEFINE_DECORATOR(timeout, double, 0);
    DOCTEST_DEFINE_DECORATOR(may_fail, bool, true);
    DOCTEST_DEFINE_DECORATOR(should_fail, bool, true);
    DOCTEST_DEFINE_DECORATOR(expected_failures, int, 0);

    template &lt;typename T&gt;
    int registerExceptionTranslator(String(*translateFunction)(T)) {
        DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")
            static detail::ExceptionTranslator&lt;T&gt; exceptionTranslator(translateFunction);
        DOCTEST_CLANG_SUPPRESS_WARNING_POP
            detail::registerExceptionTranslatorImpl(&amp;exceptionTranslator);
        return 0;
    }

} // namespace doctest

// in a separate namespace outside of doctest because the DOCTEST_TEST_SUITE macro
// introduces an anonymous namespace in which getCurrentTestSuite gets overridden
namespace doctest_detail_test_suite_ns {
    DOCTEST_INTERFACE doctest::detail::TestSuite&amp; getCurrentTestSuite();
} // namespace doctest_detail_test_suite_ns

namespace doctest {
#else  // DOCTEST_CONFIG_DISABLE
    template &lt;typename T&gt;
    int registerExceptionTranslator(String(*)(T)) {
        return 0;
    }
#endif // DOCTEST_CONFIG_DISABLE

    namespace detail {
        using assert_handler = void (*)(const AssertData&amp;);
        struct ContextState;
    } // namespace detail

    class DOCTEST_INTERFACE Context
    {
        detail::ContextState* p;

        void parseArgs(int argc, const char* const* argv, bool withDefaults = false);

    public:
        explicit Context(int argc = 0, const char* const* argv = nullptr);

        Context(const Context&amp;) = delete;
        Context(Context&amp;&amp;) = delete;

        Context&amp; operator=(const Context&amp;) = delete;
        Context&amp; operator=(Context&amp;&amp;) = delete;

        ~Context(); // NOLINT(performance-trivially-destructible)

        void applyCommandLine(int argc, const char* const* argv);

        void addFilter(const char* filter, const char* value);
        void clearFilters();
        void setOption(const char* option, bool value);
        void setOption(const char* option, int value);
        void setOption(const char* option, const char* value);

        bool shouldExit();

        void setAsDefaultForAssertsOutOfTestCases();

        void setAssertHandler(detail::assert_handler ah);

        void setCout(std::ostream* out);

        int run();
    };

    namespace TestCaseFailureReason {
        enum Enum
        {
            None = 0,
            AssertFailure = 1,   // an assertion has failed in the test case
            Exception = 2,   // test case threw an exception
            Crash = 4,   // a crash...
            TooManyFailedAsserts = 8,   // the abort-after option
            Timeout = 16,  // see the timeout decorator
            ShouldHaveFailedButDidnt = 32,  // see the should_fail decorator
            ShouldHaveFailedAndDid = 64,  // see the should_fail decorator
            DidntFailExactlyNumTimes = 128, // see the expected_failures decorator
            FailedExactlyNumTimes = 256, // see the expected_failures decorator
            CouldHaveFailedAndDid = 512  // see the may_fail decorator
        };
    } // namespace TestCaseFailureReason

    struct DOCTEST_INTERFACE CurrentTestCaseStats
    {
        int    numAssertsCurrentTest;
        int    numAssertsFailedCurrentTest;
        double seconds;
        int    failure_flags; // use TestCaseFailureReason::Enum
        bool   testCaseSuccess;
    };

    struct DOCTEST_INTERFACE TestCaseException
    {
        String error_string;
        bool   is_crash;
    };

    struct DOCTEST_INTERFACE TestRunStats
    {
        unsigned numTestCases;
        unsigned numTestCasesPassingFilters;
        unsigned numTestSuitesPassingFilters;
        unsigned numTestCasesFailed;
        int      numAsserts;
        int      numAssertsFailed;
    };

    struct QueryData
    {
        const TestRunStats* run_stats = nullptr;
        const TestCaseData** data = nullptr;
        unsigned             num_data = 0;
    };

    struct DOCTEST_INTERFACE IReporter
    {
        // The constructor has to accept "const ContextOptions&amp;" as a single argument
        // which has most of the options for the run + a pointer to the stdout stream
        // Reporter(const ContextOptions&amp; in)

        // called when a query should be reported (listing test cases, printing the version, etc.)
        virtual void report_query(const QueryData&amp;) = 0;

        // called when the whole test run starts
        virtual void test_run_start() = 0;
        // called when the whole test run ends (caching a pointer to the input doesn't make sense here)
        virtual void test_run_end(const TestRunStats&amp;) = 0;

        // called when a test case is started (safe to cache a pointer to the input)
        virtual void test_case_start(const TestCaseData&amp;) = 0;
        // called when a test case is reentered because of unfinished subcases (safe to cache a pointer to the input)
        virtual void test_case_reenter(const TestCaseData&amp;) = 0;
        // called when a test case has ended
        virtual void test_case_end(const CurrentTestCaseStats&amp;) = 0;

        // called when an exception is thrown from the test case (or it crashes)
        virtual void test_case_exception(const TestCaseException&amp;) = 0;

        // called whenever a subcase is entered (don't cache pointers to the input)
        virtual void subcase_start(const SubcaseSignature&amp;) = 0;
        // called whenever a subcase is exited (don't cache pointers to the input)
        virtual void subcase_end() = 0;

        // called for each assert (don't cache pointers to the input)
        virtual void log_assert(const AssertData&amp;) = 0;
        // called for each message (don't cache pointers to the input)
        virtual void log_message(const MessageData&amp;) = 0;

        // called when a test case is skipped either because it doesn't pass the filters, has a skip decorator
        // or isn't in the execution range (between first and last) (safe to cache a pointer to the input)
        virtual void test_case_skipped(const TestCaseData&amp;) = 0;

<span style = "background-color:#dfd">        DOCTEST_DECLARE_INTERFACE(IReporter)</span>

            // can obtain all currently active contexts and stringify them if one wishes to do so
            static int                         get_num_active_contexts();
        static const IContextScope* const* get_active_contexts();

        // can iterate through contexts which have been stringified automatically in their destructors when an exception has been thrown
        static int           get_num_stringified_contexts();
        static const String* get_stringified_contexts();
    };

    namespace detail {
        using reporterCreatorFunc = IReporter * (*)(const ContextOptions&amp;);

        DOCTEST_INTERFACE void registerReporterImpl(const char* name, int prio, reporterCreatorFunc c, bool isReporter);

        template &lt;typename Reporter&gt;
<span style = "background-color:#dfd">        IReporter* reporterCreator(const ContextOptions&amp; o) {
            return new Reporter(o);
        }</span>
    } // namespace detail

    template &lt;typename Reporter&gt;
<span style = "background-color:#dfd">    int registerReporter(const char* name, int priority, bool isReporter) {
        detail::registerReporterImpl(name, priority, detail::reporterCreator&lt;Reporter&gt;, isReporter);
        return 0;
    }</span>
} // namespace doctest

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_EMPTY [] { return false; }()
#else
#define DOCTEST_FUNC_EMPTY (void)0
#endif

// if registering is not disabled
#ifndef DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_ASSERTS_RETURN_VALUES
#define DOCTEST_FUNC_SCOPE_BEGIN [&amp;]
#define DOCTEST_FUNC_SCOPE_END ()
#define DOCTEST_FUNC_SCOPE_RET(v) return v
#else
#define DOCTEST_FUNC_SCOPE_BEGIN do
#define DOCTEST_FUNC_SCOPE_END while(false)
#define DOCTEST_FUNC_SCOPE_RET(v) (void)0
#endif

// common code in asserts - for convenience
#define DOCTEST_ASSERT_LOG_REACT_RETURN(b)                                                         \
    if(b.log()) DOCTEST_BREAK_INTO_DEBUGGER();                                                     \
    b.react();                                                                                     \
    DOCTEST_FUNC_SCOPE_RET(!b.m_failed)

#ifdef DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x) x;
#else // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS
#define DOCTEST_WRAP_IN_TRY(x)                                                                     \
    try {                                                                                          \
        x;                                                                                         \
    } catch(...) { DOCTEST_RB.translateException(); }
#endif // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS

#ifdef DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...)                                                                  \
    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wuseless-cast")                                       \
    static_cast&lt;void&gt;(__VA_ARGS__);                                                                \
    DOCTEST_GCC_SUPPRESS_WARNING_POP
#else // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS
#define DOCTEST_CAST_TO_VOID(...) __VA_ARGS__;
#endif // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS

// registers the test by initializing a dummy var with a function
#define DOCTEST_REGISTER_FUNCTION(global_prefix, f, decorators)                                    \
    global_prefix DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT */    \
            doctest::detail::regTest(                                                              \
                    doctest::detail::TestCase(                                                     \
                            f, __FILE__, __LINE__,                                                 \
                            doctest_detail_test_suite_ns::getCurrentTestSuite()) *                 \
                    decorators))

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, decorators)                                     \
    namespace { /* NOLINT */                                                                       \
        struct der : public base                                                                   \
        {                                                                                          \
            void f();                                                                              \
        };                                                                                         \
        static DOCTEST_INLINE_NOINLINE void func() {                                               \
            der v;                                                                                 \
            v.f();                                                                                 \
        }                                                                                          \
        DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, func, decorators)                                 \
    }                                                                                              \
    DOCTEST_INLINE_NOINLINE void der::f() // NOLINT(misc-definitions-in-headers)

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, decorators)                                        \
    static void f();                                                                               \
    DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, f, decorators)                                        \
    static void f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(f, proxy, decorators)                        \
    static doctest::detail::funcType proxy() { return f; }                                         \
    DOCTEST_REGISTER_FUNCTION(inline, proxy(), decorators)                                         \
    static void f()

// for registering tests
#define DOCTEST_TEST_CASE(decorators)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for registering tests in classes - requires C++17 for inline variables!
#if DOCTEST_CPLUSPLUS &gt;= 201703L
#define DOCTEST_TEST_CASE_CLASS(decorators)                                                        \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_),           \
                                                  DOCTEST_ANONYMOUS(DOCTEST_ANON_PROXY_),          \
                                                  decorators)
#else // DOCTEST_TEST_CASE_CLASS
#define DOCTEST_TEST_CASE_CLASS(...)                                                               \
    TEST_CASES_CAN_BE_REGISTERED_IN_CLASSES_ONLY_IN_CPP17_MODE_OR_WITH_VS_2017_OR_NEWER
#endif // DOCTEST_TEST_CASE_CLASS

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(c, decorators)                                                   \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), c,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), decorators)

// for converting types to strings without the &lt;typeinfo&gt; header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...)                                                        \
    namespace doctest {                                                                            \
        template &lt;&gt;                                                                                \
        inline String toString&lt;__VA_ARGS__&gt;() {                                                    \
            return str;                                                                            \
        }                                                                                          \
    }                                                                                              \
    static_assert(true, "")

#define DOCTEST_TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING_AS(#__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, iter, func)                                 \
    template &lt;typename T&gt;                                                                          \
    static void func();                                                                            \
    namespace { /* NOLINT */                                                                       \
        template &lt;typename Tuple&gt;                                                                  \
        struct iter;                                                                               \
        template &lt;typename Type, typename... Rest&gt;                                                 \
        struct iter&lt;std::tuple&lt;Type, Rest...&gt;&gt;                                                     \
        {                                                                                          \
            iter(const char* file, unsigned line, int index) {                                     \
                doctest::detail::regTest(doctest::detail::TestCase(func&lt;Type&gt;, file, line,         \
                                            doctest_detail_test_suite_ns::getCurrentTestSuite(),   \
                                            doctest::toString&lt;Type&gt;(),                             \
                                            int(line) * 1000 + index)                              \
                                         * dec);                                                   \
                iter&lt;std::tuple&lt;Rest...&gt;&gt;(file, line, index + 1);                                  \
            }                                                                                      \
        };                                                                                         \
        template &lt;&gt;                                                                                \
        struct iter&lt;std::tuple&lt;&gt;&gt;                                                                  \
        {                                                                                          \
            iter(const char*, unsigned, int) {}                                                    \
        };                                                                                         \
    }                                                                                              \
    template &lt;typename T&gt;                                                                          \
    static void func()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(dec, T, id)                                              \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(id, ITERATOR),                      \
                                           DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_))

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, anon, ...)                                 \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY), /* NOLINT(cert-err58-cpp, fuchsia-statically-constructed-objects) */ \
        doctest::detail::instantiationHelper(                                                      \
            DOCTEST_CAT(id, ITERATOR)&lt;__VA_ARGS__&gt;(__FILE__, __LINE__, 0)))

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...)                                                 \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), std::tuple&lt;__VA_ARGS__&gt;) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...)                                                  \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__) \
    static_assert(true, "")

#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, anon, ...)                                         \
    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(anon, ITERATOR), anon);             \
    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(anon, anon, std::tuple&lt;__VA_ARGS__&gt;)               \
    template &lt;typename T&gt;                                                                          \
    static void anon()

#define DOCTEST_TEST_CASE_TEMPLATE(dec, T, ...)                                                    \
    DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_), __VA_ARGS__)

// for subcases
#define DOCTEST_SUBCASE(name)                                                                      \
    if(const doctest::detail::Subcase &amp; DOCTEST_ANONYMOUS(DOCTEST_ANON_SUBCASE_) DOCTEST_UNUSED =  \
               doctest::detail::Subcase(name, __FILE__, __LINE__))

// for grouping tests in test suites by using code blocks
#define DOCTEST_TEST_SUITE_IMPL(decorators, ns_name)                                               \
    namespace ns_name { namespace doctest_detail_test_suite_ns {                                   \
            static DOCTEST_NOINLINE doctest::detail::TestSuite&amp; getCurrentTestSuite() noexcept {   \
                DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4640)                                      \
                DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wexit-time-destructors")                \
                DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmissing-field-initializers")             \
                static doctest::detail::TestSuite data{};                                          \
                static bool                       inited = false;                                  \
                DOCTEST_MSVC_SUPPRESS_WARNING_POP                                                  \
                DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                 \
                DOCTEST_GCC_SUPPRESS_WARNING_POP                                                   \
                if(!inited) {                                                                      \
                    data* decorators;                                                              \
                    inited = true;                                                                 \
                }                                                                                  \
                return data;                                                                       \
            }                                                                                      \
        }                                                                                          \
    }                                                                                              \
    namespace ns_name

#define DOCTEST_TEST_SUITE(decorators)                                                             \
    DOCTEST_TEST_SUITE_IMPL(decorators, DOCTEST_ANONYMOUS(DOCTEST_ANON_SUITE_))

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(decorators)                                                       \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * decorators))              \
    static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END                                                                     \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_VAR_), /* NOLINT(cert-err58-cpp) */  \
            doctest::detail::setTestSuite(doctest::detail::TestSuite() * ""))                      \
    using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

// for registering exception translators
#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(translatorName, signature)                      \
    inline doctest::String translatorName(signature);                                              \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerExceptionTranslator(translatorName))                                  \
    doctest::String translatorName(signature)

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_),        \
                                               signature)

// for registering reporters
#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter&lt;reporter&gt;(name, priority, true))                             \
    static_assert(true, "")

// for registering listeners
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)                                        \
    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(DOCTEST_ANON_REPORTER_), /* NOLINT(cert-err58-cpp) */ \
            doctest::registerReporter&lt;reporter&gt;(name, priority, false))                            \
    static_assert(true, "")

// clang-format off
// for logging - disabling formatting because it's important to have these on 2 separate lines - see PR #557
#define DOCTEST_INFO(...)                                                                          \
    DOCTEST_INFO_IMPL(DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_),                                         \
                      DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_OTHER_),                                   \
                      __VA_ARGS__)
// clang-format on

#define DOCTEST_INFO_IMPL(mb_name, s_name, ...)                                       \
    auto DOCTEST_ANONYMOUS(DOCTEST_CAPTURE_) = doctest::detail::MakeContextScope(                  \
        [&amp;](std::ostream* s_name) {                                                                \
        doctest::detail::MessageBuilder mb_name(__FILE__, __LINE__, doctest::assertType::is_warn); \
        mb_name.m_stream = s_name;                                                                 \
        mb_name * __VA_ARGS__;                                                                     \
    })

#define DOCTEST_CAPTURE(x) DOCTEST_INFO(#x " := ", x)

#define DOCTEST_ADD_AT_IMPL(type, file, line, mb, ...)                                             \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::MessageBuilder mb(file, line, doctest::assertType::type);                 \
        mb * __VA_ARGS__;                                                                          \
        if(mb.log())                                                                               \
            DOCTEST_BREAK_INTO_DEBUGGER();                                                         \
        mb.react();                                                                                \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_warn, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_check, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
#define DOCTEST_ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_require, file, line, DOCTEST_ANONYMOUS(DOCTEST_MESSAGE_), __VA_ARGS__)
// clang-format on

#define DOCTEST_MESSAGE(...) DOCTEST_ADD_MESSAGE_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL_CHECK(...) DOCTEST_ADD_FAIL_CHECK_AT(__FILE__, __LINE__, __VA_ARGS__)
#define DOCTEST_FAIL(...) DOCTEST_ADD_FAIL_AT(__FILE__, __LINE__, __VA_ARGS__)

#define DOCTEST_TO_LVALUE(...) __VA_ARGS__ // Not removed to keep backwards compatibility.

#ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_ASSERT_IMPLEMENT_2(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */                                  \
    doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,          \
                                               __LINE__, #__VA_ARGS__);                            \
    DOCTEST_WRAP_IN_TRY(DOCTEST_RB.setResult(                                                      \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
            &lt;&lt; __VA_ARGS__)) /* NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks) */         \
    DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB)                                                    \
    DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        DOCTEST_ASSERT_IMPLEMENT_2(assert_type, __VA_ARGS__);                                      \
    } DOCTEST_FUNC_SCOPE_END // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)

#define DOCTEST_BINARY_ASSERT(assert_type, comp, ...)                                              \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(                                                                       \
                DOCTEST_RB.binary_assert&lt;doctest::detail::binaryAssertComparison::comp&gt;(           \
                        __VA_ARGS__))                                                              \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        DOCTEST_WRAP_IN_TRY(DOCTEST_RB.unary_assert(__VA_ARGS__))                                  \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

#else // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

// necessary for &lt;ASSERT&gt;_MESSAGE
#define DOCTEST_ASSERT_IMPLEMENT_2 DOCTEST_ASSERT_IMPLEMENT_1

#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \
    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses")                  \
    doctest::detail::decomp_assert(                                                                \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__,                    \
            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \
                    &lt;&lt; __VA_ARGS__) DOCTEST_CLANG_SUPPRESS_WARNING_POP

#define DOCTEST_BINARY_ASSERT(assert_type, comparison, ...)                                        \
    doctest::detail::binary_assert&lt;doctest::detail::binaryAssertComparison::comparison&gt;(           \
            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__, __VA_ARGS__)

#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \
    doctest::detail::unary_assert(doctest::assertType::assert_type, __FILE__, __LINE__,            \
                                  #__VA_ARGS__, __VA_ARGS__)

#endif // DOCTEST_CONFIG_SUPER_FAST_ASSERTS

#define DOCTEST_WARN(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN, __VA_ARGS__)
#define DOCTEST_CHECK(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK, __VA_ARGS__)
#define DOCTEST_REQUIRE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE, __VA_ARGS__)
#define DOCTEST_WARN_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE_FALSE, __VA_ARGS__)

// clang-format off
#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE_FALSE, cond); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#define DOCTEST_WARN_EQ(...) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, eq, __VA_ARGS__)
#define DOCTEST_CHECK_EQ(...) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, eq, __VA_ARGS__)
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, eq, __VA_ARGS__)
#define DOCTEST_WARN_NE(...) DOCTEST_BINARY_ASSERT(DT_WARN_NE, ne, __VA_ARGS__)
#define DOCTEST_CHECK_NE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, ne, __VA_ARGS__)
#define DOCTEST_REQUIRE_NE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, ne, __VA_ARGS__)
#define DOCTEST_WARN_GT(...) DOCTEST_BINARY_ASSERT(DT_WARN_GT, gt, __VA_ARGS__)
#define DOCTEST_CHECK_GT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, gt, __VA_ARGS__)
#define DOCTEST_REQUIRE_GT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, gt, __VA_ARGS__)
#define DOCTEST_WARN_LT(...) DOCTEST_BINARY_ASSERT(DT_WARN_LT, lt, __VA_ARGS__)
#define DOCTEST_CHECK_LT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, lt, __VA_ARGS__)
#define DOCTEST_REQUIRE_LT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, lt, __VA_ARGS__)
#define DOCTEST_WARN_GE(...) DOCTEST_BINARY_ASSERT(DT_WARN_GE, ge, __VA_ARGS__)
#define DOCTEST_CHECK_GE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, ge, __VA_ARGS__)
#define DOCTEST_REQUIRE_GE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, ge, __VA_ARGS__)
#define DOCTEST_WARN_LE(...) DOCTEST_BINARY_ASSERT(DT_WARN_LE, le, __VA_ARGS__)
#define DOCTEST_CHECK_LE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, le, __VA_ARGS__)
#define DOCTEST_REQUIRE_LE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, le, __VA_ARGS__)

#define DOCTEST_WARN_UNARY(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, __VA_ARGS__)
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, __VA_ARGS__)
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, __VA_ARGS__)

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_ASSERT_THROWS_AS(expr, assert_type, message, ...)                                  \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()-&gt;no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, #expr, #__VA_ARGS__, message);    \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(const typename doctest::detail::types::remove_const&lt;                           \
                    typename doctest::detail::types::remove_reference&lt;__VA_ARGS__&gt;::type&gt;::type&amp;) {\
                DOCTEST_RB.translateException();                                                   \
                DOCTEST_RB.m_threw_as = true;                                                      \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
            DOCTEST_FUNC_SCOPE_RET(false);                                                         \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_THROWS_WITH(expr, expr_str, assert_type, ...)                               \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        if(!doctest::getContextOptions()-&gt;no_throw) {                                              \
            doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,  \
                                                       __LINE__, expr_str, "", __VA_ARGS__);       \
            try {                                                                                  \
                DOCTEST_CAST_TO_VOID(expr)                                                         \
            } catch(...) { DOCTEST_RB.translateException(); }                                      \
            DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                           \
        } else { /* NOLINT(*-else-after-return) */                                                 \
           DOCTEST_FUNC_SCOPE_RET(false);                                                          \
        }                                                                                          \
    } DOCTEST_FUNC_SCOPE_END

#define DOCTEST_ASSERT_NOTHROW(assert_type, ...)                                                   \
    DOCTEST_FUNC_SCOPE_BEGIN {                                                                     \
        doctest::detail::ResultBuilder DOCTEST_RB(doctest::assertType::assert_type, __FILE__,      \
                                                   __LINE__, #__VA_ARGS__);                        \
        try {                                                                                      \
            DOCTEST_CAST_TO_VOID(__VA_ARGS__)                                                      \
        } catch(...) { DOCTEST_RB.translateException(); }                                          \
        DOCTEST_ASSERT_LOG_REACT_RETURN(DOCTEST_RB);                                               \
    } DOCTEST_FUNC_SCOPE_END

// clang-format off
#define DOCTEST_WARN_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_WARN_THROWS, "")
#define DOCTEST_CHECK_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_CHECK_THROWS, "")
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_REQUIRE_THROWS, "")

#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_AS, "", __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_AS, "", __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_WARN_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_CHECK_THROWS_WITH, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_REQUIRE_THROWS_WITH, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_WITH_AS, message, __VA_ARGS__)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_WITH_AS, message, __VA_ARGS__)

#define DOCTEST_WARN_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_WARN_NOTHROW, __VA_ARGS__)
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_CHECK_NOTHROW, __VA_ARGS__)
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_REQUIRE_NOTHROW, __VA_ARGS__)

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_AS(expr, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH(expr, with); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_SCOPE_BEGIN { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_NOTHROW(expr); } DOCTEST_FUNC_SCOPE_END
// clang-format on

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// =================================================================================================
// == WHAT FOLLOWS IS VERSIONS OF THE MACROS THAT DO NOT DO ANY REGISTERING!                      ==
// == THIS CAN BE ENABLED BY DEFINING DOCTEST_CONFIG_DISABLE GLOBALLY!                            ==
// =================================================================================================
#else // DOCTEST_CONFIG_DISABLE

#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, name)                                           \
    namespace /* NOLINT */ {                                                                       \
        template &lt;typename DOCTEST_UNUSED_TEMPLATE_TYPE&gt;                                           \
        struct der : public base                                                                   \
        { void f(); };                                                                             \
    }                                                                                              \
    template &lt;typename DOCTEST_UNUSED_TEMPLATE_TYPE&gt;                                               \
    inline void der&lt;DOCTEST_UNUSED_TEMPLATE_TYPE&gt;::f()

#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, name)                                              \
    template &lt;typename DOCTEST_UNUSED_TEMPLATE_TYPE&gt;                                               \
    static inline void f()

// for registering tests
#define DOCTEST_TEST_CASE(name)                                                                    \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests in classes
#define DOCTEST_TEST_CASE_CLASS(name)                                                              \
    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for registering tests with a fixture
#define DOCTEST_TEST_CASE_FIXTURE(x, name)                                                         \
    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(DOCTEST_ANON_CLASS_), x,                           \
                              DOCTEST_ANONYMOUS(DOCTEST_ANON_FUNC_), name)

// for converting types to strings without the &lt;typeinfo&gt; header and demangling
#define DOCTEST_TYPE_TO_STRING_AS(str, ...) static_assert(true, "")
#define DOCTEST_TYPE_TO_STRING(...) static_assert(true, "")

// for typed tests
#define DOCTEST_TEST_CASE_TEMPLATE(name, type, ...)                                                \
    template &lt;typename type&gt;                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, type, id)                                          \
    template &lt;typename type&gt;                                                                       \
    inline void DOCTEST_ANONYMOUS(DOCTEST_ANON_TMP_)()

#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...) static_assert(true, "")
#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...) static_assert(true, "")

// for subcases
#define DOCTEST_SUBCASE(name)

// for a testsuite block
#define DOCTEST_TEST_SUITE(name) namespace // NOLINT

// for starting a testsuite block
#define DOCTEST_TEST_SUITE_BEGIN(name) static_assert(true, "")

// for ending a testsuite block
#define DOCTEST_TEST_SUITE_END using DOCTEST_ANONYMOUS(DOCTEST_ANON_FOR_SEMICOLON_) = int

#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \
    template &lt;typename DOCTEST_UNUSED_TEMPLATE_TYPE&gt;                                               \
    static inline doctest::String DOCTEST_ANONYMOUS(DOCTEST_ANON_TRANSLATOR_)(signature)

#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)

#define DOCTEST_INFO(...) (static_cast&lt;void&gt;(0))
#define DOCTEST_CAPTURE(x) (static_cast&lt;void&gt;(0))
#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) (static_cast&lt;void&gt;(0))
#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) (static_cast&lt;void&gt;(0))
#define DOCTEST_ADD_FAIL_AT(file, line, ...) (static_cast&lt;void&gt;(0))
#define DOCTEST_MESSAGE(...) (static_cast&lt;void&gt;(0))
#define DOCTEST_FAIL_CHECK(...) (static_cast&lt;void&gt;(0))
#define DOCTEST_FAIL(...) (static_cast&lt;void&gt;(0))

#if defined(DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED)                                    \
 &amp;&amp; defined(DOCTEST_CONFIG_ASSERTS_RETURN_VALUES)

#define DOCTEST_WARN(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_CHECK(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_WARN_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()

#define DOCTEST_WARN_MESSAGE(cond, ...) [&amp;] { return cond; }()
#define DOCTEST_CHECK_MESSAGE(cond, ...) [&amp;] { return cond; }()
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) [&amp;] { return cond; }()
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) [&amp;] { return !(cond); }()
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) [&amp;] { return !(cond); }()
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) [&amp;] { return !(cond); }()

namespace doctest {
    namespace detail {
#define DOCTEST_RELATIONAL_OP(name, op)                                                            \
    template &lt;typename L, typename R&gt;                                                              \
    bool name(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) { return lhs op rhs; }

        DOCTEST_RELATIONAL_OP(eq, == )
            DOCTEST_RELATIONAL_OP(ne, != )
            DOCTEST_RELATIONAL_OP(lt, &lt; )
            DOCTEST_RELATIONAL_OP(gt, &gt; )
            DOCTEST_RELATIONAL_OP(le, &lt;= )
            DOCTEST_RELATIONAL_OP(ge, &gt;= )
    } // namespace detail
} // namespace doctest

#define DOCTEST_WARN_EQ(...) [&amp;] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_CHECK_EQ(...) [&amp;] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_EQ(...) [&amp;] { return doctest::detail::eq(__VA_ARGS__); }()
#define DOCTEST_WARN_NE(...) [&amp;] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_CHECK_NE(...) [&amp;] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_NE(...) [&amp;] { return doctest::detail::ne(__VA_ARGS__); }()
#define DOCTEST_WARN_LT(...) [&amp;] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_CHECK_LT(...) [&amp;] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LT(...) [&amp;] { return doctest::detail::lt(__VA_ARGS__); }()
#define DOCTEST_WARN_GT(...) [&amp;] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_CHECK_GT(...) [&amp;] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GT(...) [&amp;] { return doctest::detail::gt(__VA_ARGS__); }()
#define DOCTEST_WARN_LE(...) [&amp;] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_CHECK_LE(...) [&amp;] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_LE(...) [&amp;] { return doctest::detail::le(__VA_ARGS__); }()
#define DOCTEST_WARN_GE(...) [&amp;] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_CHECK_GE(...) [&amp;] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_GE(...) [&amp;] { return doctest::detail::ge(__VA_ARGS__); }()
#define DOCTEST_WARN_UNARY(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_CHECK_UNARY(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_REQUIRE_UNARY(...) [&amp;] { return __VA_ARGS__; }()
#define DOCTEST_WARN_UNARY_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()
#define DOCTEST_CHECK_UNARY_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()
#define DOCTEST_REQUIRE_UNARY_FALSE(...) [&amp;] { return !(__VA_ARGS__); }()

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS_WITH(expr, with, ...) [] { static_assert(false, "Exception translation is not available when doctest is disabled."); return false; }()
#define DOCTEST_CHECK_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH(,,)

#define DOCTEST_WARN_THROWS(...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS(...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS(...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS(expr, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS(expr, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW(...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW(...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW(...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return false; } catch (...) { return true; } }()
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) [&amp;] { try { expr; } catch (__VA_ARGS__) { return true; } catch (...) { } return false; }()
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) [&amp;] { try { __VA_ARGS__; return true; } catch (...) { return false; } }()

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#else // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#define DOCTEST_WARN(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_EQ(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LT(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_GE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_LE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_LE(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_FUNC_EMPTY

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS

#define DOCTEST_WARN_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_FUNC_EMPTY

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_FUNC_EMPTY

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

#endif // DOCTEST_CONFIG_EVALUATE_ASSERTS_EVEN_WHEN_DISABLED

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS

#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC DOCTEST_FUNC_EMPTY
#else // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS
#define DOCTEST_EXCEPTION_EMPTY_FUNC [] { static_assert(false, "Exceptions are disabled! " \
    "Use DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS if you want to compile with exceptions disabled."); return false; }()

#undef DOCTEST_REQUIRE
#undef DOCTEST_REQUIRE_FALSE
#undef DOCTEST_REQUIRE_MESSAGE
#undef DOCTEST_REQUIRE_FALSE_MESSAGE
#undef DOCTEST_REQUIRE_EQ
#undef DOCTEST_REQUIRE_NE
#undef DOCTEST_REQUIRE_GT
#undef DOCTEST_REQUIRE_LT
#undef DOCTEST_REQUIRE_GE
#undef DOCTEST_REQUIRE_LE
#undef DOCTEST_REQUIRE_UNARY
#undef DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_REQUIRE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_FALSE_MESSAGE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_EQ DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LT DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_GE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_LE DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_UNARY_FALSE DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS

#define DOCTEST_WARN_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_EXCEPTION_EMPTY_FUNC

#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC
#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_EXCEPTION_EMPTY_FUNC

#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

// clang-format off
// KEPT FOR BACKWARDS COMPATIBILITY - FORWARDING TO THE RIGHT MACROS
#define DOCTEST_FAST_WARN_EQ             DOCTEST_WARN_EQ
#define DOCTEST_FAST_CHECK_EQ            DOCTEST_CHECK_EQ
#define DOCTEST_FAST_REQUIRE_EQ          DOCTEST_REQUIRE_EQ
#define DOCTEST_FAST_WARN_NE             DOCTEST_WARN_NE
#define DOCTEST_FAST_CHECK_NE            DOCTEST_CHECK_NE
#define DOCTEST_FAST_REQUIRE_NE          DOCTEST_REQUIRE_NE
#define DOCTEST_FAST_WARN_GT             DOCTEST_WARN_GT
#define DOCTEST_FAST_CHECK_GT            DOCTEST_CHECK_GT
#define DOCTEST_FAST_REQUIRE_GT          DOCTEST_REQUIRE_GT
#define DOCTEST_FAST_WARN_LT             DOCTEST_WARN_LT
#define DOCTEST_FAST_CHECK_LT            DOCTEST_CHECK_LT
#define DOCTEST_FAST_REQUIRE_LT          DOCTEST_REQUIRE_LT
#define DOCTEST_FAST_WARN_GE             DOCTEST_WARN_GE
#define DOCTEST_FAST_CHECK_GE            DOCTEST_CHECK_GE
#define DOCTEST_FAST_REQUIRE_GE          DOCTEST_REQUIRE_GE
#define DOCTEST_FAST_WARN_LE             DOCTEST_WARN_LE
#define DOCTEST_FAST_CHECK_LE            DOCTEST_CHECK_LE
#define DOCTEST_FAST_REQUIRE_LE          DOCTEST_REQUIRE_LE

#define DOCTEST_FAST_WARN_UNARY          DOCTEST_WARN_UNARY
#define DOCTEST_FAST_CHECK_UNARY         DOCTEST_CHECK_UNARY
#define DOCTEST_FAST_REQUIRE_UNARY       DOCTEST_REQUIRE_UNARY
#define DOCTEST_FAST_WARN_UNARY_FALSE    DOCTEST_WARN_UNARY_FALSE
#define DOCTEST_FAST_CHECK_UNARY_FALSE   DOCTEST_CHECK_UNARY_FALSE
#define DOCTEST_FAST_REQUIRE_UNARY_FALSE DOCTEST_REQUIRE_UNARY_FALSE

#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id,__VA_ARGS__)
// clang-format on

// BDD style macros
// clang-format off
#define DOCTEST_SCENARIO(name) DOCTEST_TEST_CASE("  Scenario: " name)
#define DOCTEST_SCENARIO_CLASS(name) DOCTEST_TEST_CASE_CLASS("  Scenario: " name)
#define DOCTEST_SCENARIO_TEMPLATE(name, T, ...)  DOCTEST_TEST_CASE_TEMPLATE("  Scenario: " name, T, __VA_ARGS__)
#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE("  Scenario: " name, T, id)

#define DOCTEST_GIVEN(name)     DOCTEST_SUBCASE("   Given: " name)
#define DOCTEST_WHEN(name)      DOCTEST_SUBCASE("    When: " name)
#define DOCTEST_AND_WHEN(name)  DOCTEST_SUBCASE("And when: " name)
#define DOCTEST_THEN(name)      DOCTEST_SUBCASE("    Then: " name)
#define DOCTEST_AND_THEN(name)  DOCTEST_SUBCASE("     And: " name)
// clang-format on

// == SHORT VERSIONS OF THE MACROS
#ifndef DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#define TEST_CASE(name) DOCTEST_TEST_CASE(name)
#define TEST_CASE_CLASS(name) DOCTEST_TEST_CASE_CLASS(name)
#define TEST_CASE_FIXTURE(x, name) DOCTEST_TEST_CASE_FIXTURE(x, name)
#define TYPE_TO_STRING_AS(str, ...) DOCTEST_TYPE_TO_STRING_AS(str, __VA_ARGS__)
#define TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING(__VA_ARGS__)
#define TEST_CASE_TEMPLATE(name, T, ...) DOCTEST_TEST_CASE_TEMPLATE(name, T, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, T, id)
#define TEST_CASE_TEMPLATE_INVOKE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, __VA_ARGS__)
#define TEST_CASE_TEMPLATE_APPLY(id, ...) DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, __VA_ARGS__)
#define SUBCASE(name) DOCTEST_SUBCASE(name)
#define TEST_SUITE(decorators) DOCTEST_TEST_SUITE(decorators)
#define TEST_SUITE_BEGIN(name) DOCTEST_TEST_SUITE_BEGIN(name)
#define TEST_SUITE_END DOCTEST_TEST_SUITE_END
#define REGISTER_EXCEPTION_TRANSLATOR(signature) DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)
#define REGISTER_REPORTER(name, priority, reporter) DOCTEST_REGISTER_REPORTER(name, priority, reporter)
#define REGISTER_LISTENER(name, priority, reporter) DOCTEST_REGISTER_LISTENER(name, priority, reporter)
#define INFO(...) DOCTEST_INFO(__VA_ARGS__)
#define CAPTURE(x) DOCTEST_CAPTURE(x)
#define ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_MESSAGE_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_FAIL_CHECK_AT(file, line, __VA_ARGS__)
#define ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_FAIL_AT(file, line, __VA_ARGS__)
#define MESSAGE(...) DOCTEST_MESSAGE(__VA_ARGS__)
#define FAIL_CHECK(...) DOCTEST_FAIL_CHECK(__VA_ARGS__)
#define FAIL(...) DOCTEST_FAIL(__VA_ARGS__)
#define TO_LVALUE(...) DOCTEST_TO_LVALUE(__VA_ARGS__)

#define WARN(...) DOCTEST_WARN(__VA_ARGS__)
#define WARN_FALSE(...) DOCTEST_WARN_FALSE(__VA_ARGS__)
#define WARN_THROWS(...) DOCTEST_WARN_THROWS(__VA_ARGS__)
#define WARN_THROWS_AS(expr, ...) DOCTEST_WARN_THROWS_AS(expr, __VA_ARGS__)
#define WARN_THROWS_WITH(expr, ...) DOCTEST_WARN_THROWS_WITH(expr, __VA_ARGS__)
#define WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_WARN_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define WARN_NOTHROW(...) DOCTEST_WARN_NOTHROW(__VA_ARGS__)
#define CHECK(...) DOCTEST_CHECK(__VA_ARGS__)
#define CHECK_FALSE(...) DOCTEST_CHECK_FALSE(__VA_ARGS__)
#define CHECK_THROWS(...) DOCTEST_CHECK_THROWS(__VA_ARGS__)
#define CHECK_THROWS_AS(expr, ...) DOCTEST_CHECK_THROWS_AS(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH(expr, ...) DOCTEST_CHECK_THROWS_WITH(expr, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define CHECK_NOTHROW(...) DOCTEST_CHECK_NOTHROW(__VA_ARGS__)
#define REQUIRE(...) DOCTEST_REQUIRE(__VA_ARGS__)
#define REQUIRE_FALSE(...) DOCTEST_REQUIRE_FALSE(__VA_ARGS__)
#define REQUIRE_THROWS(...) DOCTEST_REQUIRE_THROWS(__VA_ARGS__)
#define REQUIRE_THROWS_AS(expr, ...) DOCTEST_REQUIRE_THROWS_AS(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH(expr, ...) DOCTEST_REQUIRE_THROWS_WITH(expr, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, __VA_ARGS__)
#define REQUIRE_NOTHROW(...) DOCTEST_REQUIRE_NOTHROW(__VA_ARGS__)

#define WARN_MESSAGE(cond, ...) DOCTEST_WARN_MESSAGE(cond, __VA_ARGS__)
#define WARN_FALSE_MESSAGE(cond, ...) DOCTEST_WARN_FALSE_MESSAGE(cond, __VA_ARGS__)
#define WARN_THROWS_MESSAGE(expr, ...) DOCTEST_WARN_THROWS_MESSAGE(expr, __VA_ARGS__)
#define WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_WARN_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define CHECK_MESSAGE(cond, ...) DOCTEST_CHECK_MESSAGE(cond, __VA_ARGS__)
#define CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_CHECK_FALSE_MESSAGE(cond, __VA_ARGS__)
#define CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_CHECK_THROWS_MESSAGE(expr, __VA_ARGS__)
#define CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_CHECK_NOTHROW_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_MESSAGE(cond, ...) DOCTEST_REQUIRE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_REQUIRE_FALSE_MESSAGE(cond, __VA_ARGS__)
#define REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_REQUIRE_THROWS_MESSAGE(expr, __VA_ARGS__)
#define REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)
#define REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)
#define REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, __VA_ARGS__)

#define SCENARIO(name) DOCTEST_SCENARIO(name)
#define SCENARIO_CLASS(name) DOCTEST_SCENARIO_CLASS(name)
#define SCENARIO_TEMPLATE(name, T, ...) DOCTEST_SCENARIO_TEMPLATE(name, T, __VA_ARGS__)
#define SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id)
#define GIVEN(name) DOCTEST_GIVEN(name)
#define WHEN(name) DOCTEST_WHEN(name)
#define AND_WHEN(name) DOCTEST_AND_WHEN(name)
#define THEN(name) DOCTEST_THEN(name)
#define AND_THEN(name) DOCTEST_AND_THEN(name)

#define WARN_EQ(...) DOCTEST_WARN_EQ(__VA_ARGS__)
#define CHECK_EQ(...) DOCTEST_CHECK_EQ(__VA_ARGS__)
#define REQUIRE_EQ(...) DOCTEST_REQUIRE_EQ(__VA_ARGS__)
#define WARN_NE(...) DOCTEST_WARN_NE(__VA_ARGS__)
#define CHECK_NE(...) DOCTEST_CHECK_NE(__VA_ARGS__)
#define REQUIRE_NE(...) DOCTEST_REQUIRE_NE(__VA_ARGS__)
#define WARN_GT(...) DOCTEST_WARN_GT(__VA_ARGS__)
#define CHECK_GT(...) DOCTEST_CHECK_GT(__VA_ARGS__)
#define REQUIRE_GT(...) DOCTEST_REQUIRE_GT(__VA_ARGS__)
#define WARN_LT(...) DOCTEST_WARN_LT(__VA_ARGS__)
#define CHECK_LT(...) DOCTEST_CHECK_LT(__VA_ARGS__)
#define REQUIRE_LT(...) DOCTEST_REQUIRE_LT(__VA_ARGS__)
#define WARN_GE(...) DOCTEST_WARN_GE(__VA_ARGS__)
#define CHECK_GE(...) DOCTEST_CHECK_GE(__VA_ARGS__)
#define REQUIRE_GE(...) DOCTEST_REQUIRE_GE(__VA_ARGS__)
#define WARN_LE(...) DOCTEST_WARN_LE(__VA_ARGS__)
#define CHECK_LE(...) DOCTEST_CHECK_LE(__VA_ARGS__)
#define REQUIRE_LE(...) DOCTEST_REQUIRE_LE(__VA_ARGS__)
#define WARN_UNARY(...) DOCTEST_WARN_UNARY(__VA_ARGS__)
#define CHECK_UNARY(...) DOCTEST_CHECK_UNARY(__VA_ARGS__)
#define REQUIRE_UNARY(...) DOCTEST_REQUIRE_UNARY(__VA_ARGS__)
#define WARN_UNARY_FALSE(...) DOCTEST_WARN_UNARY_FALSE(__VA_ARGS__)
#define CHECK_UNARY_FALSE(...) DOCTEST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define REQUIRE_UNARY_FALSE(...) DOCTEST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

// KEPT FOR BACKWARDS COMPATIBILITY
#define FAST_WARN_EQ(...) DOCTEST_FAST_WARN_EQ(__VA_ARGS__)
#define FAST_CHECK_EQ(...) DOCTEST_FAST_CHECK_EQ(__VA_ARGS__)
#define FAST_REQUIRE_EQ(...) DOCTEST_FAST_REQUIRE_EQ(__VA_ARGS__)
#define FAST_WARN_NE(...) DOCTEST_FAST_WARN_NE(__VA_ARGS__)
#define FAST_CHECK_NE(...) DOCTEST_FAST_CHECK_NE(__VA_ARGS__)
#define FAST_REQUIRE_NE(...) DOCTEST_FAST_REQUIRE_NE(__VA_ARGS__)
#define FAST_WARN_GT(...) DOCTEST_FAST_WARN_GT(__VA_ARGS__)
#define FAST_CHECK_GT(...) DOCTEST_FAST_CHECK_GT(__VA_ARGS__)
#define FAST_REQUIRE_GT(...) DOCTEST_FAST_REQUIRE_GT(__VA_ARGS__)
#define FAST_WARN_LT(...) DOCTEST_FAST_WARN_LT(__VA_ARGS__)
#define FAST_CHECK_LT(...) DOCTEST_FAST_CHECK_LT(__VA_ARGS__)
#define FAST_REQUIRE_LT(...) DOCTEST_FAST_REQUIRE_LT(__VA_ARGS__)
#define FAST_WARN_GE(...) DOCTEST_FAST_WARN_GE(__VA_ARGS__)
#define FAST_CHECK_GE(...) DOCTEST_FAST_CHECK_GE(__VA_ARGS__)
#define FAST_REQUIRE_GE(...) DOCTEST_FAST_REQUIRE_GE(__VA_ARGS__)
#define FAST_WARN_LE(...) DOCTEST_FAST_WARN_LE(__VA_ARGS__)
#define FAST_CHECK_LE(...) DOCTEST_FAST_CHECK_LE(__VA_ARGS__)
#define FAST_REQUIRE_LE(...) DOCTEST_FAST_REQUIRE_LE(__VA_ARGS__)

#define FAST_WARN_UNARY(...) DOCTEST_FAST_WARN_UNARY(__VA_ARGS__)
#define FAST_CHECK_UNARY(...) DOCTEST_FAST_CHECK_UNARY(__VA_ARGS__)
#define FAST_REQUIRE_UNARY(...) DOCTEST_FAST_REQUIRE_UNARY(__VA_ARGS__)
#define FAST_WARN_UNARY_FALSE(...) DOCTEST_FAST_WARN_UNARY_FALSE(__VA_ARGS__)
#define FAST_CHECK_UNARY_FALSE(...) DOCTEST_FAST_CHECK_UNARY_FALSE(__VA_ARGS__)
#define FAST_REQUIRE_UNARY_FALSE(...) DOCTEST_FAST_REQUIRE_UNARY_FALSE(__VA_ARGS__)

#define TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, __VA_ARGS__)

#endif // DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES

#ifndef DOCTEST_CONFIG_DISABLE

// this is here to clear the 'current test suite' for the current translation unit - at the top
<span style = "background-color:#dfd">DOCTEST_TEST_SUITE_END();</span>

#endif // DOCTEST_CONFIG_DISABLE

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_INCLUDED

#ifndef DOCTEST_SINGLE_HEADER
#define DOCTEST_SINGLE_HEADER
#endif // DOCTEST_SINGLE_HEADER

#if defined(DOCTEST_CONFIG_IMPLEMENT) || !defined(DOCTEST_SINGLE_HEADER)

#ifndef DOCTEST_SINGLE_HEADER
#include "doctest_fwd.h"
#endif // DOCTEST_SINGLE_HEADER

DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wunused-macros")

#ifndef DOCTEST_LIBRARY_IMPLEMENTATION
#define DOCTEST_LIBRARY_IMPLEMENTATION

DOCTEST_CLANG_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_PUSH

DOCTEST_CLANG_SUPPRESS_WARNING_PUSH
DOCTEST_CLANG_SUPPRESS_WARNING("-Wglobal-constructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wexit-time-destructors")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wshorten-64-to-32")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-variable-declarations")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wcovered-switch-default")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-noreturn")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wdisabled-macro-expansion")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wunused-member-function")
DOCTEST_CLANG_SUPPRESS_WARNING("-Wnonportable-system-include-path")

DOCTEST_GCC_SUPPRESS_WARNING_PUSH
DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-field-initializers")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-braces")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-enum")
DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-default")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunsafe-loop-optimizations")
DOCTEST_GCC_SUPPRESS_WARNING("-Wold-style-cast")
DOCTEST_GCC_SUPPRESS_WARNING("-Wunused-function")
DOCTEST_GCC_SUPPRESS_WARNING("-Wmultiple-inheritance")
DOCTEST_GCC_SUPPRESS_WARNING("-Wsuggest-attribute")

DOCTEST_MSVC_SUPPRESS_WARNING_PUSH
DOCTEST_MSVC_SUPPRESS_WARNING(4267) // 'var' : conversion from 'x' to 'y', possible loss of data
DOCTEST_MSVC_SUPPRESS_WARNING(4530) // C++ exception handler used, but unwind semantics not enabled
DOCTEST_MSVC_SUPPRESS_WARNING(4577) // 'noexcept' used with no exception handling mode specified
DOCTEST_MSVC_SUPPRESS_WARNING(4774) // format string expected in argument is not a string literal
DOCTEST_MSVC_SUPPRESS_WARNING(4365) // conversion from 'int' to 'unsigned', signed/unsigned mismatch
DOCTEST_MSVC_SUPPRESS_WARNING(5039) // pointer to potentially throwing function passed to extern C
DOCTEST_MSVC_SUPPRESS_WARNING(4800) // forcing value to bool 'true' or 'false' (performance warning)
DOCTEST_MSVC_SUPPRESS_WARNING(5245) // unreferenced function with internal linkage has been removed

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN

// required includes - will go only in one translation unit!
#include &lt;ctime&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
// borland (Embarcadero) compiler requires math.h and not cmath - https://github.com/doctest/doctest/pull/37
#ifdef __BORLANDC__
#include &lt;math.h&gt;
#endif // __BORLANDC__
#include &lt;new&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include &lt;iostream&gt;
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#ifndef DOCTEST_CONFIG_NO_MULTITHREADING
#include &lt;atomic&gt;
#include &lt;mutex&gt;
#define DOCTEST_DECLARE_MUTEX(name) std::mutex name;
#define DOCTEST_DECLARE_STATIC_MUTEX(name) static DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name) std::lock_guard&lt;std::mutex&gt; DOCTEST_ANONYMOUS(DOCTEST_ANON_LOCK_)(name);
#else // DOCTEST_CONFIG_NO_MULTITHREADING
#define DOCTEST_DECLARE_MUTEX(name)
#define DOCTEST_DECLARE_STATIC_MUTEX(name)
#define DOCTEST_LOCK_MUTEX(name)
#endif // DOCTEST_CONFIG_NO_MULTITHREADING
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;exception&gt;
#include &lt;stdexcept&gt;
#include &lt;csignal&gt;
#include &lt;cfloat&gt;
#include &lt;cctype&gt;
#include &lt;cstdint&gt;
#include &lt;string&gt;

#ifdef DOCTEST_PLATFORM_MAC
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/sysctl.h&gt;
#endif // DOCTEST_PLATFORM_MAC

#ifdef DOCTEST_PLATFORM_WINDOWS

// defines for a leaner windows.h
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#define DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // WIN32_LEAN_AND_MEAN
#ifndef NOMINMAX
#define NOMINMAX
#define DOCTEST_UNDEF_NOMINMAX
#endif // NOMINMAX

// not sure what AfxWin.h is for - here I do what Catch does
#ifdef __AFXDLL
#include &lt;AfxWin.h&gt;
#else
#include &lt;windows.h&gt;
#endif
#include &lt;io.h&gt;

#else // DOCTEST_PLATFORM_WINDOWS

#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

#endif // DOCTEST_PLATFORM_WINDOWS

// this is a fix for https://github.com/doctest/doctest/issues/348
// https://mail.gnome.org/archives/xml/2012-January/msg00000.html
#if !defined(HAVE_UNISTD_H) &amp;&amp; !defined(STDOUT_FILENO)
#define STDOUT_FILENO fileno(stdout)
#endif // HAVE_UNISTD_H

DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END

// counts the number of elements in a C array
#define DOCTEST_COUNTOF(x) (sizeof(x) / sizeof(x[0]))

#ifdef DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_disabled
#else // DOCTEST_CONFIG_DISABLE
#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_not_disabled
#endif // DOCTEST_CONFIG_DISABLE

#ifndef DOCTEST_CONFIG_OPTIONS_PREFIX
#define DOCTEST_CONFIG_OPTIONS_PREFIX "dt-"
#endif

#ifndef DOCTEST_THREAD_LOCAL
#if defined(DOCTEST_CONFIG_NO_MULTITHREADING) || DOCTEST_MSVC &amp;&amp; (DOCTEST_MSVC &lt; DOCTEST_COMPILER(19, 0, 0))
#define DOCTEST_THREAD_LOCAL
#else // DOCTEST_MSVC
#define DOCTEST_THREAD_LOCAL thread_local
#endif // DOCTEST_MSVC
#endif // DOCTEST_THREAD_LOCAL

#ifndef DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES
#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES 32
#endif

#ifndef DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE
#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE 64
#endif

#ifdef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
#define DOCTEST_OPTIONS_PREFIX_DISPLAY DOCTEST_CONFIG_OPTIONS_PREFIX
#else
#define DOCTEST_OPTIONS_PREFIX_DISPLAY ""
#endif

#if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY == WINAPI_FAMILY_APP)
#define DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
#endif

#ifndef DOCTEST_CDECL
#define DOCTEST_CDECL __cdecl
#endif

    namespace doctest {

    bool is_running_in_test = false;

    namespace {
        using namespace detail;

        template &lt;typename Ex&gt;
<span style = "background-color:#fdd">        DOCTEST_NORETURN void throw_exception(Ex const&amp; e) {</span>
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#fdd">            throw e;</span>
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
#ifdef DOCTEST_CONFIG_HANDLE_EXCEPTION
            DOCTEST_CONFIG_HANDLE_EXCEPTION(e);
#else // DOCTEST_CONFIG_HANDLE_EXCEPTION
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            std::cerr &lt;&lt; "doctest will terminate because it needed to throw an exception.\n"
                &lt;&lt; "The message was: " &lt;&lt; e.what() &lt;&lt; '\n';
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
#endif // DOCTEST_CONFIG_HANDLE_EXCEPTION
            std::terminate();
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#fdd">        }</span>

#ifndef DOCTEST_INTERNAL_ERROR
#define DOCTEST_INTERNAL_ERROR(msg)                                                                \
    throw_exception(std::logic_error(                                                              \
            __FILE__ ":" DOCTEST_TOSTR(__LINE__) ": Internal doctest error: " msg))
#endif // DOCTEST_INTERNAL_ERROR

        // case insensitive strcmp
<span style = "background-color:#dfd">        int stricmp(const char* a, const char* b) {
            for (;; a++, b++) {
                const int d = tolower(*a) - tolower(*b);
                if (d != 0 || !*a)
                    return d;
            }
        }</span>

        struct Endianness
        {
            enum Arch
            {
                Big,
                Little
            };

            static Arch which() {
                int x = 1;
                // casting any data pointer to char* is allowed
                auto ptr = reinterpret_cast&lt;char*&gt;(&amp;x);
                if (*ptr)
                    return Little;
                return Big;
            }
        };
    } // namespace

    namespace detail {
        DOCTEST_THREAD_LOCAL class
        {
            std::vector&lt;std::streampos&gt; stack;
            std::stringstream           ss;

        public:
<span style = "background-color:#fdd">            std::ostream* push() {
                stack.push_back(ss.tellp());
                return &amp;ss;
            }</span>

<span style = "background-color:#fdd">            String pop() {
                if (stack.empty())
                    DOCTEST_INTERNAL_ERROR("TLSS was empty when trying to pop!");</span>

<span style = "background-color:#fdd">                std::streampos pos = stack.back();
                stack.pop_back();
                unsigned sz = static_cast&lt;unsigned&gt;(ss.tellp() - pos);
                ss.rdbuf()-&gt;pubseekpos(pos, std::ios::in | std::ios::out);
                return String(ss, sz);
            }</span>
<span style = "background-color:#dfd">        } g_oss;</span>

<span style = "background-color:#fdd">        std::ostream* tlssPush() {
            return g_oss.push();
        }</span>

<span style = "background-color:#fdd">        String tlssPop() {
            return g_oss.pop();
        }</span>

#ifndef DOCTEST_CONFIG_DISABLE

        namespace timer_large_integer
        {

#if defined(DOCTEST_PLATFORM_WINDOWS)
            using type = ULONGLONG;
#else // DOCTEST_PLATFORM_WINDOWS
            using type = std::uint64_t;
#endif // DOCTEST_PLATFORM_WINDOWS
        }

        using ticks_t = timer_large_integer::type;

#ifdef DOCTEST_CONFIG_GETCURRENTTICKS
        ticks_t getCurrentTicks() { return DOCTEST_CONFIG_GETCURRENTTICKS(); }
#elif defined(DOCTEST_PLATFORM_WINDOWS)
<span style = "background-color:#dfd">        ticks_t getCurrentTicks() {</span>
            static LARGE_INTEGER hz = { {0} }, hzo = { {0} };
<span style = "background-color:#dfd">            if (!hz.QuadPart) {
                QueryPerformanceFrequency(&amp;hz);
                QueryPerformanceCounter(&amp;hzo);</span>
            }
            LARGE_INTEGER t;
<span style = "background-color:#dfd">            QueryPerformanceCounter(&amp;t);
            return ((t.QuadPart - hzo.QuadPart) * LONGLONG(1000000)) / hz.QuadPart;
        }</span>
#else  // DOCTEST_PLATFORM_WINDOWS
        ticks_t getCurrentTicks() {
            timeval t;
            gettimeofday(&amp;t, nullptr);
            return static_cast&lt;ticks_t&gt;(t.tv_sec) * 1000000 + static_cast&lt;ticks_t&gt;(t.tv_usec);
        }
#endif // DOCTEST_PLATFORM_WINDOWS

        struct Timer
        {
<span style = "background-color:#dfd">            void         start() { m_ticks = getCurrentTicks(); }</span>
            unsigned int getElapsedMicroseconds() const {
                return static_cast&lt;unsigned int&gt;(getCurrentTicks() - m_ticks);
            }
            //unsigned int getElapsedMilliseconds() const {
            //    return static_cast&lt;unsigned int&gt;(getElapsedMicroseconds() / 1000);
            //}
<span style = "background-color:#dfd">            double getElapsedSeconds() const { return static_cast&lt;double&gt;(getCurrentTicks() - m_ticks) / 1000000.0; }</span>

        private:
            ticks_t m_ticks = 0;
        };

#ifdef DOCTEST_CONFIG_NO_MULTITHREADING
        template &lt;typename T&gt;
        using Atomic = T;
#else // DOCTEST_CONFIG_NO_MULTITHREADING
        template &lt;typename T&gt;
        using Atomic = std::atomic&lt;T&gt;;
#endif // DOCTEST_CONFIG_NO_MULTITHREADING

#if defined(DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS) || defined(DOCTEST_CONFIG_NO_MULTITHREADING)
        template &lt;typename T&gt;
        using MultiLaneAtomic = Atomic&lt;T&gt;;
#else // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS
        // Provides a multilane implementation of an atomic variable that supports add, sub, load,
        // store. Instead of using a single atomic variable, this splits up into multiple ones,
        // each sitting on a separate cache line. The goal is to provide a speedup when most
        // operations are modifying. It achieves this with two properties:
        //
        // * Multiple atomics are used, so chance of congestion from the same atomic is reduced.
        // * Each atomic sits on a separate cache line, so false sharing is reduced.
        //
        // The disadvantage is that there is a small overhead due to the use of TLS, and load/store
        // is slower because all atomics have to be accessed.
        template &lt;typename T&gt;
        class MultiLaneAtomic
        {
            struct CacheLineAlignedAtomic
            {
                Atomic&lt;T&gt; atomic{};
                char padding[DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE - sizeof(Atomic&lt;T&gt;)];
            };
            CacheLineAlignedAtomic m_atomics[DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES];

            static_assert(sizeof(CacheLineAlignedAtomic) == DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE,
                "guarantee one atomic takes exactly one cache line");

        public:
            T operator++() DOCTEST_NOEXCEPT { return fetch_add(1) + 1; }

<span style = "background-color:#dfd">            T operator++(int) DOCTEST_NOEXCEPT { return fetch_add(1); }</span>

<span style = "background-color:#dfd">            T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
                return myAtomic().fetch_add(arg, order);
            }</span>

            T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {
                return myAtomic().fetch_sub(arg, order);
            }

<span style = "background-color:#dfd">            operator T() const DOCTEST_NOEXCEPT { return load(); }</span>

<span style = "background-color:#dfd">            T load(std::memory_order order = std::memory_order_seq_cst) const DOCTEST_NOEXCEPT {
                auto result = T();
                for (auto const&amp; c : m_atomics) {
                    result += c.atomic.load(order);
                }
                return result;
            }</span>

<span style = "background-color:#dfd">            T operator=(T desired) DOCTEST_NOEXCEPT { // lgtm [cpp/assignment-does-not-return-this]
                store(desired);
                return desired;
            }</span>

<span style = "background-color:#dfd">            void store(T desired, std::memory_order order = std::memory_order_seq_cst) DOCTEST_NOEXCEPT {</span>
                // first value becomes desired", all others become 0.
<span style = "background-color:#dfd">                for (auto&amp; c : m_atomics) {
                    c.atomic.store(desired, order);
                    desired = {};
                }
            }</span>

        private:
            // Each thread has a different atomic that it operates on. If more than NumLanes threads
            // use this, some will use the same atomic. So performance will degrade a bit, but still
            // everything will work.
            //
            // The logic here is a bit tricky. The call should be as fast as possible, so that there
            // is minimal to no overhead in determining the correct atomic for the current thread.
            //
            // 1. A global static counter laneCounter counts continuously up.
            // 2. Each successive thread will use modulo operation of that counter so it gets an atomic
            //    assigned in a round-robin fashion.
            // 3. This tlsLaneIdx is stored in the thread local data, so it is directly available with
            //    little overhead.
<span style = "background-color:#dfd">            Atomic&lt;T&gt;&amp; myAtomic() DOCTEST_NOEXCEPT {</span>
                static Atomic&lt;size_t&gt; laneCounter;
<span style = "background-color:#dfd">                DOCTEST_THREAD_LOCAL size_t tlsLaneIdx =</span>
                    laneCounter++ % DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES;

<span style = "background-color:#dfd">                return m_atomics[tlsLaneIdx].atomic;
            }</span>
        };
#endif // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS

        // this holds both parameters from the command line and runtime data for tests
        struct ContextState : ContextOptions, TestRunStats, CurrentTestCaseStats
        {
            MultiLaneAtomic&lt;int&gt; numAssertsCurrentTest_atomic;
            MultiLaneAtomic&lt;int&gt; numAssertsFailedCurrentTest_atomic;

            std::vector&lt;std::vector&lt;String&gt;&gt; filters = decltype(filters)(9); // 9 different filters

            std::vector&lt;IReporter*&gt; reporters_currently_used;

            assert_handler ah = nullptr;

            Timer timer;

            std::vector&lt;String&gt; stringifiedContexts; // logging from INFO() due to an exception

            // stuff for subcases
            bool reachedLeaf;
            std::vector&lt;SubcaseSignature&gt; subcaseStack;
            std::vector&lt;SubcaseSignature&gt; nextSubcaseStack;
            std::unordered_set&lt;unsigned long long&gt; fullyTraversedSubcases;
            size_t currentSubcaseDepth;
            Atomic&lt;bool&gt; shouldLogCurrentException;

<span style = "background-color:#dfd">            void resetRunData() {
                numTestCases = 0;
                numTestCasesPassingFilters = 0;
                numTestSuitesPassingFilters = 0;
                numTestCasesFailed = 0;
                numAsserts = 0;
                numAssertsFailed = 0;
                numAssertsCurrentTest = 0;
                numAssertsFailedCurrentTest = 0;
            }</span>

<span style = "background-color:#dfd">            void finalizeTestCaseData() {
                seconds = timer.getElapsedSeconds();</span>

                // update the non-atomic counters
<span style = "background-color:#dfd">                numAsserts += numAssertsCurrentTest_atomic;
                numAssertsFailed += numAssertsFailedCurrentTest_atomic;
                numAssertsCurrentTest = numAssertsCurrentTest_atomic;
                numAssertsFailedCurrentTest = numAssertsFailedCurrentTest_atomic;</span>

<span style = "background-color:#dfd">                if (numAssertsFailedCurrentTest)</span>
<span style = "background-color:#fdd">                    failure_flags |= TestCaseFailureReason::AssertFailure;</span>

<span style = "background-color:#dfd">                if (Approx(currentTest-&gt;m_timeout).epsilon(DBL_EPSILON) != 0 &amp;&amp;</span>
                    Approx(seconds).epsilon(DBL_EPSILON) &gt; currentTest-&gt;m_timeout)
<span style = "background-color:#fdd">                    failure_flags |= TestCaseFailureReason::Timeout;</span>

<span style = "background-color:#dfd">                if (currentTest-&gt;m_should_fail) {</span>
<span style = "background-color:#fdd">                    if (failure_flags) {
                        failure_flags |= TestCaseFailureReason::ShouldHaveFailedAndDid;
                    }</span>
                    else {
<span style = "background-color:#fdd">                        failure_flags |= TestCaseFailureReason::ShouldHaveFailedButDidnt;</span>
                    }
<span style = "background-color:#fdd">                }</span>
<span style = "background-color:#dfd">                else if (failure_flags &amp;&amp; currentTest-&gt;m_may_fail) {</span>
<span style = "background-color:#fdd">                    failure_flags |= TestCaseFailureReason::CouldHaveFailedAndDid;
                }</span>
<span style = "background-color:#dfd">                else if (currentTest-&gt;m_expected_failures &gt; 0) {</span>
<span style = "background-color:#fdd">                    if (numAssertsFailedCurrentTest == currentTest-&gt;m_expected_failures) {
                        failure_flags |= TestCaseFailureReason::FailedExactlyNumTimes;
                    }</span>
                    else {
<span style = "background-color:#fdd">                        failure_flags |= TestCaseFailureReason::DidntFailExactlyNumTimes;</span>
                    }
                }

<span style = "background-color:#dfd">                bool ok_to_fail = (TestCaseFailureReason::ShouldHaveFailedAndDid &amp; failure_flags) ||</span>
                    (TestCaseFailureReason::CouldHaveFailedAndDid &amp; failure_flags) ||
                    (TestCaseFailureReason::FailedExactlyNumTimes &amp; failure_flags);

                // if any subcase has failed - the whole test case has failed
<span style = "background-color:#dfd">                testCaseSuccess = !(failure_flags &amp;&amp; !ok_to_fail);
                if (!testCaseSuccess)</span>
<span style = "background-color:#fdd">                    numTestCasesFailed++;</span>
<span style = "background-color:#dfd">            }</span>
        };

        ContextState* g_cs = nullptr;

        // used to avoid locks for the debug output
        // TODO: figure out if this is indeed necessary/correct - seems like either there still
        // could be a race or that there wouldn't be a race even if using the context directly
        DOCTEST_THREAD_LOCAL bool g_no_colors;

#endif // DOCTEST_CONFIG_DISABLE
    } // namespace detail

<span style = "background-color:#dfd">    char* String::allocate(size_type sz) {
        if (sz &lt;= last) {
            buf[sz] = '\0';
            setLast(last - sz);
            return buf;</span>
<span style = "background-color:#fdd">        }</span>
        else {
<span style = "background-color:#dfd">            setOnHeap();
            data.size = sz;
            data.capacity = data.size + 1;
            data.ptr = new char[data.capacity];
            data.ptr[sz] = '\0';
            return data.ptr;</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void String::setOnHeap() noexcept { *reinterpret_cast&lt;unsigned char*&gt;(&amp;buf[last]) = 128; }
    void String::setLast(size_type in) noexcept { buf[last] = char(in); }</span>
<span style = "background-color:#fdd">    void String::setSize(size_type sz) noexcept {
        if (isOnStack()) { buf[sz] = '\0'; setLast(last - sz); }
        else { data.ptr[sz] = '\0'; data.size = sz; }
    }</span>

<span style = "background-color:#dfd">    void String::copy(const String&amp; other) {
        if (other.isOnStack()) {
            memcpy(buf, other.buf, len);
        }</span>
        else {
<span style = "background-color:#dfd">            memcpy(allocate(other.data.size), other.data.ptr, other.data.size);</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    String::String() noexcept {
        buf[0] = '\0';
        setLast();
    }</span>

<span style = "background-color:#dfd">    String::~String() {
        if (!isOnStack())
            delete[] data.ptr;
    } // NOLINT(clang-analyzer-cplusplus.NewDeleteLeaks)</span>

    String::String(const char* in)
<span style = "background-color:#dfd">        : String(in, strlen(in)) {}</span>

<span style = "background-color:#dfd">    String::String(const char* in, size_type in_size) {
        memcpy(allocate(in_size), in, in_size);
    }</span>

<span style = "background-color:#fdd">    String::String(std::istream&amp; in, size_type in_size) {
        in.read(allocate(in_size), in_size);
    }</span>

<span style = "background-color:#dfd">    String::String(const String&amp; other) { copy(other); }</span>

<span style = "background-color:#dfd">    String&amp; String::operator=(const String&amp; other) {
        if (this != &amp;other) {
            if (!isOnStack())</span>
<span style = "background-color:#fdd">                delete[] data.ptr;</span>

<span style = "background-color:#dfd">            copy(other);</span>
        }

<span style = "background-color:#dfd">        return *this;
    }</span>

<span style = "background-color:#dfd">    String&amp; String::operator+=(const String&amp; other) {
        const size_type my_old_size = size();
        const size_type other_size = other.size();
        const size_type total_size = my_old_size + other_size;
        if (isOnStack()) {
            if (total_size &lt; len) {</span>
                // append to the current stack space
<span style = "background-color:#fdd">                memcpy(buf + my_old_size, other.c_str(), other_size + 1);</span>
                // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)
<span style = "background-color:#fdd">                setLast(last - total_size);
            }</span>
            else {
                // alloc new chunk
<span style = "background-color:#dfd">                char* temp = new char[total_size + 1];</span>
                // copy current data to new location before writing in the union
<span style = "background-color:#dfd">                memcpy(temp, buf, my_old_size); // skip the +1 ('\0') for speed</span>
                // update data in union
<span style = "background-color:#dfd">                setOnHeap();
                data.size = total_size;
                data.capacity = data.size + 1;
                data.ptr = temp;</span>
                // transfer the rest of the data
<span style = "background-color:#dfd">                memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);</span>
            }
<span style = "background-color:#dfd">        }</span>
        else {
<span style = "background-color:#dfd">            if (data.capacity &gt; total_size) {</span>
                // append to the current heap block
<span style = "background-color:#fdd">                data.size = total_size;
                memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);
            }</span>
            else {
                // resize
<span style = "background-color:#dfd">                data.capacity *= 2;
                if (data.capacity &lt;= total_size)</span>
<span style = "background-color:#fdd">                    data.capacity = total_size + 1;</span>
                // alloc new chunk
<span style = "background-color:#dfd">                char* temp = new char[data.capacity];</span>
                // copy current data to new location before releasing it
<span style = "background-color:#dfd">                memcpy(temp, data.ptr, my_old_size); // skip the +1 ('\0') for speed</span>
                // release old chunk
<span style = "background-color:#dfd">                delete[] data.ptr;</span>
                // update the rest of the union members
<span style = "background-color:#dfd">                data.size = total_size;
                data.ptr = temp;</span>
                // transfer the rest of the data
<span style = "background-color:#dfd">                memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);</span>
            }
        }

<span style = "background-color:#dfd">        return *this;
    }</span>

<span style = "background-color:#dfd">    String::String(String&amp;&amp; other) noexcept {
        memcpy(buf, other.buf, len);
        other.buf[0] = '\0';
        other.setLast();
    }</span>

<span style = "background-color:#dfd">    String&amp; String::operator=(String&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            if (!isOnStack())
                delete[] data.ptr;
            memcpy(buf, other.buf, len);
            other.buf[0] = '\0';
            other.setLast();</span>
        }
<span style = "background-color:#dfd">        return *this;
    }</span>

<span style = "background-color:#fdd">    char String::operator[](size_type i) const {
        return const_cast&lt;String*&gt;(this)-&gt;operator[](i);
    }</span>

<span style = "background-color:#fdd">    char&amp; String::operator[](size_type i) {
        if (isOnStack())
            return reinterpret_cast&lt;char*&gt;(buf)[i];
        return data.ptr[i];
    }</span>

    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wmaybe-uninitialized")
<span style = "background-color:#dfd">        String::size_type String::size() const {
        if (isOnStack())
            return last - (size_type(buf[last]) &amp; 31); // using "last" would work only if "len" is 32
        return data.size;
    }</span>
    DOCTEST_GCC_SUPPRESS_WARNING_POP

<span style = "background-color:#fdd">        String::size_type String::capacity() const {
        if (isOnStack())
            return len;
        return data.capacity;
    }</span>

<span style = "background-color:#fdd">    String String::substr(size_type pos, size_type cnt)&amp;&amp; {
        cnt = std::min(cnt, size() - 1 - pos);
        char* cptr = c_str();
        memmove(cptr, cptr + pos, cnt);
        setSize(cnt);
        return std::move(*this);
    }</span>

<span style = "background-color:#fdd">    String String::substr(size_type pos, size_type cnt) const&amp; {
        cnt = std::min(cnt, size() - 1 - pos);
        return String{ c_str() + pos, cnt };
    }</span>

<span style = "background-color:#fdd">    String::size_type String::find(char ch, size_type pos) const {
        const char* begin = c_str();
        const char* end = begin + size();
        const char* it = begin + pos;
        for (; it &lt; end &amp;&amp; *it != ch; it++);
        if (it &lt; end) { return static_cast&lt;size_type&gt;(it - begin); }
        else { return npos; }
    }</span>

<span style = "background-color:#fdd">    String::size_type String::rfind(char ch, size_type pos) const {
        const char* begin = c_str();
        const char* it = begin + std::min(pos, size() - 1);
        for (; it &gt;= begin &amp;&amp; *it != ch; it--);
        if (it &gt;= begin) { return static_cast&lt;size_type&gt;(it - begin); }
        else { return npos; }
    }</span>

<span style = "background-color:#dfd">    int String::compare(const char* other, bool no_case) const {
        if (no_case)
            return doctest::stricmp(c_str(), other);
        return std::strcmp(c_str(), other);
    }</span>

<span style = "background-color:#dfd">    int String::compare(const String&amp; other, bool no_case) const {
        return compare(other.c_str(), no_case);
    }</span>

<span style = "background-color:#dfd">    String operator+(const String&amp; lhs, const String&amp; rhs) { return  String(lhs) += rhs; }</span>

<span style = "background-color:#dfd">    bool operator==(const String&amp; lhs, const String&amp; rhs) { return lhs.compare(rhs) == 0; }</span>
<span style = "background-color:#fdd">    bool operator!=(const String&amp; lhs, const String&amp; rhs) { return lhs.compare(rhs) != 0; }</span>
<span style = "background-color:#dfd">    bool operator&lt; (const String&amp; lhs, const String&amp; rhs) { return lhs.compare(rhs) &lt; 0; }</span>
<span style = "background-color:#fdd">    bool operator&gt; (const String&amp; lhs, const String&amp; rhs) { return lhs.compare(rhs) &gt; 0; }
    bool operator&lt;=(const String&amp; lhs, const String&amp; rhs) { return (lhs != rhs) ? lhs.compare(rhs) &lt; 0 : true; }
    bool operator&gt;=(const String&amp; lhs, const String&amp; rhs) { return (lhs != rhs) ? lhs.compare(rhs) &gt; 0 : true; }</span>

<span style = "background-color:#fdd">    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, const String&amp; in) { return s &lt;&lt; in.c_str(); }</span>

<span style = "background-color:#dfd">    Contains::Contains(const String&amp; str) : string(str) { }</span>

<span style = "background-color:#fdd">    bool Contains::checkWith(const String&amp; other) const {
        return strstr(other.c_str(), string.c_str()) != nullptr;
    }</span>

<span style = "background-color:#fdd">    String toString(const Contains&amp; in) {
        return "Contains( " + in.string + " )";
    }</span>

<span style = "background-color:#fdd">    bool operator==(const String&amp; lhs, const Contains&amp; rhs) { return rhs.checkWith(lhs); }
    bool operator==(const Contains&amp; lhs, const String&amp; rhs) { return lhs.checkWith(rhs); }
    bool operator!=(const String&amp; lhs, const Contains&amp; rhs) { return !rhs.checkWith(lhs); }
    bool operator!=(const Contains&amp; lhs, const String&amp; rhs) { return !lhs.checkWith(rhs); }</span>

    namespace {
        void color_to_stream(std::ostream&amp;, Color::Enum) DOCTEST_BRANCH_ON_DISABLED({}, ;)
    } // namespace

    namespace Color {
<span style = "background-color:#dfd">        std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Color::Enum code) {
            color_to_stream(s, code);
            return s;
        }</span>
    } // namespace Color

    // clang-format off
<span style = "background-color:#fdd">    const char* assertString(assertType::Enum at) {</span>
        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4061) // enum 'x' in switch of enum 'y' is not explicitly handled
#define DOCTEST_GENERATE_ASSERT_TYPE_CASE(assert_type) case assertType::DT_ ## assert_type: return #assert_type
#define DOCTEST_GENERATE_ASSERT_TYPE_CASES(assert_type) \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK_ ## assert_type); \
        DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE_ ## assert_type)
<span style = "background-color:#fdd">            switch (at) {
                DOCTEST_GENERATE_ASSERT_TYPE_CASE(WARN);
                DOCTEST_GENERATE_ASSERT_TYPE_CASE(CHECK);
                DOCTEST_GENERATE_ASSERT_TYPE_CASE(REQUIRE);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(FALSE);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_AS);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(THROWS_WITH_AS);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(NOTHROW);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(EQ);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(NE);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(GT);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(LT);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(GE);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(LE);</span>

<span style = "background-color:#fdd">                DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY);
                DOCTEST_GENERATE_ASSERT_TYPE_CASES(UNARY_FALSE);</span>

<span style = "background-color:#fdd">            default: DOCTEST_INTERNAL_ERROR("Tried stringifying invalid assert type!");</span>
            }
        DOCTEST_MSVC_SUPPRESS_WARNING_POP
<span style = "background-color:#fdd">    }</span>
    // clang-format on

<span style = "background-color:#fdd">    const char* failureString(assertType::Enum at) {
        if (at &amp; assertType::is_warn) //!OCLINT bitwise operator in conditional
            return "WARNING";
        if (at &amp; assertType::is_check) //!OCLINT bitwise operator in conditional
            return "ERROR";
        if (at &amp; assertType::is_require) //!OCLINT bitwise operator in conditional
            return "FATAL ERROR";
        return "";
    }</span>

    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
        DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wnull-dereference")
        // depending on the current options this will remove the path of filenames
<span style = "background-color:#fdd">        const char* skipPathFromFilename(const char* file) {</span>
#ifndef DOCTEST_CONFIG_DISABLE
<span style = "background-color:#fdd">        if (getContextOptions()-&gt;no_path_in_filenames) {
            auto back = std::strrchr(file, '\\');
            auto forward = std::strrchr(file, '/');
            if (back || forward) {
                if (back &gt; forward)
                    forward = back;
                return forward + 1;</span>
            }
        }
#endif // DOCTEST_CONFIG_DISABLE
<span style = "background-color:#fdd">        return file;
    }</span>
    DOCTEST_CLANG_SUPPRESS_WARNING_POP
        DOCTEST_GCC_SUPPRESS_WARNING_POP

<span style = "background-color:#dfd">        bool SubcaseSignature::operator==(const SubcaseSignature&amp; other) const {
        return m_line == other.m_line</span>
            &amp;&amp; std::strcmp(m_file, other.m_file) == 0
            &amp;&amp; m_name == other.m_name;
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#fdd">    bool SubcaseSignature::operator&lt;(const SubcaseSignature&amp; other) const {
        if (m_line != other.m_line)
            return m_line &lt; other.m_line;
        if (std::strcmp(m_file, other.m_file) != 0)
            return std::strcmp(m_file, other.m_file) &lt; 0;
        return m_name.compare(other.m_name) &lt; 0;
    }</span>

<span style = "background-color:#fdd">    DOCTEST_DEFINE_INTERFACE(IContextScope)</span>

        namespace detail {
<span style = "background-color:#fdd">        void filldata&lt;const void*&gt;::fill(std::ostream* stream, const void* in) {
            if (in) { *stream &lt;&lt; in; }
            else { *stream &lt;&lt; "nullptr"; }
        }</span>

        template &lt;typename T&gt;
<span style = "background-color:#fdd">        String toStreamLit(T t) {
            std::ostream* os = tlssPush();
            os-&gt;operator&lt;&lt;(t);
            return tlssPop();
        }</span>
    }

#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING
    String toString(const char* in) { return String("\"") + (in ? in : "{null string}") + "\""; }
#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING

#if DOCTEST_MSVC &gt;= DOCTEST_COMPILER(19, 20, 0)
    // see this issue on why this is needed: https://github.com/doctest/doctest/issues/183
<span style = "background-color:#fdd">    String toString(const std::string&amp; in) { return in.c_str(); }</span>
#endif // VS 2019

<span style = "background-color:#fdd">    String toString(String in) { return in; }</span>

<span style = "background-color:#fdd">    String toString(std::nullptr_t) { return "nullptr"; }</span>

<span style = "background-color:#fdd">    String toString(bool in) { return in ? "true" : "false"; }</span>

<span style = "background-color:#fdd">    String toString(float in) { return toStreamLit(in); }
    String toString(double in) { return toStreamLit(in); }
    String toString(double long in) { return toStreamLit(in); }</span>

<span style = "background-color:#fdd">    String toString(char in) { return toStreamLit(static_cast&lt;signed&gt;(in)); }
    String toString(char signed in) { return toStreamLit(static_cast&lt;signed&gt;(in)); }
    String toString(char unsigned in) { return toStreamLit(static_cast&lt;unsigned&gt;(in)); }
    String toString(short in) { return toStreamLit(in); }
    String toString(short unsigned in) { return toStreamLit(in); }
    String toString(signed in) { return toStreamLit(in); }
    String toString(unsigned in) { return toStreamLit(in); }
    String toString(long in) { return toStreamLit(in); }
    String toString(long unsigned in) { return toStreamLit(in); }
    String toString(long long in) { return toStreamLit(in); }
    String toString(long long unsigned in) { return toStreamLit(in); }</span>

    Approx::Approx(double value)
<span style = "background-color:#dfd">        : m_epsilon(static_cast&lt;double&gt;(std::numeric_limits&lt;float&gt;::epsilon()) * 100)
        , m_scale(1.0)
        , m_value(value) {}</span>

<span style = "background-color:#fdd">    Approx Approx::operator()(double value) const {
        Approx approx(value);
        approx.epsilon(m_epsilon);
        approx.scale(m_scale);
        return approx;
    }</span>

<span style = "background-color:#dfd">    Approx&amp; Approx::epsilon(double newEpsilon) {
        m_epsilon = newEpsilon;
        return *this;
    }</span>
<span style = "background-color:#fdd">    Approx&amp; Approx::scale(double newScale) {
        m_scale = newScale;
        return *this;
    }</span>

<span style = "background-color:#dfd">    bool operator==(double lhs, const Approx&amp; rhs) {</span>
        // Thanks to Richard Harris for his help refining this formula
<span style = "background-color:#dfd">        return std::fabs(lhs - rhs.m_value) &lt;</span>
            rhs.m_epsilon * (rhs.m_scale + std::max&lt;double&gt;(std::fabs(lhs), std::fabs(rhs.m_value)));
<span style = "background-color:#dfd">    }</span>
<span style = "background-color:#fdd">    bool operator==(const Approx&amp; lhs, double rhs) { return operator==(rhs, lhs); }
    bool operator!=(double lhs, const Approx&amp; rhs) { return !operator==(lhs, rhs); }</span>
<span style = "background-color:#dfd">    bool operator!=(const Approx&amp; lhs, double rhs) { return !operator==(rhs, lhs); }</span>
<span style = "background-color:#fdd">    bool operator&lt;=(double lhs, const Approx&amp; rhs) { return lhs &lt; rhs.m_value || lhs == rhs; }
    bool operator&lt;=(const Approx&amp; lhs, double rhs) { return lhs.m_value &lt; rhs || lhs == rhs; }
    bool operator&gt;=(double lhs, const Approx&amp; rhs) { return lhs &gt; rhs.m_value || lhs == rhs; }
    bool operator&gt;=(const Approx&amp; lhs, double rhs) { return lhs.m_value &gt; rhs || lhs == rhs; }
    bool operator&lt;(double lhs, const Approx&amp; rhs) { return lhs &lt; rhs.m_value &amp;&amp; lhs != rhs; }
    bool operator&lt;(const Approx&amp; lhs, double rhs) { return lhs.m_value &lt; rhs &amp;&amp; lhs != rhs; }
    bool operator&gt;(double lhs, const Approx&amp; rhs) { return lhs &gt; rhs.m_value &amp;&amp; lhs != rhs; }
    bool operator&gt;(const Approx&amp; lhs, double rhs) { return lhs.m_value &gt; rhs &amp;&amp; lhs != rhs; }</span>

<span style = "background-color:#fdd">    String toString(const Approx&amp; in) {
        return "Approx( " + doctest::toString(in.m_value) + " )";
    }</span>
<span style = "background-color:#dfd">    const ContextOptions* getContextOptions() { return DOCTEST_BRANCH_ON_DISABLED(nullptr, g_cs); }</span>

    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4738)
        template &lt;typename F&gt;
<span style = "background-color:#fdd">    IsNaN&lt;F&gt;::operator bool() const {
        return std::isnan(value) ^ flipped;
    }</span>
    DOCTEST_MSVC_SUPPRESS_WARNING_POP
        template struct DOCTEST_INTERFACE_DEF IsNaN&lt;float&gt;;
    template struct DOCTEST_INTERFACE_DEF IsNaN&lt;double&gt;;
    template struct DOCTEST_INTERFACE_DEF IsNaN&lt;long double&gt;;
    template &lt;typename F&gt;
<span style = "background-color:#fdd">    String toString(IsNaN&lt;F&gt; in) { return String(in.flipped ? "! " : "") + "IsNaN( " + doctest::toString(in.value) + " )"; }
    String toString(IsNaN&lt;float&gt; in) { return toString&lt;float&gt;(in); }
    String toString(IsNaN&lt;double&gt; in) { return toString&lt;double&gt;(in); }
    String toString(IsNaN&lt;double long&gt; in) { return toString&lt;double long&gt;(in); }</span>

} // namespace doctest

#ifdef DOCTEST_CONFIG_DISABLE
namespace doctest {
    Context::Context(int, const char* const*) {}
    Context::~Context() = default;
    void Context::applyCommandLine(int, const char* const*) {}
    void Context::addFilter(const char*, const char*) {}
    void Context::clearFilters() {}
    void Context::setOption(const char*, bool) {}
    void Context::setOption(const char*, int) {}
    void Context::setOption(const char*, const char*) {}
    bool Context::shouldExit() { return false; }
    void Context::setAsDefaultForAssertsOutOfTestCases() {}
    void Context::setAssertHandler(detail::assert_handler) {}
    void Context::setCout(std::ostream*) {}
    int  Context::run() { return 0; }

    int                         IReporter::get_num_active_contexts() { return 0; }
    const IContextScope* const* IReporter::get_active_contexts() { return nullptr; }
    int                         IReporter::get_num_stringified_contexts() { return 0; }
    const String* IReporter::get_stringified_contexts() { return nullptr; }

    int registerReporter(const char*, int, IReporter*) { return 0; }

} // namespace doctest
#else // DOCTEST_CONFIG_DISABLE

#if !defined(DOCTEST_CONFIG_COLORS_NONE)
#if !defined(DOCTEST_CONFIG_COLORS_WINDOWS) &amp;&amp; !defined(DOCTEST_CONFIG_COLORS_ANSI)
#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_CONFIG_COLORS_WINDOWS
#else // linux
#define DOCTEST_CONFIG_COLORS_ANSI
#endif // platform
#endif // DOCTEST_CONFIG_COLORS_WINDOWS &amp;&amp; DOCTEST_CONFIG_COLORS_ANSI
#endif // DOCTEST_CONFIG_COLORS_NONE

namespace doctest_detail_test_suite_ns {
    // holds the current test suite
<span style = "background-color:#dfd">    doctest::detail::TestSuite&amp; getCurrentTestSuite() {</span>
        static doctest::detail::TestSuite data{};
<span style = "background-color:#dfd">        return data;
    }</span>
} // namespace doctest_detail_test_suite_ns

namespace doctest {
    namespace {
        // the int (priority) is part of the key for automatic sorting - sadly one can register a
        // reporter with a duplicate name and a different priority but hopefully that won't happen often :|
        using reporterMap = std::map&lt;std::pair&lt;int, String&gt;, reporterCreatorFunc&gt;;

<span style = "background-color:#dfd">        reporterMap&amp; getReporters() {
            static reporterMap data;
            return data;
        }
        reporterMap&amp; getListeners() {
            static reporterMap data;
            return data;
        }</span>
    } // namespace
    namespace detail {
#define DOCTEST_ITERATE_THROUGH_REPORTERS(function, ...)                                           \
    for(auto&amp; curr_rep : g_cs-&gt;reporters_currently_used)                                           \
    curr_rep-&gt;function(__VA_ARGS__)

<span style = "background-color:#fdd">        bool checkIfShouldThrow(assertType::Enum at) {
            if (at &amp; assertType::is_require) //!OCLINT bitwise operator in conditional
                return true;</span>

            if ((at &amp; assertType::is_check) //!OCLINT bitwise operator in conditional
<span style = "background-color:#fdd">                &amp;&amp; getContextOptions()-&gt;abort_after &gt; 0 &amp;&amp;</span>
                (g_cs-&gt;numAssertsFailed + g_cs-&gt;numAssertsFailedCurrentTest_atomic) &gt;=
                getContextOptions()-&gt;abort_after)
<span style = "background-color:#fdd">                return true;</span>

<span style = "background-color:#fdd">            return false;
        }</span>

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#fdd">        DOCTEST_NORETURN void throwException() {
            g_cs-&gt;shouldLogCurrentException = false;
            throw TestFailureException(); // NOLINT(hicpp-exception-baseclass)
        }</span>
#else // DOCTEST_CONFIG_NO_EXCEPTIONS
        void throwException() {}
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
    } // namespace detail

    namespace {
        using namespace detail;
        // matching of a string against a wildcard mask (case sensitivity configurable) taken from
        // https://www.codeproject.com/Articles/1088/Wildcard-string-compare-globbing
<span style = "background-color:#dfd">        int wildcmp(const char* str, const char* wild, bool caseSensitive) {
            const char* cp = str;
            const char* mp = wild;</span>

<span style = "background-color:#dfd">            while ((*str) &amp;&amp; (*wild != '*')) {
                if ((caseSensitive ? (*wild != *str) : (tolower(*wild) != tolower(*str))) &amp;&amp;</span>
                    (*wild != '?')) {
<span style = "background-color:#dfd">                    return 0;</span>
                }
<span style = "background-color:#dfd">                wild++;
                str++;
            }</span>

<span style = "background-color:#dfd">            while (*str) {</span>
<span style = "background-color:#fdd">                if (*wild == '*') {
                    if (!*++wild) {
                        return 1;</span>
                    }
<span style = "background-color:#fdd">                    mp = wild;
                    cp = str + 1;
                }
                else if ((caseSensitive ? (*wild == *str) : (tolower(*wild) == tolower(*str))) ||</span>
                    (*wild == '?')) {
<span style = "background-color:#fdd">                    wild++;
                    str++;
                }</span>
                else {
<span style = "background-color:#fdd">                    wild = mp;   //!OCLINT parameter reassignment
                    str = cp++; //!OCLINT parameter reassignment</span>
                }
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#dfd">            while (*wild == '*') {</span>
<span style = "background-color:#fdd">                wild++;
            }</span>
<span style = "background-color:#dfd">            return !*wild;
        }</span>

        // checks if the name matches any of the filters (and can be configured what to do when empty)
        bool matchesAny(const char* name, const std::vector&lt;String&gt;&amp; filters, bool matchEmpty,
<span style = "background-color:#dfd">            bool caseSensitive) {
            if (filters.empty() &amp;&amp; matchEmpty)
                return true;
            for (auto&amp; curr : filters)
                if (wildcmp(name, curr.c_str(), caseSensitive))
                    return true;
            return false;
        }</span>

        DOCTEST_NO_SANITIZE_INTEGER
<span style = "background-color:#dfd">            unsigned long long hash(unsigned long long a, unsigned long long b) {
            return (a &lt;&lt; 5) + b;
        }</span>

        // C string hash function (djb2) - taken from http://www.cse.yorku.ca/~oz/hash.html
        DOCTEST_NO_SANITIZE_INTEGER
<span style = "background-color:#dfd">            unsigned long long hash(const char* str) {
            unsigned long long hash = 5381;</span>
            char c;
<span style = "background-color:#dfd">            while ((c = *str++))
                hash = ((hash &lt;&lt; 5) + hash) + c; // hash * 33 + c
            return hash;
        }</span>

<span style = "background-color:#dfd">        unsigned long long hash(const SubcaseSignature&amp; sig) {
            return hash(hash(hash(sig.m_file), hash(sig.m_name.c_str())), sig.m_line);
        }</span>

<span style = "background-color:#dfd">        unsigned long long hash(const std::vector&lt;SubcaseSignature&gt;&amp; sigs, size_t count) {
            unsigned long long running = 0;
            auto end = sigs.begin() + count;
            for (auto it = sigs.begin(); it != end; it++) {</span>
<span style = "background-color:#fdd">                running = hash(running, hash(*it));</span>
<span style = "background-color:#dfd">            }
            return running;
        }</span>

<span style = "background-color:#dfd">        unsigned long long hash(const std::vector&lt;SubcaseSignature&gt;&amp; sigs) {
            unsigned long long running = 0;
            for (const SubcaseSignature&amp; sig : sigs) {
                running = hash(running, hash(sig));
            }
            return running;
        }</span>
    } // namespace
    namespace detail {
<span style = "background-color:#dfd">        bool Subcase::checkFilters() {
            if (g_cs-&gt;subcaseStack.size() &lt; size_t(g_cs-&gt;subcase_filter_levels)) {
                if (!matchesAny(m_signature.m_name.c_str(), g_cs-&gt;filters[6], true, g_cs-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                    return true;</span>
<span style = "background-color:#dfd">                if (matchesAny(m_signature.m_name.c_str(), g_cs-&gt;filters[7], false, g_cs-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                    return true;</span>
            }
<span style = "background-color:#dfd">            return false;
        }</span>

        Subcase::Subcase(const String&amp; name, const char* file, int line)
<span style = "background-color:#dfd">            : m_signature({ name, file, line }) {
            if (!g_cs-&gt;reachedLeaf) {</span>
                if (g_cs-&gt;nextSubcaseStack.size() &lt;= g_cs-&gt;subcaseStack.size()
<span style = "background-color:#dfd">                    || g_cs-&gt;nextSubcaseStack[g_cs-&gt;subcaseStack.size()] == m_signature) {</span>
                    // Going down.
<span style = "background-color:#dfd">                    if (checkFilters()) { return; }</span>

<span style = "background-color:#dfd">                    g_cs-&gt;subcaseStack.push_back(m_signature);
                    g_cs-&gt;currentSubcaseDepth++;
                    m_entered = true;
                    DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);</span>
                }
<span style = "background-color:#dfd">            }</span>
            else {
<span style = "background-color:#dfd">                if (g_cs-&gt;subcaseStack[g_cs-&gt;currentSubcaseDepth] == m_signature) {</span>
                    // This subcase is reentered via control flow.
<span style = "background-color:#fdd">                    g_cs-&gt;currentSubcaseDepth++;
                    m_entered = true;
                    DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);
                }</span>
                else if (g_cs-&gt;nextSubcaseStack.size() &lt;= g_cs-&gt;currentSubcaseDepth
<span style = "background-color:#dfd">                    &amp;&amp; g_cs-&gt;fullyTraversedSubcases.find(hash(hash(g_cs-&gt;subcaseStack, g_cs-&gt;currentSubcaseDepth), hash(m_signature)))</span>
                    == g_cs-&gt;fullyTraversedSubcases.end()) {
<span style = "background-color:#dfd">                    if (checkFilters()) { return; }</span>
                    // This subcase is part of the one to be executed next.
<span style = "background-color:#dfd">                    g_cs-&gt;nextSubcaseStack.clear();
                    g_cs-&gt;nextSubcaseStack.insert(g_cs-&gt;nextSubcaseStack.end(),</span>
                        g_cs-&gt;subcaseStack.begin(), g_cs-&gt;subcaseStack.begin() + g_cs-&gt;currentSubcaseDepth);
<span style = "background-color:#dfd">                    g_cs-&gt;nextSubcaseStack.push_back(m_signature);</span>
                }
            }
<span style = "background-color:#dfd">        }</span>

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
            DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
            DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

<span style = "background-color:#dfd">            Subcase::~Subcase() {
            if (m_entered) {
                g_cs-&gt;currentSubcaseDepth--;</span>

<span style = "background-color:#dfd">                if (!g_cs-&gt;reachedLeaf) {</span>
                    // Leaf.
<span style = "background-color:#dfd">                    g_cs-&gt;fullyTraversedSubcases.insert(hash(g_cs-&gt;subcaseStack));
                    g_cs-&gt;nextSubcaseStack.clear();
                    g_cs-&gt;reachedLeaf = true;
                }</span>
<span style = "background-color:#fdd">                else if (g_cs-&gt;nextSubcaseStack.empty()) {</span>
                    // All children are finished.
<span style = "background-color:#fdd">                    g_cs-&gt;fullyTraversedSubcases.insert(hash(g_cs-&gt;subcaseStack));</span>
                }

#if defined(__cpp_lib_uncaught_exceptions) &amp;&amp; __cpp_lib_uncaught_exceptions &gt;= 201411L &amp;&amp; (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101200)
                if (std::uncaught_exceptions() &gt; 0
#else
                if (std::uncaught_exception()
#endif
<span style = "background-color:#dfd">                    &amp;&amp; g_cs-&gt;shouldLogCurrentException) {</span>
<span style = "background-color:#fdd">                    DOCTEST_ITERATE_THROUGH_REPORTERS(</span>
                        test_case_exception, { "exception thrown in subcase - will translate later "
                                                "when the whole test case has been exited (cannot "
                                                "translate while there is an active exception)",
<span style = "background-color:#fdd">                                                false });
                                                g_cs-&gt;shouldLogCurrentException = false;</span>
                }

<span style = "background-color:#dfd">                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);</span>
            }
<span style = "background-color:#dfd">        }</span>

        DOCTEST_CLANG_SUPPRESS_WARNING_POP
            DOCTEST_GCC_SUPPRESS_WARNING_POP
            DOCTEST_MSVC_SUPPRESS_WARNING_POP

<span style = "background-color:#dfd">            Subcase::operator bool() const { return m_entered; }</span>

        Result::Result(bool passed, const String&amp; decomposition)
<span style = "background-color:#dfd">            : m_passed(passed)
            , m_decomp(decomposition) {}</span>

        ExpressionDecomposer::ExpressionDecomposer(assertType::Enum at)
<span style = "background-color:#dfd">            : m_at(at) {}</span>

<span style = "background-color:#dfd">        TestSuite&amp; TestSuite::operator*(const char* in) {
            m_test_suite = in;
            return *this;
        }</span>

        TestCase::TestCase(funcType test, const char* file, unsigned line, const TestSuite&amp; test_suite,
<span style = "background-color:#dfd">            const String&amp; type, int template_id) {
            m_file = file;
            m_line = line;
            m_name = nullptr; // will be later overridden in operator*
            m_test_suite = test_suite.m_test_suite;
            m_description = test_suite.m_description;
            m_skip = test_suite.m_skip;
            m_no_breaks = test_suite.m_no_breaks;
            m_no_output = test_suite.m_no_output;
            m_may_fail = test_suite.m_may_fail;
            m_should_fail = test_suite.m_should_fail;
            m_expected_failures = test_suite.m_expected_failures;
            m_timeout = test_suite.m_timeout;</span>

<span style = "background-color:#dfd">            m_test = test;
            m_type = type;
            m_template_id = template_id;
        }</span>

        TestCase::TestCase(const TestCase&amp; other)
<span style = "background-color:#dfd">            : TestCaseData() {
            *this = other;
        }</span>

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function
<span style = "background-color:#dfd">            TestCase&amp; TestCase::operator=(const TestCase&amp; other) {
            TestCaseData::operator=(other);
            m_test = other.m_test;
            m_type = other.m_type;
            m_template_id = other.m_template_id;
            m_full_name = other.m_full_name;</span>

<span style = "background-color:#dfd">            if (m_template_id != -1)</span>
<span style = "background-color:#fdd">                m_name = m_full_name.c_str();</span>
<span style = "background-color:#dfd">            return *this;
        }</span>
        DOCTEST_MSVC_SUPPRESS_WARNING_POP

<span style = "background-color:#dfd">            TestCase&amp; TestCase::operator*(const char* in) {
            m_name = in;</span>
            // make a new name with an appended type for templated test case
<span style = "background-color:#dfd">            if (m_template_id != -1) {</span>
<span style = "background-color:#fdd">                m_full_name = String(m_name) + "&lt;" + m_type + "&gt;";</span>
                // redirect the name to point to the newly constructed full name
<span style = "background-color:#fdd">                m_name = m_full_name.c_str();</span>
            }
<span style = "background-color:#dfd">            return *this;
        }</span>

<span style = "background-color:#dfd">        bool TestCase::operator&lt;(const TestCase&amp; other) const {</span>
            // this will be used only to differentiate between test cases - not relevant for sorting
<span style = "background-color:#dfd">            if (m_line != other.m_line)
                return m_line &lt; other.m_line;</span>
<span style = "background-color:#fdd">            const int name_cmp = strcmp(m_name, other.m_name);
            if (name_cmp != 0)
                return name_cmp &lt; 0;
            const int file_cmp = m_file.compare(other.m_file);
            if (file_cmp != 0)
                return file_cmp &lt; 0;
            return m_template_id &lt; other.m_template_id;</span>
<span style = "background-color:#dfd">        }</span>

        // all the registered tests
<span style = "background-color:#dfd">        std::set&lt;TestCase&gt;&amp; getRegisteredTests() {
            static std::set&lt;TestCase&gt; data;
            return data;
        }</span>
    } // namespace detail
    namespace {
        using namespace detail;
        // for sorting tests by file/line
<span style = "background-color:#dfd">        bool fileOrderComparator(const TestCase* lhs, const TestCase* rhs) {</span>
            // this is needed because MSVC gives different case for drive letters
            // for __FILE__ when evaluated in a header and a source file
<span style = "background-color:#dfd">            const int res = lhs-&gt;m_file.compare(rhs-&gt;m_file, bool(DOCTEST_MSVC));
            if (res != 0)
                return res &lt; 0;
            if (lhs-&gt;m_line != rhs-&gt;m_line)
                return lhs-&gt;m_line &lt; rhs-&gt;m_line;</span>
<span style = "background-color:#fdd">            return lhs-&gt;m_template_id &lt; rhs-&gt;m_template_id;</span>
<span style = "background-color:#dfd">        }</span>

        // for sorting tests by suite/file/line
<span style = "background-color:#fdd">        bool suiteOrderComparator(const TestCase* lhs, const TestCase* rhs) {
            const int res = std::strcmp(lhs-&gt;m_test_suite, rhs-&gt;m_test_suite);
            if (res != 0)
                return res &lt; 0;
            return fileOrderComparator(lhs, rhs);
        }</span>

        // for sorting tests by name/suite/file/line
<span style = "background-color:#fdd">        bool nameOrderComparator(const TestCase* lhs, const TestCase* rhs) {
            const int res = std::strcmp(lhs-&gt;m_name, rhs-&gt;m_name);
            if (res != 0)
                return res &lt; 0;
            return suiteOrderComparator(lhs, rhs);
        }</span>

        DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
<span style = "background-color:#dfd">            void color_to_stream(std::ostream&amp; s, Color::Enum code) {</span>
            static_cast&lt;void&gt;(s);    // for DOCTEST_CONFIG_COLORS_NONE or DOCTEST_CONFIG_COLORS_WINDOWS
            static_cast&lt;void&gt;(code); // for DOCTEST_CONFIG_COLORS_NONE
#ifdef DOCTEST_CONFIG_COLORS_ANSI
            if (g_no_colors ||
                (isatty(STDOUT_FILENO) == false &amp;&amp; getContextOptions()-&gt;force_colors == false))
                return;

            auto col = "";
            // clang-format off
            switch (code) { //!OCLINT missing break in switch statement / unnecessary default statement in covered switch statement
            case Color::Red:         col = "[0;31m"; break;
            case Color::Green:       col = "[0;32m"; break;
            case Color::Blue:        col = "[0;34m"; break;
            case Color::Cyan:        col = "[0;36m"; break;
            case Color::Yellow:      col = "[0;33m"; break;
            case Color::Grey:        col = "[1;30m"; break;
            case Color::LightGrey:   col = "[0;37m"; break;
            case Color::BrightRed:   col = "[1;31m"; break;
            case Color::BrightGreen: col = "[1;32m"; break;
            case Color::BrightWhite: col = "[1;37m"; break;
            case Color::Bright: // invalid
            case Color::None:
            case Color::White:
            default:                 col = "[0m";
            }
            // clang-format on
            s &lt;&lt; "\033" &lt;&lt; col;
#endif // DOCTEST_CONFIG_COLORS_ANSI

#ifdef DOCTEST_CONFIG_COLORS_WINDOWS
<span style = "background-color:#dfd">            if (g_no_colors ||</span>
                (_isatty(_fileno(stdout)) == false &amp;&amp; getContextOptions()-&gt;force_colors == false))
<span style = "background-color:#fdd">                return;</span>

            static struct ConsoleHelper {
                HANDLE stdoutHandle;
                WORD   origFgAttrs;
                WORD   origBgAttrs;

<span style = "background-color:#dfd">                ConsoleHelper() {
                    stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);</span>
                    CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
<span style = "background-color:#dfd">                    GetConsoleScreenBufferInfo(stdoutHandle, &amp;csbiInfo);
                    origFgAttrs = csbiInfo.wAttributes &amp; ~(BACKGROUND_GREEN | BACKGROUND_RED |</span>
                        BACKGROUND_BLUE | BACKGROUND_INTENSITY);
<span style = "background-color:#dfd">                    origBgAttrs = csbiInfo.wAttributes &amp; ~(FOREGROUND_GREEN | FOREGROUND_RED |</span>
                        FOREGROUND_BLUE | FOREGROUND_INTENSITY);
<span style = "background-color:#dfd">                }
            } ch;</span>

#define DOCTEST_SET_ATTR(x) SetConsoleTextAttribute(ch.stdoutHandle, x | ch.origBgAttrs)

            // clang-format off
<span style = "background-color:#dfd">            switch (code) {</span>
<span style = "background-color:#fdd">            case Color::White:       DOCTEST_SET_ATTR(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;
            case Color::Red:         DOCTEST_SET_ATTR(FOREGROUND_RED);                                      break;</span>
<span style = "background-color:#dfd">            case Color::Green:       DOCTEST_SET_ATTR(FOREGROUND_GREEN);                                    break;</span>
<span style = "background-color:#fdd">            case Color::Blue:        DOCTEST_SET_ATTR(FOREGROUND_BLUE);                                     break;</span>
<span style = "background-color:#dfd">            case Color::Cyan:        DOCTEST_SET_ATTR(FOREGROUND_BLUE | FOREGROUND_GREEN);                  break;
            case Color::Yellow:      DOCTEST_SET_ATTR(FOREGROUND_RED | FOREGROUND_GREEN);                   break;</span>
<span style = "background-color:#fdd">            case Color::Grey:        DOCTEST_SET_ATTR(0);                                                   break;
            case Color::LightGrey:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY);                                break;
            case Color::BrightRed:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_RED);               break;
            case Color::BrightGreen: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN);             break;
            case Color::BrightWhite: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;</span>
            case Color::None:
            case Color::Bright: // invalid
<span style = "background-color:#dfd">            default:                 DOCTEST_SET_ATTR(ch.origFgAttrs);</span>
            }
            // clang-format on
#endif // DOCTEST_CONFIG_COLORS_WINDOWS
<span style = "background-color:#dfd">        }</span>
        DOCTEST_CLANG_SUPPRESS_WARNING_POP

<span style = "background-color:#dfd">            std::vector&lt;const IExceptionTranslator*&gt;&amp; getExceptionTranslators() {
            static std::vector&lt;const IExceptionTranslator*&gt; data;
            return data;
        }</span>

<span style = "background-color:#dfd">        String translateActiveException() {</span>
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#dfd">            String res;
            auto&amp; translators = getExceptionTranslators();
            for (auto&amp; curr : translators)</span>
<span style = "background-color:#fdd">                if (curr-&gt;translate(res))
                    return res;</span>
            // clang-format off
            DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wcatch-value")
                try {
<span style = "background-color:#dfd">                throw;</span>
            }
<span style = "background-color:#fdd">            catch (std::exception&amp; ex) {
                return ex.what();
            }
            catch (std::string&amp; msg) {
                return msg.c_str();
            }</span>
<span style = "background-color:#dfd">            catch (const char* msg) {
                return msg;</span>
<span style = "background-color:#fdd">            }
            catch (...) {
                return "unknown exception";
            }</span>
            DOCTEST_GCC_SUPPRESS_WARNING_POP
                // clang-format on
#else  // DOCTEST_CONFIG_NO_EXCEPTIONS
            return "";
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#fdd">        }</span>
    } // namespace

    namespace detail {
        // used by the macros for registering tests
<span style = "background-color:#dfd">        int regTest(const TestCase&amp; tc) {
            getRegisteredTests().insert(tc);
            return 0;
        }</span>

        // sets the current test suite
<span style = "background-color:#dfd">        int setTestSuite(const TestSuite&amp; ts) {
            doctest_detail_test_suite_ns::getCurrentTestSuite() = ts;
            return 0;
        }</span>

#ifdef DOCTEST_IS_DEBUGGER_ACTIVE
        bool isDebuggerActive() { return DOCTEST_IS_DEBUGGER_ACTIVE(); }
#else // DOCTEST_IS_DEBUGGER_ACTIVE
#ifdef DOCTEST_PLATFORM_LINUX
        class ErrnoGuard {
        public:
            ErrnoGuard() : m_oldErrno(errno) {}
            ~ErrnoGuard() { errno = m_oldErrno; }
        private:
            int m_oldErrno;
        };
        // See the comments in Catch2 for the reasoning behind this implementation:
        // https://github.com/catchorg/Catch2/blob/v2.13.1/include/internal/catch_debugger.cpp#L79-L102
        bool isDebuggerActive() {
            ErrnoGuard guard;
            std::ifstream in("/proc/self/status");
            for (std::string line; std::getline(in, line);) {
                static const int PREFIX_LEN = 11;
                if (line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0) {
                    return line.length() &gt; PREFIX_LEN &amp;&amp; line[PREFIX_LEN] != '0';
                }
            }
            return false;
        }
#elif defined(DOCTEST_PLATFORM_MAC)
        // The following function is taken directly from the following technical note:
        // https://developer.apple.com/library/archive/qa/qa1361/_index.html
        // Returns true if the current process is being debugged (either
        // running under the debugger or has a debugger attached post facto).
        bool isDebuggerActive() {
            int        mib[4];
            kinfo_proc info;
            size_t     size;
            // Initialize the flags so that, if sysctl fails for some bizarre
            // reason, we get a predictable result.
            info.kp_proc.p_flag = 0;
            // Initialize mib, which tells sysctl the info we want, in this case
            // we're looking for information about a specific process ID.
            mib[0] = CTL_KERN;
            mib[1] = KERN_PROC;
            mib[2] = KERN_PROC_PID;
            mib[3] = getpid();
            // Call sysctl.
            size = sizeof(info);
            if (sysctl(mib, DOCTEST_COUNTOF(mib), &amp;info, &amp;size, 0, 0) != 0) {
                std::cerr &lt;&lt; "\nCall to sysctl failed - unable to determine if debugger is active **\n";
                return false;
            }
            // We're being debugged if the P_TRACED flag is set.
            return ((info.kp_proc.p_flag &amp; P_TRACED) != 0);
        }
#elif DOCTEST_MSVC || defined(__MINGW32__) || defined(__MINGW64__)
<span style = "background-color:#dfd">        bool isDebuggerActive() { return ::IsDebuggerPresent() != 0; }</span>
#else
        bool isDebuggerActive() { return false; }
#endif // Platform
#endif // DOCTEST_IS_DEBUGGER_ACTIVE

<span style = "background-color:#fdd">        void registerExceptionTranslatorImpl(const IExceptionTranslator* et) {
            if (std::find(getExceptionTranslators().begin(), getExceptionTranslators().end(), et) ==</span>
                getExceptionTranslators().end())
<span style = "background-color:#fdd">                getExceptionTranslators().push_back(et);
        }</span>

<span style = "background-color:#dfd">        DOCTEST_THREAD_LOCAL std::vector&lt;IContextScope*&gt; g_infoContexts; // for logging with INFO()</span>

<span style = "background-color:#fdd">        ContextScopeBase::ContextScopeBase() {
            g_infoContexts.push_back(this);
        }</span>

<span style = "background-color:#fdd">        ContextScopeBase::ContextScopeBase(ContextScopeBase&amp;&amp; other) noexcept {
            if (other.need_to_destroy) {
                other.destroy();</span>
            }
<span style = "background-color:#fdd">            other.need_to_destroy = false;
            g_infoContexts.push_back(this);
        }</span>

        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17
            DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")
            DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")

            // destroy cannot be inlined into the destructor because that would mean calling stringify after
            // ContextScope has been destroyed (base class destructors run after derived class destructors).
            // Instead, ContextScope calls this method directly from its destructor.
<span style = "background-color:#fdd">            void ContextScopeBase::destroy() {</span>
#if defined(__cpp_lib_uncaught_exceptions) &amp;&amp; __cpp_lib_uncaught_exceptions &gt;= 201411L &amp;&amp; (!defined(__MAC_OS_X_VERSION_MIN_REQUIRED) || __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101200)
<span style = "background-color:#fdd">            if (std::uncaught_exceptions() &gt; 0) {</span>
#else
            if (std::uncaught_exception()) {
#endif
<span style = "background-color:#fdd">                std::ostringstream s;
                this-&gt;stringify(&amp;s);
                g_cs-&gt;stringifiedContexts.push_back(s.str().c_str());
            }
            g_infoContexts.pop_back();
            }</span>

        DOCTEST_CLANG_SUPPRESS_WARNING_POP
            DOCTEST_GCC_SUPPRESS_WARNING_POP
            DOCTEST_MSVC_SUPPRESS_WARNING_POP
        } // namespace detail
    namespace {
        using namespace detail;

#if !defined(DOCTEST_CONFIG_POSIX_SIGNALS) &amp;&amp; !defined(DOCTEST_CONFIG_WINDOWS_SEH)
        struct FatalConditionHandler
        {
            static void reset() {}
            static void allocateAltStackMem() {}
            static void freeAltStackMem() {}
        };
#else // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

        void reportFatal(const std::string&amp;);

#ifdef DOCTEST_PLATFORM_WINDOWS

        struct SignalDefs
        {
            DWORD id;
            const char* name;
        };
        // There is no 1-1 mapping between signals and windows exceptions.
        // Windows can easily distinguish between SO and SigSegV,
        // but SigInt, SigTerm, etc are handled differently.
        SignalDefs signalDefs[] = {
                {static_cast&lt;DWORD&gt;(EXCEPTION_ILLEGAL_INSTRUCTION),
                 "SIGILL - Illegal instruction signal"},
                {static_cast&lt;DWORD&gt;(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow"},
                {static_cast&lt;DWORD&gt;(EXCEPTION_ACCESS_VIOLATION),
                 "SIGSEGV - Segmentation violation signal"},
                {static_cast&lt;DWORD&gt;(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error"},
        };

        struct FatalConditionHandler
        {
<span style = "background-color:#fdd">            static LONG CALLBACK handleException(PEXCEPTION_POINTERS ExceptionInfo) {</span>
                // Multiple threads may enter this filter/handler at once. We want the error message to be printed on the
                // console just once no matter how many threads have crashed.
<span style = "background-color:#fdd">                DOCTEST_DECLARE_STATIC_MUTEX(mutex)</span>
                    static bool execute = true;
                {
<span style = "background-color:#fdd">                    DOCTEST_LOCK_MUTEX(mutex)
                        if (execute) {
                            bool reported = false;
                            for (size_t i = 0; i &lt; DOCTEST_COUNTOF(signalDefs); ++i) {
                                if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == signalDefs[i].id) {
                                    reportFatal(signalDefs[i].name);
                                    reported = true;
                                    break;</span>
                                }
<span style = "background-color:#fdd">                            }
                            if (reported == false)
                                reportFatal("Unhandled SEH exception caught");
                            if (isDebuggerActive() &amp;&amp; !g_cs-&gt;no_breaks)
                                DOCTEST_BREAK_INTO_DEBUGGER();</span>
                        }
<span style = "background-color:#fdd">                    execute = false;
                }
                std::exit(EXIT_FAILURE);
            }</span>

<span style = "background-color:#dfd">            static void allocateAltStackMem() {}
            static void freeAltStackMem() {}</span>

<span style = "background-color:#dfd">            FatalConditionHandler() {
                isSet = true;</span>
                // 32k seems enough for doctest to handle stack overflow,
                // but the value was found experimentally, so there is no strong guarantee
<span style = "background-color:#dfd">                guaranteeSize = 32 * 1024;</span>
                // Register an unhandled exception filter
<span style = "background-color:#dfd">                previousTop = SetUnhandledExceptionFilter(handleException);</span>
                // Pass in guarantee size to be filled
<span style = "background-color:#dfd">                SetThreadStackGuarantee(&amp;guaranteeSize);</span>

                // On Windows uncaught exceptions from another thread, exceptions from
                // destructors, or calls to std::terminate are not a SEH exception

                // The terminal handler gets called when:
                // - std::terminate is called FROM THE TEST RUNNER THREAD
                // - an exception is thrown from a destructor FROM THE TEST RUNNER THREAD
<span style = "background-color:#dfd">                original_terminate_handler = std::get_terminate();
                std::set_terminate([]() DOCTEST_NOEXCEPT{</span>
<span style = "background-color:#fdd">                    reportFatal("Terminate handler called");
                    if (isDebuggerActive() &amp;&amp; !g_cs-&gt;no_breaks)
                        DOCTEST_BREAK_INTO_DEBUGGER();
                    std::exit(EXIT_FAILURE); // explicitly exit - otherwise the SIGABRT handler may be called as well
                    });</span>

                // SIGABRT is raised when:
                // - std::terminate is called FROM A DIFFERENT THREAD
                // - an exception is thrown from a destructor FROM A DIFFERENT THREAD
                // - an uncaught exception is thrown FROM A DIFFERENT THREAD
<span style = "background-color:#dfd">                prev_sigabrt_handler = std::signal(SIGABRT, [](int signal) DOCTEST_NOEXCEPT{</span>
<span style = "background-color:#fdd">                    if (signal == SIGABRT) {
                        reportFatal("SIGABRT - Abort (abnormal termination) signal");
                        if (isDebuggerActive() &amp;&amp; !g_cs-&gt;no_breaks)
                            DOCTEST_BREAK_INTO_DEBUGGER();
                        std::exit(EXIT_FAILURE);</span>
                    }
<span style = "background-color:#fdd">                    });</span>

                // The following settings are taken from google test, and more
                // specifically from UnitTest::Run() inside of gtest.cc

                // the user does not want to see pop-up dialogs about crashes
<span style = "background-color:#dfd">                prev_error_mode_1 = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |</span>
                    SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
                // This forces the abort message to go to stderr in all circumstances.
<span style = "background-color:#dfd">                prev_error_mode_2 = _set_error_mode(_OUT_TO_STDERR);</span>
                // In the debug version, Visual Studio pops up a separate dialog
                // offering a choice to debug the aborted program - we want to disable that.
<span style = "background-color:#dfd">                prev_abort_behavior = _set_abort_behavior(0x0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);</span>
                // In debug mode, the Windows CRT can crash with an assertion over invalid
                // input (e.g. passing an invalid file descriptor). The default handling
                // for these assertions is to pop up a dialog and wait for user input.
                // Instead ask the CRT to dump such assertions to stderr non-interactively.
<span style = "background-color:#dfd">                prev_report_mode = _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
                prev_report_file = _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
            }</span>

<span style = "background-color:#dfd">            static void reset() {
                if (isSet) {</span>
                    // Unregister handler and restore the old guarantee
<span style = "background-color:#dfd">                    SetUnhandledExceptionFilter(previousTop);
                    SetThreadStackGuarantee(&amp;guaranteeSize);
                    std::set_terminate(original_terminate_handler);
                    std::signal(SIGABRT, prev_sigabrt_handler);
                    SetErrorMode(prev_error_mode_1);
                    _set_error_mode(prev_error_mode_2);
                    _set_abort_behavior(prev_abort_behavior, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
                    static_cast&lt;void&gt;(_CrtSetReportMode(_CRT_ASSERT, prev_report_mode));
                    static_cast&lt;void&gt;(_CrtSetReportFile(_CRT_ASSERT, prev_report_file));
                    isSet = false;</span>
                }
<span style = "background-color:#dfd">            }</span>

<span style = "background-color:#dfd">            ~FatalConditionHandler() { reset(); }</span>

        private:
            static UINT         prev_error_mode_1;
            static int          prev_error_mode_2;
            static unsigned int prev_abort_behavior;
            static int          prev_report_mode;
            static _HFILE       prev_report_file;
            static void (DOCTEST_CDECL* prev_sigabrt_handler)(int);
            static std::terminate_handler original_terminate_handler;
            static bool isSet;
            static ULONG guaranteeSize;
            static LPTOP_LEVEL_EXCEPTION_FILTER previousTop;
        };

        UINT         FatalConditionHandler::prev_error_mode_1;
        int          FatalConditionHandler::prev_error_mode_2;
        unsigned int FatalConditionHandler::prev_abort_behavior;
        int          FatalConditionHandler::prev_report_mode;
        _HFILE       FatalConditionHandler::prev_report_file;
        void (DOCTEST_CDECL* FatalConditionHandler::prev_sigabrt_handler)(int);
        std::terminate_handler FatalConditionHandler::original_terminate_handler;
        bool FatalConditionHandler::isSet = false;
        ULONG FatalConditionHandler::guaranteeSize = 0;
        LPTOP_LEVEL_EXCEPTION_FILTER FatalConditionHandler::previousTop = nullptr;

#else // DOCTEST_PLATFORM_WINDOWS

        struct SignalDefs
        {
            int         id;
            const char* name;
        };
        SignalDefs signalDefs[] = { {SIGINT, "SIGINT - Terminal interrupt signal"},
                                   {SIGILL, "SIGILL - Illegal instruction signal"},
                                   {SIGFPE, "SIGFPE - Floating point error signal"},
                                   {SIGSEGV, "SIGSEGV - Segmentation violation signal"},
                                   {SIGTERM, "SIGTERM - Termination request signal"},
                                   {SIGABRT, "SIGABRT - Abort (abnormal termination) signal"} };

        struct FatalConditionHandler
        {
            static bool             isSet;
            static struct sigaction oldSigActions[DOCTEST_COUNTOF(signalDefs)];
            static stack_t          oldSigStack;
            static size_t           altStackSize;
            static char* altStackMem;

            static void handleSignal(int sig) {
                const char* name = "&lt;unknown signal&gt;";
                for (std::size_t i = 0; i &lt; DOCTEST_COUNTOF(signalDefs); ++i) {
                    SignalDefs&amp; def = signalDefs[i];
                    if (sig == def.id) {
                        name = def.name;
                        break;
                    }
                }
                reset();
                reportFatal(name);
                raise(sig);
            }

            static void allocateAltStackMem() {
                altStackMem = new char[altStackSize];
            }

            static void freeAltStackMem() {
                delete[] altStackMem;
            }

            FatalConditionHandler() {
                isSet = true;
                stack_t sigStack;
                sigStack.ss_sp = altStackMem;
                sigStack.ss_size = altStackSize;
                sigStack.ss_flags = 0;
                sigaltstack(&amp;sigStack, &amp;oldSigStack);
                struct sigaction sa = {};
                sa.sa_handler = handleSignal;
                sa.sa_flags = SA_ONSTACK;
                for (std::size_t i = 0; i &lt; DOCTEST_COUNTOF(signalDefs); ++i) {
                    sigaction(signalDefs[i].id, &amp;sa, &amp;oldSigActions[i]);
                }
            }

            ~FatalConditionHandler() { reset(); }
            static void reset() {
                if (isSet) {
                    // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
                    for (std::size_t i = 0; i &lt; DOCTEST_COUNTOF(signalDefs); ++i) {
                        sigaction(signalDefs[i].id, &amp;oldSigActions[i], nullptr);
                    }
                    // Return the old stack
                    sigaltstack(&amp;oldSigStack, nullptr);
                    isSet = false;
                }
            }
        };

        bool             FatalConditionHandler::isSet = false;
        struct sigaction FatalConditionHandler::oldSigActions[DOCTEST_COUNTOF(signalDefs)] = {};
        stack_t          FatalConditionHandler::oldSigStack = {};
        size_t           FatalConditionHandler::altStackSize = 4 * SIGSTKSZ;
        char* FatalConditionHandler::altStackMem = nullptr;

#endif // DOCTEST_PLATFORM_WINDOWS
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH

    } // namespace

    namespace {
        using namespace detail;

#ifdef DOCTEST_PLATFORM_WINDOWS
#define DOCTEST_OUTPUT_DEBUG_STRING(text) ::OutputDebugStringA(text)
#else
        // TODO: integration with XCode and other IDEs
#define DOCTEST_OUTPUT_DEBUG_STRING(text)
#endif // Platform

<span style = "background-color:#dfd">        void addAssert(assertType::Enum at) {
            if ((at &amp; assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
                g_cs-&gt;numAssertsCurrentTest_atomic++;
        }</span>

<span style = "background-color:#fdd">        void addFailedAssert(assertType::Enum at) {
            if ((at &amp; assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional
                g_cs-&gt;numAssertsFailedCurrentTest_atomic++;
        }</span>

#if defined(DOCTEST_CONFIG_POSIX_SIGNALS) || defined(DOCTEST_CONFIG_WINDOWS_SEH)
<span style = "background-color:#fdd">        void reportFatal(const std::string&amp; message) {
            g_cs-&gt;failure_flags |= TestCaseFailureReason::Crash;</span>

<span style = "background-color:#fdd">            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception, { message.c_str(), true });</span>

<span style = "background-color:#fdd">            while (g_cs-&gt;subcaseStack.size()) {
                g_cs-&gt;subcaseStack.pop_back();
                DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);
            }</span>

<span style = "background-color:#fdd">            g_cs-&gt;finalizeTestCaseData();</span>

<span style = "background-color:#fdd">            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);</span>

<span style = "background-color:#fdd">            DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
        }</span>
#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH
    } // namespace

    AssertData::AssertData(assertType::Enum at, const char* file, int line, const char* expr,
        const char* exception_type, const StringContains&amp; exception_string)
<span style = "background-color:#dfd">        : m_test_case(g_cs-&gt;currentTest), m_at(at), m_file(file), m_line(line), m_expr(expr),
        m_failed(true), m_threw(false), m_threw_as(false), m_exception_type(exception_type),
        m_exception_string(exception_string) {</span>
#if DOCTEST_MSVC
<span style = "background-color:#dfd">        if (m_expr[0] == ' ') // this happens when variadic macros are disabled under MSVC</span>
<span style = "background-color:#fdd">            ++m_expr;</span>
#endif // MSVC
<span style = "background-color:#dfd">    }</span>

    namespace detail {
        ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
            const char* exception_type, const String&amp; exception_string)
<span style = "background-color:#dfd">            : AssertData(at, file, line, expr, exception_type, exception_string) { }</span>

        ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,
            const char* exception_type, const Contains&amp; exception_string)
<span style = "background-color:#fdd">            : AssertData(at, file, line, expr, exception_type, exception_string) { }</span>

<span style = "background-color:#dfd">        void ResultBuilder::setResult(const Result&amp; res) {
            m_decomp = res.m_decomp;
            m_failed = !res.m_passed;
        }</span>

<span style = "background-color:#dfd">        void ResultBuilder::translateException() {
            m_threw = true;
            m_exception = translateActiveException();
        }</span>

<span style = "background-color:#dfd">        bool ResultBuilder::log() {
            if (m_at &amp; assertType::is_throws) { //!OCLINT bitwise operator in conditional
                m_failed = !m_threw;
            }
            else if ((m_at &amp; assertType::is_throws_as) &amp;&amp; (m_at &amp; assertType::is_throws_with)) { //!OCLINT</span>
<span style = "background-color:#fdd">                m_failed = !m_threw_as || !m_exception_string.check(m_exception);
            }</span>
<span style = "background-color:#dfd">            else if (m_at &amp; assertType::is_throws_as) { //!OCLINT bitwise operator in conditional</span>
<span style = "background-color:#fdd">                m_failed = !m_threw_as;
            }</span>
<span style = "background-color:#dfd">            else if (m_at &amp; assertType::is_throws_with) { //!OCLINT bitwise operator in conditional</span>
<span style = "background-color:#fdd">                m_failed = !m_exception_string.check(m_exception);
            }</span>
<span style = "background-color:#dfd">            else if (m_at &amp; assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
                m_failed = m_threw;</span>
            }

<span style = "background-color:#dfd">            if (m_exception.size())
                m_exception = "\"" + m_exception + "\"";</span>

<span style = "background-color:#dfd">            if (is_running_in_test) {
                addAssert(m_at);
                DOCTEST_ITERATE_THROUGH_REPORTERS(log_assert, *this);</span>

<span style = "background-color:#dfd">                if (m_failed)</span>
<span style = "background-color:#fdd">                    addFailedAssert(m_at);</span>
<span style = "background-color:#dfd">            }</span>
<span style = "background-color:#fdd">            else if (m_failed) {
                failed_out_of_a_testing_context(*this);</span>
            }

<span style = "background-color:#dfd">            return m_failed &amp;&amp; isDebuggerActive() &amp;&amp; !getContextOptions()-&gt;no_breaks &amp;&amp;</span>
                (g_cs-&gt;currentTest == nullptr || !g_cs-&gt;currentTest-&gt;m_no_breaks); // break into debugger
<span style = "background-color:#dfd">        }</span>

<span style = "background-color:#dfd">        void ResultBuilder::react() const {
            if (m_failed &amp;&amp; checkIfShouldThrow(m_at))</span>
<span style = "background-color:#fdd">                throwException();</span>
<span style = "background-color:#dfd">        }</span>

<span style = "background-color:#fdd">        void failed_out_of_a_testing_context(const AssertData&amp; ad) {
            if (g_cs-&gt;ah)
                g_cs-&gt;ah(ad);</span>
            else
<span style = "background-color:#fdd">                std::abort();
        }</span>

        bool decomp_assert(assertType::Enum at, const char* file, int line, const char* expr,
<span style = "background-color:#fdd">            const Result&amp; result) {
            bool failed = !result.m_passed;</span>

            // ###################################################################################
            // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT
            // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED
            // ###################################################################################
<span style = "background-color:#fdd">            DOCTEST_ASSERT_OUT_OF_TESTS(result.m_decomp);
            DOCTEST_ASSERT_IN_TESTS(result.m_decomp);
            return !failed;
        }</span>

<span style = "background-color:#fdd">        MessageBuilder::MessageBuilder(const char* file, int line, assertType::Enum severity) {
            m_stream = tlssPush();
            m_file = file;
            m_line = line;
            m_severity = severity;
        }</span>

<span style = "background-color:#fdd">        MessageBuilder::~MessageBuilder() {
            if (!logged)
                tlssPop();
        }</span>

<span style = "background-color:#fdd">        DOCTEST_DEFINE_INTERFACE(IExceptionTranslator)</span>

<span style = "background-color:#fdd">            bool MessageBuilder::log() {
            if (!logged) {
                m_string = tlssPop();
                logged = true;</span>
            }

<span style = "background-color:#fdd">            DOCTEST_ITERATE_THROUGH_REPORTERS(log_message, *this);</span>

<span style = "background-color:#fdd">            const bool isWarn = m_severity &amp; assertType::is_warn;</span>

            // warn is just a message in this context so we don't treat it as an assert
<span style = "background-color:#fdd">            if (!isWarn) {
                addAssert(m_severity);
                addFailedAssert(m_severity);</span>
            }

<span style = "background-color:#fdd">            return isDebuggerActive() &amp;&amp; !getContextOptions()-&gt;no_breaks &amp;&amp; !isWarn &amp;&amp;</span>
                (g_cs-&gt;currentTest == nullptr || !g_cs-&gt;currentTest-&gt;m_no_breaks); // break into debugger
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        void MessageBuilder::react() {
            if (m_severity &amp; assertType::is_require) //!OCLINT bitwise operator in conditional
                throwException();
        }</span>
    } // namespace detail
    namespace {
        using namespace detail;

        // clang-format off

    // =================================================================================================
    // The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
    // This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
    // =================================================================================================

        class XmlEncode {
        public:
            enum ForWhat { ForTextNodes, ForAttributes };

            XmlEncode(std::string const&amp; str, ForWhat forWhat = ForTextNodes);

            void encodeTo(std::ostream&amp; os) const;

            friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, XmlEncode const&amp; xmlEncode);

        private:
            std::string m_str;
            ForWhat m_forWhat;
        };

        class XmlWriter {
        public:

            class ScopedElement {
            public:
                ScopedElement(XmlWriter* writer);

                ScopedElement(ScopedElement&amp;&amp; other) DOCTEST_NOEXCEPT;
                ScopedElement&amp; operator=(ScopedElement&amp;&amp; other) DOCTEST_NOEXCEPT;

                ~ScopedElement();

                ScopedElement&amp; writeText(std::string const&amp; text, bool indent = true);

                template&lt;typename T&gt;
<span style = "background-color:#fdd">                ScopedElement&amp; writeAttribute(std::string const&amp; name, T const&amp; attribute) {
                    m_writer-&gt;writeAttribute(name, attribute);
                    return *this;
                }</span>

            private:
                mutable XmlWriter* m_writer = nullptr;
            };

#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            XmlWriter(std::ostream&amp; os = std::cout);
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            XmlWriter(std::ostream&amp; os);
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            ~XmlWriter();

            XmlWriter(XmlWriter const&amp;) = delete;
            XmlWriter&amp; operator=(XmlWriter const&amp;) = delete;

            XmlWriter&amp; startElement(std::string const&amp; name);

            ScopedElement scopedElement(std::string const&amp; name);

            XmlWriter&amp; endElement();

            XmlWriter&amp; writeAttribute(std::string const&amp; name, std::string const&amp; attribute);

            XmlWriter&amp; writeAttribute(std::string const&amp; name, const char* attribute);

            XmlWriter&amp; writeAttribute(std::string const&amp; name, bool attribute);

            template&lt;typename T&gt;
<span style = "background-color:#fdd">            XmlWriter&amp; writeAttribute(std::string const&amp; name, T const&amp; attribute) {
                std::stringstream rss;
                rss &lt;&lt; attribute;
                return writeAttribute(name, rss.str());
            }</span>

            XmlWriter&amp; writeText(std::string const&amp; text, bool indent = true);

            //XmlWriter&amp; writeComment( std::string const&amp; text );

            //void writeStylesheetRef( std::string const&amp; url );

            //XmlWriter&amp; writeBlankLine();

            void ensureTagClosed();

            void writeDeclaration();

        private:

            void newlineIfNecessary();

<span style = "background-color:#fdd">            bool m_tagIsOpen = false;
            bool m_needsNewline = false;</span>
            std::vector&lt;std::string&gt; m_tags;
            std::string m_indent;
            std::ostream&amp; m_os;
        };

        // =================================================================================================
        // The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp
        // This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.
        // =================================================================================================

        using uchar = unsigned char;

        namespace {

<span style = "background-color:#fdd">            size_t trailingBytes(unsigned char c) {
                if ((c &amp; 0xE0) == 0xC0) {
                    return 2;</span>
                }
<span style = "background-color:#fdd">                if ((c &amp; 0xF0) == 0xE0) {
                    return 3;</span>
                }
<span style = "background-color:#fdd">                if ((c &amp; 0xF8) == 0xF0) {
                    return 4;</span>
                }
<span style = "background-color:#fdd">                DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
            }</span>

<span style = "background-color:#fdd">            uint32_t headerValue(unsigned char c) {
                if ((c &amp; 0xE0) == 0xC0) {
                    return c &amp; 0x1F;</span>
                }
<span style = "background-color:#fdd">                if ((c &amp; 0xF0) == 0xE0) {
                    return c &amp; 0x0F;</span>
                }
<span style = "background-color:#fdd">                if ((c &amp; 0xF8) == 0xF0) {
                    return c &amp; 0x07;</span>
                }
<span style = "background-color:#fdd">                DOCTEST_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
            }</span>

<span style = "background-color:#fdd">            void hexEscapeChar(std::ostream&amp; os, unsigned char c) {
                std::ios_base::fmtflags f(os.flags());
                os &lt;&lt; "\\x"</span>
                    &lt;&lt; std::uppercase &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2)
                    &lt;&lt; static_cast&lt;int&gt;(c);
<span style = "background-color:#fdd">                os.flags(f);
            }</span>

        } // anonymous namespace

        XmlEncode::XmlEncode(std::string const&amp; str, ForWhat forWhat)
<span style = "background-color:#fdd">            : m_str(str),
            m_forWhat(forWhat)
        {}</span>

<span style = "background-color:#fdd">        void XmlEncode::encodeTo(std::ostream&amp; os) const {</span>
            // Apostrophe escaping not necessary if we always use " to write attributes
            // (see: https://www.w3.org/TR/xml/#syntax)

<span style = "background-color:#fdd">            for (std::size_t idx = 0; idx &lt; m_str.size(); ++idx) {
                uchar c = m_str[idx];
                switch (c) {
                case '&lt;':   os &lt;&lt; "&amp;lt;"; break;
                case '&amp;':   os &lt;&lt; "&amp;amp;"; break;</span>

                case '&gt;':
                    // See: https://www.w3.org/TR/xml/#syntax
<span style = "background-color:#fdd">                    if (idx &gt; 2 &amp;&amp; m_str[idx - 1] == ']' &amp;&amp; m_str[idx - 2] == ']')
                        os &lt;&lt; "&amp;gt;";</span>
                    else
<span style = "background-color:#fdd">                        os &lt;&lt; c;
                    break;</span>

                case '\"':
<span style = "background-color:#fdd">                    if (m_forWhat == ForAttributes)
                        os &lt;&lt; "&amp;quot;";</span>
                    else
<span style = "background-color:#fdd">                        os &lt;&lt; c;
                    break;</span>

                default:
                    // Check for control characters and invalid utf-8

                    // Escape control characters in standard ascii
                    // see https://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
<span style = "background-color:#fdd">                    if (c &lt; 0x09 || (c &gt; 0x0D &amp;&amp; c &lt; 0x20) || c == 0x7F) {
                        hexEscapeChar(os, c);
                        break;</span>
                    }

                    // Plain ASCII: Write it to stream
<span style = "background-color:#fdd">                    if (c &lt; 0x7F) {
                        os &lt;&lt; c;
                        break;</span>
                    }

                    // UTF-8 territory
                    // Check if the encoding is valid and if it is not, hex escape bytes.
                    // Important: We do not check the exact decoded values for validity, only the encoding format
                    // First check that this bytes is a valid lead byte:
                    // This means that it is not encoded as 1111 1XXX
                    // Or as 10XX XXXX
<span style = "background-color:#fdd">                    if (c &lt; 0xC0 ||</span>
                        c &gt;= 0xF8) {
<span style = "background-color:#fdd">                        hexEscapeChar(os, c);
                        break;</span>
                    }

<span style = "background-color:#fdd">                    auto encBytes = trailingBytes(c);</span>
                    // Are there enough bytes left to avoid accessing out-of-bounds memory?
<span style = "background-color:#fdd">                    if (idx + encBytes - 1 &gt;= m_str.size()) {
                        hexEscapeChar(os, c);
                        break;</span>
                    }
                    // The header is valid, check data
                    // The next encBytes bytes must together be a valid utf-8
                    // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
<span style = "background-color:#fdd">                    bool valid = true;
                    uint32_t value = headerValue(c);
                    for (std::size_t n = 1; n &lt; encBytes; ++n) {
                        uchar nc = m_str[idx + n];
                        valid &amp;= ((nc &amp; 0xC0) == 0x80);
                        value = (value &lt;&lt; 6) | (nc &amp; 0x3F);
                    }</span>

                    if (
                        // Wrong bit pattern of following bytes
                        (!valid) ||
                        // Overlong encodings
                        (value &lt; 0x80) ||
                        (value &lt; 0x800 &amp;&amp; encBytes &gt; 2) || // removed "0x80 &lt;= value &amp;&amp;" because redundant
<span style = "background-color:#fdd">                        (0x800 &lt; value &amp;&amp; value &lt; 0x10000 &amp;&amp; encBytes &gt; 3) ||</span>
                        // Encoded value out of range
                        (value &gt;= 0x110000)
                        ) {
<span style = "background-color:#fdd">                        hexEscapeChar(os, c);
                        break;</span>
                    }

                    // If we got here, this is in fact a valid(ish) utf-8 sequence
<span style = "background-color:#fdd">                    for (std::size_t n = 0; n &lt; encBytes; ++n) {
                        os &lt;&lt; m_str[idx + n];
                    }
                    idx += encBytes - 1;</span>
                    break;
                }
<span style = "background-color:#fdd">            }
        }</span>

<span style = "background-color:#fdd">        std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, XmlEncode const&amp; xmlEncode) {
            xmlEncode.encodeTo(os);
            return os;
        }</span>

        XmlWriter::ScopedElement::ScopedElement(XmlWriter* writer)
<span style = "background-color:#fdd">            : m_writer(writer)
        {}</span>

        XmlWriter::ScopedElement::ScopedElement(ScopedElement&amp;&amp; other) DOCTEST_NOEXCEPT
            : m_writer(other.m_writer) {
            other.m_writer = nullptr;
        }
        XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::operator=(ScopedElement&amp;&amp; other) DOCTEST_NOEXCEPT {
            if (m_writer) {
                m_writer-&gt;endElement();
            }
            m_writer = other.m_writer;
            other.m_writer = nullptr;
            return *this;
        }


<span style = "background-color:#fdd">        XmlWriter::ScopedElement::~ScopedElement() {
            if (m_writer)
                m_writer-&gt;endElement();
        }</span>

<span style = "background-color:#fdd">        XmlWriter::ScopedElement&amp; XmlWriter::ScopedElement::writeText(std::string const&amp; text, bool indent) {
            m_writer-&gt;writeText(text, indent);
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter::XmlWriter(std::ostream&amp; os) : m_os(os)
        {</span>
            // writeDeclaration(); // called explicitly by the reporters that use the writer class - see issue #627
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        XmlWriter::~XmlWriter() {
            while (!m_tags.empty())
                endElement();
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::startElement(std::string const&amp; name) {
            ensureTagClosed();
            newlineIfNecessary();
            m_os &lt;&lt; m_indent &lt;&lt; '&lt;' &lt;&lt; name;
            m_tags.push_back(name);
            m_indent += "  ";
            m_tagIsOpen = true;
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter::ScopedElement XmlWriter::scopedElement(std::string const&amp; name) {
            ScopedElement scoped(this);
            startElement(name);
            return scoped;
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::endElement() {
            newlineIfNecessary();
            m_indent = m_indent.substr(0, m_indent.size() - 2);
            if (m_tagIsOpen) {
                m_os &lt;&lt; "/&gt;";
                m_tagIsOpen = false;
            }</span>
            else {
<span style = "background-color:#fdd">                m_os &lt;&lt; m_indent &lt;&lt; "&lt;/" &lt;&lt; m_tags.back() &lt;&lt; "&gt;";</span>
            }
<span style = "background-color:#fdd">            m_os &lt;&lt; std::endl;
            m_tags.pop_back();
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::writeAttribute(std::string const&amp; name, std::string const&amp; attribute) {
            if (!name.empty() &amp;&amp; !attribute.empty())
                m_os &lt;&lt; ' ' &lt;&lt; name &lt;&lt; "=\"" &lt;&lt; XmlEncode(attribute, XmlEncode::ForAttributes) &lt;&lt; '"';
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::writeAttribute(std::string const&amp; name, const char* attribute) {
            if (!name.empty() &amp;&amp; attribute &amp;&amp; attribute[0] != '\0')
                m_os &lt;&lt; ' ' &lt;&lt; name &lt;&lt; "=\"" &lt;&lt; XmlEncode(attribute, XmlEncode::ForAttributes) &lt;&lt; '"';
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::writeAttribute(std::string const&amp; name, bool attribute) {
            m_os &lt;&lt; ' ' &lt;&lt; name &lt;&lt; "=\"" &lt;&lt; (attribute ? "true" : "false") &lt;&lt; '"';
            return *this;
        }</span>

<span style = "background-color:#fdd">        XmlWriter&amp; XmlWriter::writeText(std::string const&amp; text, bool indent) {
            if (!text.empty()) {
                bool tagWasOpen = m_tagIsOpen;
                ensureTagClosed();
                if (tagWasOpen &amp;&amp; indent)
                    m_os &lt;&lt; m_indent;
                m_os &lt;&lt; XmlEncode(text);
                m_needsNewline = true;</span>
            }
<span style = "background-color:#fdd">            return *this;
        }</span>

        //XmlWriter&amp; XmlWriter::writeComment( std::string const&amp; text ) {
        //    ensureTagClosed();
        //    m_os &lt;&lt; m_indent &lt;&lt; "&lt;!--" &lt;&lt; text &lt;&lt; "--&gt;";
        //    m_needsNewline = true;
        //    return *this;
        //}

        //void XmlWriter::writeStylesheetRef( std::string const&amp; url ) {
        //    m_os &lt;&lt; "&lt;?xml-stylesheet type=\"text/xsl\" href=\"" &lt;&lt; url &lt;&lt; "\"?&gt;\n";
        //}

        //XmlWriter&amp; XmlWriter::writeBlankLine() {
        //    ensureTagClosed();
        //    m_os &lt;&lt; '\n';
        //    return *this;
        //}

<span style = "background-color:#fdd">        void XmlWriter::ensureTagClosed() {
            if (m_tagIsOpen) {
                m_os &lt;&lt; "&gt;" &lt;&lt; std::endl;
                m_tagIsOpen = false;</span>
            }
<span style = "background-color:#fdd">        }</span>

<span style = "background-color:#fdd">        void XmlWriter::writeDeclaration() {
            m_os &lt;&lt; "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n";
        }</span>

<span style = "background-color:#fdd">        void XmlWriter::newlineIfNecessary() {
            if (m_needsNewline) {
                m_os &lt;&lt; std::endl;
                m_needsNewline = false;</span>
            }
<span style = "background-color:#fdd">        }</span>

        // =================================================================================================
        // End of copy-pasted code from Catch
        // =================================================================================================

            // clang-format on

        struct XmlReporter : public IReporter
        {
            XmlWriter xml;
            DOCTEST_DECLARE_MUTEX(mutex)

                // caching pointers/references to objects of these types - safe to do
                const ContextOptions&amp; opt;
<span style = "background-color:#fdd">            const TestCaseData* tc = nullptr;</span>

            XmlReporter(const ContextOptions&amp; co)
<span style = "background-color:#fdd">                : xml(*co.cout)
                , opt(co) {}</span>

<span style = "background-color:#fdd">            void log_contexts() {
                int num_contexts = get_num_active_contexts();
                if (num_contexts) {
                    auto              contexts = get_active_contexts();
                    std::stringstream ss;
                    for (int i = 0; i &lt; num_contexts; ++i) {
                        contexts[i]-&gt;stringify(&amp;ss);
                        xml.scopedElement("Info").writeText(ss.str());
                        ss.str("");
                    }
                }
            }</span>

<span style = "background-color:#fdd">            unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }</span>

<span style = "background-color:#fdd">            void test_case_start_impl(const TestCaseData&amp; in) {
                bool open_ts_tag = false;
                if (tc != nullptr) { // we have already opened a test suite
                    if (std::strcmp(tc-&gt;m_test_suite, in.m_test_suite) != 0) {
                        xml.endElement();
                        open_ts_tag = true;</span>
                    }
<span style = "background-color:#fdd">                }</span>
                else {
<span style = "background-color:#fdd">                    open_ts_tag = true; // first test case ==&gt; first test suite</span>
                }

<span style = "background-color:#fdd">                if (open_ts_tag) {
                    xml.startElement("TestSuite");
                    xml.writeAttribute("name", in.m_test_suite);</span>
                }

<span style = "background-color:#fdd">                tc = &amp;in;
                xml.startElement("TestCase")</span>
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file.c_str()))
                    .writeAttribute("line", line(in.m_line))
                    .writeAttribute("description", in.m_description);

<span style = "background-color:#fdd">                if (Approx(in.m_timeout) != 0)
                    xml.writeAttribute("timeout", in.m_timeout);
                if (in.m_may_fail)
                    xml.writeAttribute("may_fail", true);
                if (in.m_should_fail)
                    xml.writeAttribute("should_fail", true);
            }</span>

            // =========================================================================================
            // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
            // =========================================================================================

<span style = "background-color:#fdd">            void report_query(const QueryData&amp; in) override {
                test_run_start();
                if (opt.list_reporters) {
                    for (auto&amp; curr : getListeners())
                        xml.scopedElement("Listener")</span>
                        .writeAttribute("priority", curr.first.first)
<span style = "background-color:#fdd">                        .writeAttribute("name", curr.first.second);
                    for (auto&amp; curr : getReporters())
                        xml.scopedElement("Reporter")</span>
                        .writeAttribute("priority", curr.first.first)
<span style = "background-color:#fdd">                        .writeAttribute("name", curr.first.second);
                }
                else if (opt.count || opt.list_test_cases) {
                    for (unsigned i = 0; i &lt; in.num_data; ++i) {
                        xml.scopedElement("TestCase").writeAttribute("name", in.data[i]-&gt;m_name)</span>
                            .writeAttribute("testsuite", in.data[i]-&gt;m_test_suite)
                            .writeAttribute("filename", skipPathFromFilename(in.data[i]-&gt;m_file.c_str()))
                            .writeAttribute("line", line(in.data[i]-&gt;m_line))
                            .writeAttribute("skipped", in.data[i]-&gt;m_skip);
<span style = "background-color:#fdd">                    }
                    xml.scopedElement("OverallResultsTestCases")</span>
                        .writeAttribute("unskipped", in.run_stats-&gt;numTestCasesPassingFilters);
<span style = "background-color:#fdd">                }
                else if (opt.list_test_suites) {
                    for (unsigned i = 0; i &lt; in.num_data; ++i)
                        xml.scopedElement("TestSuite").writeAttribute("name", in.data[i]-&gt;m_test_suite);
                    xml.scopedElement("OverallResultsTestCases")</span>
                        .writeAttribute("unskipped", in.run_stats-&gt;numTestCasesPassingFilters);
<span style = "background-color:#fdd">                    xml.scopedElement("OverallResultsTestSuites")</span>
                        .writeAttribute("unskipped", in.run_stats-&gt;numTestSuitesPassingFilters);
                }
<span style = "background-color:#fdd">                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void test_run_start() override {
                xml.writeDeclaration();</span>

                // remove .exe extension - mainly to have the same output on UNIX and Windows
<span style = "background-color:#fdd">                std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());</span>
#ifdef DOCTEST_PLATFORM_WINDOWS
<span style = "background-color:#fdd">                if (binary_name.rfind(".exe") != std::string::npos)
                    binary_name = binary_name.substr(0, binary_name.length() - 4);</span>
#endif // DOCTEST_PLATFORM_WINDOWS

<span style = "background-color:#fdd">                xml.startElement("doctest").writeAttribute("binary", binary_name);
                if (opt.no_version == false)
                    xml.writeAttribute("version", DOCTEST_VERSION_STR);</span>

                // only the consequential ones (TODO: filters)
<span style = "background-color:#fdd">                xml.scopedElement("Options")</span>
                    .writeAttribute("order_by", opt.order_by.c_str())
                    .writeAttribute("rand_seed", opt.rand_seed)
                    .writeAttribute("first", opt.first)
                    .writeAttribute("last", opt.last)
                    .writeAttribute("abort_after", opt.abort_after)
                    .writeAttribute("subcase_filter_levels", opt.subcase_filter_levels)
                    .writeAttribute("case_sensitive", opt.case_sensitive)
                    .writeAttribute("no_throw", opt.no_throw)
                    .writeAttribute("no_skip", opt.no_skip);
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            void test_run_end(const TestRunStats&amp; p) override {
                if (tc) // the TestSuite tag - only if there has been at least 1 test case
                    xml.endElement();</span>

<span style = "background-color:#fdd">                xml.scopedElement("OverallResultsAsserts")</span>
                    .writeAttribute("successes", p.numAsserts - p.numAssertsFailed)
                    .writeAttribute("failures", p.numAssertsFailed);

<span style = "background-color:#fdd">                xml.startElement("OverallResultsTestCases")</span>
                    .writeAttribute("successes",
                        p.numTestCasesPassingFilters - p.numTestCasesFailed)
                    .writeAttribute("failures", p.numTestCasesFailed);
<span style = "background-color:#fdd">                if (opt.no_skipped_summary == false)
                    xml.writeAttribute("skipped", p.numTestCases - p.numTestCasesPassingFilters);
                xml.endElement();</span>

<span style = "background-color:#fdd">                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void test_case_start(const TestCaseData&amp; in) override {
                test_case_start_impl(in);
                xml.ensureTagClosed();
            }</span>

<span style = "background-color:#fdd">            void test_case_reenter(const TestCaseData&amp;) override {}</span>

<span style = "background-color:#fdd">            void test_case_end(const CurrentTestCaseStats&amp; st) override {
                xml.startElement("OverallResultsAsserts")</span>
                    .writeAttribute("successes",
                        st.numAssertsCurrentTest - st.numAssertsFailedCurrentTest)
                    .writeAttribute("failures", st.numAssertsFailedCurrentTest)
                    .writeAttribute("test_case_success", st.testCaseSuccess);
<span style = "background-color:#fdd">                if (opt.duration)
                    xml.writeAttribute("duration", st.seconds);
                if (tc-&gt;m_expected_failures)
                    xml.writeAttribute("expected_failures", tc-&gt;m_expected_failures);
                xml.endElement();</span>

<span style = "background-color:#fdd">                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void test_case_exception(const TestCaseException&amp; e) override {
                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    xml.scopedElement("Exception")</span>
                    .writeAttribute("crash", e.is_crash)
                    .writeText(e.error_string.c_str());
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            void subcase_start(const SubcaseSignature&amp; in) override {
                xml.startElement("SubCase")</span>
                    .writeAttribute("name", in.m_name)
                    .writeAttribute("filename", skipPathFromFilename(in.m_file))
                    .writeAttribute("line", line(in.m_line));
<span style = "background-color:#fdd">                xml.ensureTagClosed();
            }</span>

<span style = "background-color:#fdd">            void subcase_end() override { xml.endElement(); }</span>

<span style = "background-color:#fdd">            void log_assert(const AssertData&amp; rb) override {
                if (!rb.m_failed &amp;&amp; !opt.success)
                    return;</span>

<span style = "background-color:#fdd">                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    xml.startElement("Expression")</span>
                    .writeAttribute("success", !rb.m_failed)
                    .writeAttribute("type", assertString(rb.m_at))
                    .writeAttribute("filename", skipPathFromFilename(rb.m_file))
                    .writeAttribute("line", line(rb.m_line));

<span style = "background-color:#fdd">                xml.scopedElement("Original").writeText(rb.m_expr);</span>

<span style = "background-color:#fdd">                if (rb.m_threw)
                    xml.scopedElement("Exception").writeText(rb.m_exception.c_str());</span>

<span style = "background-color:#fdd">                if (rb.m_at &amp; assertType::is_throws_as)
                    xml.scopedElement("ExpectedException").writeText(rb.m_exception_type);
                if (rb.m_at &amp; assertType::is_throws_with)
                    xml.scopedElement("ExpectedExceptionString").writeText(rb.m_exception_string.c_str());
                if ((rb.m_at &amp; assertType::is_normal) &amp;&amp; !rb.m_threw)
                    xml.scopedElement("Expanded").writeText(rb.m_decomp.c_str());</span>

<span style = "background-color:#fdd">                log_contexts();</span>

<span style = "background-color:#fdd">                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void log_message(const MessageData&amp; mb) override {
                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    xml.startElement("Message")</span>
                    .writeAttribute("type", failureString(mb.m_severity))
                    .writeAttribute("filename", skipPathFromFilename(mb.m_file))
                    .writeAttribute("line", line(mb.m_line));

<span style = "background-color:#fdd">                xml.scopedElement("Text").writeText(mb.m_string.c_str());</span>

<span style = "background-color:#fdd">                log_contexts();</span>

<span style = "background-color:#fdd">                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void test_case_skipped(const TestCaseData&amp; in) override {
                if (opt.no_skipped_summary == false) {
                    test_case_start_impl(in);
                    xml.writeAttribute("skipped", "true");
                    xml.endElement();</span>
                }
<span style = "background-color:#fdd">            }</span>
        };

<span style = "background-color:#dfd">        DOCTEST_REGISTER_REPORTER("xml", 0, XmlReporter);</span>

<span style = "background-color:#fdd">        void fulltext_log_assert_to_stream(std::ostream&amp; s, const AssertData&amp; rb) {
            if ((rb.m_at &amp; (assertType::is_throws_as | assertType::is_throws_with)) ==</span>
                0) //!OCLINT bitwise operator in conditional
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; assertString(rb.m_at) &lt;&lt; "( " &lt;&lt; rb.m_expr &lt;&lt; " ) "</span>
                &lt;&lt; Color::None;

<span style = "background-color:#fdd">            if (rb.m_at &amp; assertType::is_throws) { //!OCLINT bitwise operator in conditional
                s &lt;&lt; (rb.m_threw ? "threw as expected!" : "did NOT throw at all!") &lt;&lt; "\n";
            }
            else if ((rb.m_at &amp; assertType::is_throws_as) &amp;&amp;</span>
                (rb.m_at &amp; assertType::is_throws_with)) { //!OCLINT
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; assertString(rb.m_at) &lt;&lt; "( " &lt;&lt; rb.m_expr &lt;&lt; ", \""</span>
                    &lt;&lt; rb.m_exception_string.c_str()
                    &lt;&lt; "\", " &lt;&lt; rb.m_exception_type &lt;&lt; " ) " &lt;&lt; Color::None;
<span style = "background-color:#fdd">                if (rb.m_threw) {
                    if (!rb.m_failed) {
                        s &lt;&lt; "threw as expected!\n";
                    }</span>
                    else {
<span style = "background-color:#fdd">                        s &lt;&lt; "threw a DIFFERENT exception! (contents: " &lt;&lt; rb.m_exception &lt;&lt; ")\n";</span>
                    }
<span style = "background-color:#fdd">                }</span>
                else {
<span style = "background-color:#fdd">                    s &lt;&lt; "did NOT throw at all!\n";</span>
                }
<span style = "background-color:#fdd">            }
            else if (rb.m_at &amp;</span>
                assertType::is_throws_as) { //!OCLINT bitwise operator in conditional
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; assertString(rb.m_at) &lt;&lt; "( " &lt;&lt; rb.m_expr &lt;&lt; ", "</span>
                    &lt;&lt; rb.m_exception_type &lt;&lt; " ) " &lt;&lt; Color::None
                    &lt;&lt; (rb.m_threw ? (rb.m_threw_as ? "threw as expected!" :
                        "threw a DIFFERENT exception: ") :
                        "did NOT throw at all!")
                    &lt;&lt; Color::Cyan &lt;&lt; rb.m_exception &lt;&lt; "\n";
<span style = "background-color:#fdd">            }
            else if (rb.m_at &amp;</span>
                assertType::is_throws_with) { //!OCLINT bitwise operator in conditional
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; assertString(rb.m_at) &lt;&lt; "( " &lt;&lt; rb.m_expr &lt;&lt; ", \""</span>
                    &lt;&lt; rb.m_exception_string.c_str()
                    &lt;&lt; "\" ) " &lt;&lt; Color::None
                    &lt;&lt; (rb.m_threw ? (!rb.m_failed ? "threw as expected!" :
                        "threw a DIFFERENT exception: ") :
                        "did NOT throw at all!")
                    &lt;&lt; Color::Cyan &lt;&lt; rb.m_exception &lt;&lt; "\n";
<span style = "background-color:#fdd">            }
            else if (rb.m_at &amp; assertType::is_nothrow) { //!OCLINT bitwise operator in conditional
                s &lt;&lt; (rb.m_threw ? "THREW exception: " : "didn't throw!") &lt;&lt; Color::Cyan</span>
                    &lt;&lt; rb.m_exception &lt;&lt; "\n";
<span style = "background-color:#fdd">            }</span>
            else {
<span style = "background-color:#fdd">                s &lt;&lt; (rb.m_threw ? "THREW exception: " :</span>
                    (!rb.m_failed ? "is correct!\n" : "is NOT correct!\n"));
<span style = "background-color:#fdd">                if (rb.m_threw)
                    s &lt;&lt; rb.m_exception &lt;&lt; "\n";</span>
                else
<span style = "background-color:#fdd">                    s &lt;&lt; "  values: " &lt;&lt; assertString(rb.m_at) &lt;&lt; "( " &lt;&lt; rb.m_decomp &lt;&lt; " )\n";</span>
            }
<span style = "background-color:#fdd">        }</span>

        // TODO:
        // - log_message()
        // - respond to queries
        // - honor remaining options
        // - more attributes in tags
        struct JUnitReporter : public IReporter
        {
            XmlWriter xml;
            DOCTEST_DECLARE_MUTEX(mutex)
                Timer timer;
            std::vector&lt;String&gt; deepestSubcaseStackNames;

            struct JUnitTestCaseData
            {
<span style = "background-color:#fdd">                static std::string getCurrentTimestamp() {</span>
                    // Beware, this is not reentrant because of backward compatibility issues
                    // Also, UTC only, again because of backward compatibility (%z is C++11)
                    time_t rawtime;
<span style = "background-color:#fdd">                    std::time(&amp;rawtime);
                    auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");</span>

                    std::tm timeInfo;
#ifdef DOCTEST_PLATFORM_WINDOWS
<span style = "background-color:#fdd">                    gmtime_s(&amp;timeInfo, &amp;rawtime);</span>
#else // DOCTEST_PLATFORM_WINDOWS
                    gmtime_r(&amp;rawtime, &amp;timeInfo);
#endif // DOCTEST_PLATFORM_WINDOWS

                    char timeStamp[timeStampSize];
<span style = "background-color:#fdd">                    const char* const fmt = "%Y-%m-%dT%H:%M:%SZ";</span>

<span style = "background-color:#fdd">                    std::strftime(timeStamp, timeStampSize, fmt, &amp;timeInfo);
                    return std::string(timeStamp);
                }</span>

                struct JUnitTestMessage
                {
<span style = "background-color:#fdd">                    JUnitTestMessage(const std::string&amp; _message, const std::string&amp; _type, const std::string&amp; _details)
                        : message(_message), type(_type), details(_details) {}</span>

<span style = "background-color:#fdd">                    JUnitTestMessage(const std::string&amp; _message, const std::string&amp; _details)
                        : message(_message), type(), details(_details) {}</span>

                    std::string message, type, details;
                };

                struct JUnitTestCase
                {
<span style = "background-color:#fdd">                    JUnitTestCase(const std::string&amp; _classname, const std::string&amp; _name)
                        : classname(_classname), name(_name), time(0), failures() {}</span>

                    std::string classname, name;
                    double time;
                    std::vector&lt;JUnitTestMessage&gt; failures, errors;
                };

<span style = "background-color:#fdd">                void add(const std::string&amp; classname, const std::string&amp; name) {
                    testcases.emplace_back(classname, name);
                }</span>

<span style = "background-color:#fdd">                void appendSubcaseNamesToLastTestcase(std::vector&lt;String&gt; nameStack) {
                    for (auto&amp; curr : nameStack)
                        if (curr.size())
                            testcases.back().name += std::string("/") + curr.c_str();
                }</span>

<span style = "background-color:#fdd">                void addTime(double time) {
                    if (time &lt; 1e-4)
                        time = 0;
                    testcases.back().time = time;
                    totalSeconds += time;
                }</span>

<span style = "background-color:#fdd">                void addFailure(const std::string&amp; message, const std::string&amp; type, const std::string&amp; details) {
                    testcases.back().failures.emplace_back(message, type, details);
                    ++totalFailures;
                }</span>

<span style = "background-color:#fdd">                void addError(const std::string&amp; message, const std::string&amp; details) {
                    testcases.back().errors.emplace_back(message, details);
                    ++totalErrors;
                }</span>

                std::vector&lt;JUnitTestCase&gt; testcases;
                double totalSeconds = 0;
                int totalErrors = 0, totalFailures = 0;
            };

            JUnitTestCaseData testCaseData;

            // caching pointers/references to objects of these types - safe to do
            const ContextOptions&amp; opt;
<span style = "background-color:#fdd">            const TestCaseData* tc = nullptr;</span>

            JUnitReporter(const ContextOptions&amp; co)
<span style = "background-color:#fdd">                : xml(*co.cout)
                , opt(co) {}</span>

<span style = "background-color:#fdd">            unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }</span>

            // =========================================================================================
            // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
            // =========================================================================================

<span style = "background-color:#fdd">            void report_query(const QueryData&amp;) override {
                xml.writeDeclaration();
            }</span>

<span style = "background-color:#fdd">            void test_run_start() override {
                xml.writeDeclaration();
            }</span>

<span style = "background-color:#fdd">            void test_run_end(const TestRunStats&amp; p) override {</span>
                // remove .exe extension - mainly to have the same output on UNIX and Windows
<span style = "background-color:#fdd">                std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());</span>
#ifdef DOCTEST_PLATFORM_WINDOWS
<span style = "background-color:#fdd">                if (binary_name.rfind(".exe") != std::string::npos)
                    binary_name = binary_name.substr(0, binary_name.length() - 4);</span>
#endif // DOCTEST_PLATFORM_WINDOWS
<span style = "background-color:#fdd">                xml.startElement("testsuites");
                xml.startElement("testsuite").writeAttribute("name", binary_name)</span>
                    .writeAttribute("errors", testCaseData.totalErrors)
                    .writeAttribute("failures", testCaseData.totalFailures)
                    .writeAttribute("tests", p.numAsserts);
<span style = "background-color:#fdd">                if (opt.no_time_in_output == false) {
                    xml.writeAttribute("time", testCaseData.totalSeconds);
                    xml.writeAttribute("timestamp", JUnitTestCaseData::getCurrentTimestamp());</span>
                }
<span style = "background-color:#fdd">                if (opt.no_version == false)
                    xml.writeAttribute("doctest_version", DOCTEST_VERSION_STR);</span>

<span style = "background-color:#fdd">                for (const auto&amp; testCase : testCaseData.testcases) {
                    xml.startElement("testcase")</span>
                        .writeAttribute("classname", testCase.classname)
                        .writeAttribute("name", testCase.name);
<span style = "background-color:#fdd">                    if (opt.no_time_in_output == false)
                        xml.writeAttribute("time", testCase.time);</span>
                    // This is not ideal, but it should be enough to mimic gtest's junit output.
<span style = "background-color:#fdd">                    xml.writeAttribute("status", "run");</span>

<span style = "background-color:#fdd">                    for (const auto&amp; failure : testCase.failures) {
                        xml.scopedElement("failure")</span>
                            .writeAttribute("message", failure.message)
                            .writeAttribute("type", failure.type)
                            .writeText(failure.details, false);
<span style = "background-color:#fdd">                    }</span>

<span style = "background-color:#fdd">                    for (const auto&amp; error : testCase.errors) {
                        xml.scopedElement("error")</span>
                            .writeAttribute("message", error.message)
                            .writeText(error.details);
<span style = "background-color:#fdd">                    }</span>

<span style = "background-color:#fdd">                    xml.endElement();
                }
                xml.endElement();
                xml.endElement();
            }</span>

<span style = "background-color:#fdd">            void test_case_start(const TestCaseData&amp; in) override {
                testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
                timer.start();
            }</span>

<span style = "background-color:#fdd">            void test_case_reenter(const TestCaseData&amp; in) override {
                testCaseData.addTime(timer.getElapsedSeconds());
                testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
                deepestSubcaseStackNames.clear();</span>

<span style = "background-color:#fdd">                timer.start();
                testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);
            }</span>

<span style = "background-color:#fdd">            void test_case_end(const CurrentTestCaseStats&amp;) override {
                testCaseData.addTime(timer.getElapsedSeconds());
                testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);
                deepestSubcaseStackNames.clear();
            }</span>

<span style = "background-color:#fdd">            void test_case_exception(const TestCaseException&amp; e) override {
                DOCTEST_LOCK_MUTEX(mutex)
                    testCaseData.addError("exception", e.error_string.c_str());
            }</span>

<span style = "background-color:#fdd">            void subcase_start(const SubcaseSignature&amp; in) override {
                deepestSubcaseStackNames.push_back(in.m_name);
            }</span>

<span style = "background-color:#fdd">            void subcase_end() override {}</span>

<span style = "background-color:#fdd">            void log_assert(const AssertData&amp; rb) override {
                if (!rb.m_failed) // report only failures &amp; ignore the `success` option
                    return;</span>

<span style = "background-color:#fdd">                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    std::ostringstream os;
                os &lt;&lt; skipPathFromFilename(rb.m_file) &lt;&lt; (opt.gnu_file_line ? ":" : "(")</span>
                    &lt;&lt; line(rb.m_line) &lt;&lt; (opt.gnu_file_line ? ":" : "):") &lt;&lt; std::endl;

<span style = "background-color:#fdd">                fulltext_log_assert_to_stream(os, rb);
                log_contexts(os);
                testCaseData.addFailure(rb.m_decomp.c_str(), assertString(rb.m_at), os.str());
            }</span>

<span style = "background-color:#fdd">            void log_message(const MessageData&amp; mb) override {
                if (mb.m_severity &amp; assertType::is_warn) // report only failures
                    return;</span>

<span style = "background-color:#fdd">                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    std::ostringstream os;
                os &lt;&lt; skipPathFromFilename(mb.m_file) &lt;&lt; (opt.gnu_file_line ? ":" : "(")</span>
                    &lt;&lt; line(mb.m_line) &lt;&lt; (opt.gnu_file_line ? ":" : "):") &lt;&lt; std::endl;

<span style = "background-color:#fdd">                os &lt;&lt; mb.m_string.c_str() &lt;&lt; "\n";
                log_contexts(os);</span>

<span style = "background-color:#fdd">                testCaseData.addFailure(mb.m_string.c_str(),</span>
                    mb.m_severity &amp; assertType::is_check ? "FAIL_CHECK" : "FAIL", os.str());
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            void test_case_skipped(const TestCaseData&amp;) override {}</span>

<span style = "background-color:#fdd">            void log_contexts(std::ostringstream&amp; s) {
                int num_contexts = get_num_active_contexts();
                if (num_contexts) {
                    auto contexts = get_active_contexts();</span>

<span style = "background-color:#fdd">                    s &lt;&lt; "  logged: ";
                    for (int i = 0; i &lt; num_contexts; ++i) {
                        s &lt;&lt; (i == 0 ? "" : "          ");
                        contexts[i]-&gt;stringify(&amp;s);
                        s &lt;&lt; std::endl;
                    }</span>
                }
<span style = "background-color:#fdd">            }</span>
        };

<span style = "background-color:#dfd">        DOCTEST_REGISTER_REPORTER("junit", 0, JUnitReporter);</span>

        struct Whitespace
        {
            int nrSpaces;
<span style = "background-color:#fdd">            explicit Whitespace(int nr)
                : nrSpaces(nr) {}</span>
        };

<span style = "background-color:#fdd">        std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Whitespace&amp; ws) {
            if (ws.nrSpaces != 0)
                out &lt;&lt; std::setw(ws.nrSpaces) &lt;&lt; ' ';
            return out;
        }</span>

        struct ConsoleReporter : public IReporter
        {
            std::ostream&amp; s;
            bool                          hasLoggedCurrentTestStart;
            std::vector&lt;SubcaseSignature&gt; subcasesStack;
            size_t                        currentSubcaseLevel;
            DOCTEST_DECLARE_MUTEX(mutex)

                // caching pointers/references to objects of these types - safe to do
                const ContextOptions&amp; opt;
            const TestCaseData* tc;

            ConsoleReporter(const ContextOptions&amp; co)
<span style = "background-color:#dfd">                : s(*co.cout)
                , opt(co) {}</span>

            ConsoleReporter(const ContextOptions&amp; co, std::ostream&amp; ostr)
<span style = "background-color:#dfd">                : s(ostr)
                , opt(co) {}</span>

            // =========================================================================================
            // WHAT FOLLOWS ARE HELPERS USED BY THE OVERRIDES OF THE VIRTUAL METHODS OF THE INTERFACE
            // =========================================================================================

<span style = "background-color:#dfd">            void separator_to_stream() {
                s &lt;&lt; Color::Yellow</span>
                    &lt;&lt; "==============================================================================="
                    "\n";
<span style = "background-color:#dfd">            }</span>

            const char* getSuccessOrFailString(bool success, assertType::Enum at,
<span style = "background-color:#fdd">                const char* success_str) {
                if (success)
                    return success_str;
                return failureString(at);
            }</span>

<span style = "background-color:#fdd">            Color::Enum getSuccessOrFailColor(bool success, assertType::Enum at) {
                return success ? Color::BrightGreen :</span>
                    (at &amp; assertType::is_warn) ? Color::Yellow : Color::Red;
<span style = "background-color:#fdd">            }</span>

            void successOrFailColoredStringToStream(bool success, assertType::Enum at,
<span style = "background-color:#fdd">                const char* success_str = "SUCCESS") {
                s &lt;&lt; getSuccessOrFailColor(success, at)</span>
                    &lt;&lt; getSuccessOrFailString(success, at, success_str) &lt;&lt; ": ";
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            void log_contexts() {
                int num_contexts = get_num_active_contexts();
                if (num_contexts) {
                    auto contexts = get_active_contexts();</span>

<span style = "background-color:#fdd">                    s &lt;&lt; Color::None &lt;&lt; "  logged: ";
                    for (int i = 0; i &lt; num_contexts; ++i) {
                        s &lt;&lt; (i == 0 ? "" : "          ");
                        contexts[i]-&gt;stringify(&amp;s);
                        s &lt;&lt; "\n";
                    }</span>
                }

<span style = "background-color:#fdd">                s &lt;&lt; "\n";
            }</span>

            // this was requested to be made virtual so users could override it
            virtual void file_line_to_stream(const char* file, int line,
<span style = "background-color:#fdd">                const char* tail = "") {
                s &lt;&lt; Color::LightGrey &lt;&lt; skipPathFromFilename(file) &lt;&lt; (opt.gnu_file_line ? ":" : "(")</span>
                    &lt;&lt; (opt.no_line_numbers ? 0 : line) // 0 or the real num depending on the option
                    &lt;&lt; (opt.gnu_file_line ? ":" : "):") &lt;&lt; tail;
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#fdd">            void logTestStart() {
                if (hasLoggedCurrentTestStart)
                    return;</span>

<span style = "background-color:#fdd">                separator_to_stream();
                file_line_to_stream(tc-&gt;m_file.c_str(), tc-&gt;m_line, "\n");
                if (tc-&gt;m_description)
                    s &lt;&lt; Color::Yellow &lt;&lt; "DESCRIPTION: " &lt;&lt; Color::None &lt;&lt; tc-&gt;m_description &lt;&lt; "\n";
                if (tc-&gt;m_test_suite &amp;&amp; tc-&gt;m_test_suite[0] != '\0')
                    s &lt;&lt; Color::Yellow &lt;&lt; "TEST SUITE: " &lt;&lt; Color::None &lt;&lt; tc-&gt;m_test_suite &lt;&lt; "\n";
                if (strncmp(tc-&gt;m_name, "  Scenario:", 11) != 0)
                    s &lt;&lt; Color::Yellow &lt;&lt; "TEST CASE:  ";
                s &lt;&lt; Color::None &lt;&lt; tc-&gt;m_name &lt;&lt; "\n";</span>

<span style = "background-color:#fdd">                for (size_t i = 0; i &lt; currentSubcaseLevel; ++i) {
                    if (subcasesStack[i].m_name[0] != '\0')
                        s &lt;&lt; "  " &lt;&lt; subcasesStack[i].m_name &lt;&lt; "\n";
                }</span>

<span style = "background-color:#fdd">                if (currentSubcaseLevel != subcasesStack.size()) {
                    s &lt;&lt; Color::Yellow &lt;&lt; "\nDEEPEST SUBCASE STACK REACHED (DIFFERENT FROM THE CURRENT ONE):\n" &lt;&lt; Color::None;
                    for (size_t i = 0; i &lt; subcasesStack.size(); ++i) {
                        if (subcasesStack[i].m_name[0] != '\0')
                            s &lt;&lt; "  " &lt;&lt; subcasesStack[i].m_name &lt;&lt; "\n";
                    }</span>
                }

<span style = "background-color:#fdd">                s &lt;&lt; "\n";</span>

<span style = "background-color:#fdd">                hasLoggedCurrentTestStart = true;
            }</span>

<span style = "background-color:#dfd">            void printVersion() {
                if (opt.no_version == false)
                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None &lt;&lt; "doctest version is \""</span>
                    &lt;&lt; DOCTEST_VERSION_STR &lt;&lt; "\"\n";
<span style = "background-color:#dfd">            }</span>

<span style = "background-color:#dfd">            void printIntro() {
                if (opt.no_intro == false) {
                    printVersion();
                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                        &lt;&lt; "run with \"--" DOCTEST_OPTIONS_PREFIX_DISPLAY "help\" for options\n";
                }
<span style = "background-color:#dfd">            }</span>

<span style = "background-color:#fdd">            void printHelp() {
                int sizePrefixDisplay = static_cast&lt;int&gt;(strlen(DOCTEST_OPTIONS_PREFIX_DISPLAY));
                printVersion();</span>
                // clang-format off
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest]\n" &lt;&lt; Color::None;
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "boolean values: \"1/on/yes/true\" or \"0/off/no/false\"\n";
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "filter  values: \"str1,str2,str3\" (comma separated strings)\n";
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest]\n" &lt;&lt; Color::None;
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "filters use wildcards for matching strings\n";
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "something passes a filter if any of the strings in a filter matches\n";</span>
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest]\n" &lt;&lt; Color::None;
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A \"" DOCTEST_CONFIG_OPTIONS_PREFIX "\" PREFIX!!!\n";</span>
#endif
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest]\n" &lt;&lt; Color::None;
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "Query flags - the program quits after them. Available:\n\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "?,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "help, -" DOCTEST_OPTIONS_PREFIX_DISPLAY "h                      "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 0) &lt;&lt; "prints this message\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "v,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "version                       "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "prints the version\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "c,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "count                         "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "prints the number of matching tests\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ltc, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-cases               "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "lists all matching tests by name\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lts, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-test-suites              "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "lists all matching test suites\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "lr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "list-reporters                "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "lists all registered reporters\n\n";
                // ================================================================================== &lt;&lt; 79
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "The available &lt;int&gt;/&lt;string&gt; options/filters are:\n\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case=&lt;filters&gt;           "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters     tests by their name\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-case-exclude=&lt;filters&gt;   "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters OUT tests by their name\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sf,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file=&lt;filters&gt;         "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters     tests by their file\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sfe, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "source-file-exclude=&lt;filters&gt; "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters OUT tests by their file\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ts,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite=&lt;filters&gt;          "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters     tests by their test suite\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "tse, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "test-suite-exclude=&lt;filters&gt;  "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters OUT tests by their test suite\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase=&lt;filters&gt;             "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters     subcases by their name\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "sce, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-exclude=&lt;filters&gt;     "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters OUT subcases by their name\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "r,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "reporters=&lt;filters&gt;           "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "reporters to use (console is default)\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "o,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "out=&lt;string&gt;                  "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "output filename\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ob,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "order-by=&lt;string&gt;             "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "how the tests should be ordered\n";
<span style = "background-color:#fdd">                s &lt;&lt; Whitespace(sizePrefixDisplay * 3) &lt;&lt; "                                       &lt;string&gt; - [file/suite/name/rand/none]\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "rs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "rand-seed=&lt;int&gt;               "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "seed for random ordering\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "f,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "first=&lt;int&gt;                   "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "the first test passing the filters to\n";
<span style = "background-color:#fdd">                s &lt;&lt; Whitespace(sizePrefixDisplay * 3) &lt;&lt; "                                       execute - for range-based execution\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "l,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "last=&lt;int&gt;                    "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "the last test passing the filters to\n";
<span style = "background-color:#fdd">                s &lt;&lt; Whitespace(sizePrefixDisplay * 3) &lt;&lt; "                                       execute - for range-based execution\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "aa,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "abort-after=&lt;int&gt;             "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "stop after &lt;int&gt; failed assertions\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "scfl,--" DOCTEST_OPTIONS_PREFIX_DISPLAY "subcase-filter-levels=&lt;int&gt;   "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "apply filters for the first &lt;int&gt; levels\n";
<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "\n[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "Bool options - can be used like flags and true is assumed. Available:\n\n";
                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "s,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "success=&lt;bool&gt;                "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "include successful assertions in output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "cs,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "case-sensitive=&lt;bool&gt;         "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "filters being treated as case sensitive\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "e,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "exit=&lt;bool&gt;                   "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "exits after the tests finish\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "d,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "duration=&lt;bool&gt;               "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "prints the time duration of each test\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "m,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "minimal=&lt;bool&gt;                "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "minimal console output (only failures)\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "q,   --" DOCTEST_OPTIONS_PREFIX_DISPLAY "quiet=&lt;bool&gt;                  "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "no console output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nt,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-throw=&lt;bool&gt;               "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "skips exceptions-related assert checks\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ne,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-exitcode=&lt;bool&gt;            "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "returns (or exits) always with success\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nr,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-run=&lt;bool&gt;                 "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "skips all runtime doctest operations\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ni,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-intro=&lt;bool&gt;               "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "omit the framework intro in the output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nv,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-version=&lt;bool&gt;             "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "omit the framework version in the output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-colors=&lt;bool&gt;              "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "disables colors in output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "fc,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "force-colors=&lt;bool&gt;           "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "use colors even when not in a tty\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nb,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-breaks=&lt;bool&gt;              "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "disables breakpoints in debuggers\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "ns,  --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-skip=&lt;bool&gt;                "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "don't skip test cases marked as skip\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "gfl, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "gnu-file-line=&lt;bool&gt;          "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; ":n: vs (n): for line numbers in output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "npf, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-path-filenames=&lt;bool&gt;      "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "only filenames and no paths in output\n";
<span style = "background-color:#fdd">                s &lt;&lt; " -" DOCTEST_OPTIONS_PREFIX_DISPLAY "nln, --" DOCTEST_OPTIONS_PREFIX_DISPLAY "no-line-numbers=&lt;bool&gt;        "</span>
                    &lt;&lt; Whitespace(sizePrefixDisplay * 1) &lt;&lt; "0 instead of real line numbers in output\n";
                // ================================================================================== &lt;&lt; 79
                // clang-format on

<span style = "background-color:#fdd">                s &lt;&lt; Color::Cyan &lt;&lt; "\n[doctest] " &lt;&lt; Color::None;
                s &lt;&lt; "for more information visit the project documentation\n\n";
            }</span>

<span style = "background-color:#fdd">            void printRegisteredReporters() {
                printVersion();
                auto printReporters = [this](const reporterMap&amp; reporters, const char* type) {
                    if (reporters.size()) {
                        s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None &lt;&lt; "listing all registered " &lt;&lt; type &lt;&lt; "\n";
                        for (auto&amp; curr : reporters)
                            s &lt;&lt; "priority: " &lt;&lt; std::setw(5) &lt;&lt; curr.first.first</span>
                            &lt;&lt; " name: " &lt;&lt; curr.first.second &lt;&lt; "\n";
                    }
<span style = "background-color:#fdd">                    };
                printReporters(getListeners(), "listeners");
                printReporters(getReporters(), "reporters");
            }</span>

            // =========================================================================================
            // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE
            // =========================================================================================

<span style = "background-color:#fdd">            void report_query(const QueryData&amp; in) override {
                if (opt.version) {
                    printVersion();
                }
                else if (opt.help) {
                    printHelp();
                }
                else if (opt.list_reporters) {
                    printRegisteredReporters();
                }
                else if (opt.count || opt.list_test_cases) {
                    if (opt.list_test_cases) {
                        s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                            &lt;&lt; "listing all test case names\n";
<span style = "background-color:#fdd">                        separator_to_stream();</span>
                    }

<span style = "background-color:#fdd">                    for (unsigned i = 0; i &lt; in.num_data; ++i)
                        s &lt;&lt; Color::None &lt;&lt; in.data[i]-&gt;m_name &lt;&lt; "\n";</span>

<span style = "background-color:#fdd">                    separator_to_stream();</span>

<span style = "background-color:#fdd">                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                        &lt;&lt; "unskipped test cases passing the current filters: "
                        &lt;&lt; g_cs-&gt;numTestCasesPassingFilters &lt;&lt; "\n";

<span style = "background-color:#fdd">                }
                else if (opt.list_test_suites) {
                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None &lt;&lt; "listing all test suites\n";
                    separator_to_stream();</span>

<span style = "background-color:#fdd">                    for (unsigned i = 0; i &lt; in.num_data; ++i)
                        s &lt;&lt; Color::None &lt;&lt; in.data[i]-&gt;m_test_suite &lt;&lt; "\n";</span>

<span style = "background-color:#fdd">                    separator_to_stream();</span>

<span style = "background-color:#fdd">                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                        &lt;&lt; "unskipped test cases passing the current filters: "
                        &lt;&lt; g_cs-&gt;numTestCasesPassingFilters &lt;&lt; "\n";
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                        &lt;&lt; "test suites with unskipped test cases passing the current filters: "
                        &lt;&lt; g_cs-&gt;numTestSuitesPassingFilters &lt;&lt; "\n";
                }
<span style = "background-color:#fdd">            }</span>

<span style = "background-color:#dfd">            void test_run_start() override {
                if (!opt.minimal)
                    printIntro();
            }</span>

<span style = "background-color:#dfd">            void test_run_end(const TestRunStats&amp; p) override {
                if (opt.minimal &amp;&amp; p.numTestCasesFailed == 0)</span>
<span style = "background-color:#fdd">                    return;</span>

<span style = "background-color:#dfd">                separator_to_stream();
                s &lt;&lt; std::dec;</span>

<span style = "background-color:#dfd">                auto totwidth = int(std::ceil(log10(static_cast&lt;double&gt;(std::max(p.numTestCasesPassingFilters, static_cast&lt;unsigned&gt;(p.numAsserts))) + 1)));
                auto passwidth = int(std::ceil(log10(static_cast&lt;double&gt;(std::max(p.numTestCasesPassingFilters - p.numTestCasesFailed, static_cast&lt;unsigned&gt;(p.numAsserts - p.numAssertsFailed))) + 1)));
                auto failwidth = int(std::ceil(log10(static_cast&lt;double&gt;(std::max(p.numTestCasesFailed, static_cast&lt;unsigned&gt;(p.numAssertsFailed))) + 1)));
                const bool anythingFailed = p.numTestCasesFailed &gt; 0 || p.numAssertsFailed &gt; 0;
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None &lt;&lt; "test cases: " &lt;&lt; std::setw(totwidth)</span>
                    &lt;&lt; p.numTestCasesPassingFilters &lt;&lt; " | "
                    &lt;&lt; ((p.numTestCasesPassingFilters == 0 || anythingFailed) ? Color::None :
                        Color::Green)
                    &lt;&lt; std::setw(passwidth) &lt;&lt; p.numTestCasesPassingFilters - p.numTestCasesFailed &lt;&lt; " passed"
                    &lt;&lt; Color::None &lt;&lt; " | " &lt;&lt; (p.numTestCasesFailed &gt; 0 ? Color::Red : Color::None)
                    &lt;&lt; std::setw(failwidth) &lt;&lt; p.numTestCasesFailed &lt;&lt; " failed" &lt;&lt; Color::None &lt;&lt; " |";
<span style = "background-color:#dfd">                if (opt.no_skipped_summary == false) {
                    const int numSkipped = p.numTestCases - p.numTestCasesPassingFilters;
                    s &lt;&lt; " " &lt;&lt; (numSkipped == 0 ? Color::None : Color::Yellow) &lt;&lt; numSkipped</span>
                        &lt;&lt; " skipped" &lt;&lt; Color::None;
                }
<span style = "background-color:#dfd">                s &lt;&lt; "\n";
                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None &lt;&lt; "assertions: " &lt;&lt; std::setw(totwidth)</span>
                    &lt;&lt; p.numAsserts &lt;&lt; " | "
                    &lt;&lt; ((p.numAsserts == 0 || anythingFailed) ? Color::None : Color::Green)
                    &lt;&lt; std::setw(passwidth) &lt;&lt; (p.numAsserts - p.numAssertsFailed) &lt;&lt; " passed" &lt;&lt; Color::None
                    &lt;&lt; " | " &lt;&lt; (p.numAssertsFailed &gt; 0 ? Color::Red : Color::None) &lt;&lt; std::setw(failwidth)
                    &lt;&lt; p.numAssertsFailed &lt;&lt; " failed" &lt;&lt; Color::None &lt;&lt; " |\n";
<span style = "background-color:#dfd">                s &lt;&lt; Color::Cyan &lt;&lt; "[doctest] " &lt;&lt; Color::None</span>
                    &lt;&lt; "Status: " &lt;&lt; (p.numTestCasesFailed &gt; 0 ? Color::Red : Color::Green)
                    &lt;&lt; ((p.numTestCasesFailed &gt; 0) ? "FAILURE!" : "SUCCESS!") &lt;&lt; Color::None &lt;&lt; std::endl;
<span style = "background-color:#dfd">            }</span>

<span style = "background-color:#dfd">            void test_case_start(const TestCaseData&amp; in) override {
                hasLoggedCurrentTestStart = false;
                tc = &amp;in;
                subcasesStack.clear();
                currentSubcaseLevel = 0;
            }</span>

<span style = "background-color:#dfd">            void test_case_reenter(const TestCaseData&amp;) override {
                subcasesStack.clear();
            }</span>

<span style = "background-color:#dfd">            void test_case_end(const CurrentTestCaseStats&amp; st) override {
                if (tc-&gt;m_no_output)</span>
<span style = "background-color:#fdd">                    return;</span>

                // log the preamble of the test case only if there is something
                // else to print - something other than that an assert has failed
<span style = "background-color:#dfd">                if (opt.duration ||</span>
                    (st.failure_flags &amp;&amp; st.failure_flags != static_cast&lt;int&gt;(TestCaseFailureReason::AssertFailure)))
<span style = "background-color:#fdd">                    logTestStart();</span>

<span style = "background-color:#dfd">                if (opt.duration)</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::None &lt;&lt; std::setprecision(6) &lt;&lt; std::fixed &lt;&lt; st.seconds</span>
                    &lt;&lt; " s: " &lt;&lt; tc-&gt;m_name &lt;&lt; "\n";

<span style = "background-color:#dfd">                if (st.failure_flags &amp; TestCaseFailureReason::Timeout)</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Red &lt;&lt; "Test case exceeded time limit of " &lt;&lt; std::setprecision(6)</span>
                    &lt;&lt; std::fixed &lt;&lt; tc-&gt;m_timeout &lt;&lt; "!\n";

<span style = "background-color:#dfd">                if (st.failure_flags &amp; TestCaseFailureReason::ShouldHaveFailedButDidnt) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Red &lt;&lt; "Should have failed but didn't! Marking it as failed!\n";
                }</span>
<span style = "background-color:#dfd">                else if (st.failure_flags &amp; TestCaseFailureReason::ShouldHaveFailedAndDid) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Yellow &lt;&lt; "Failed as expected so marking it as not failed\n";
                }</span>
<span style = "background-color:#dfd">                else if (st.failure_flags &amp; TestCaseFailureReason::CouldHaveFailedAndDid) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Yellow &lt;&lt; "Allowed to fail so marking it as not failed\n";
                }</span>
<span style = "background-color:#dfd">                else if (st.failure_flags &amp; TestCaseFailureReason::DidntFailExactlyNumTimes) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Red &lt;&lt; "Didn't fail exactly " &lt;&lt; tc-&gt;m_expected_failures</span>
                        &lt;&lt; " times so marking it as failed!\n";
<span style = "background-color:#fdd">                }</span>
<span style = "background-color:#dfd">                else if (st.failure_flags &amp; TestCaseFailureReason::FailedExactlyNumTimes) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Yellow &lt;&lt; "Failed exactly " &lt;&lt; tc-&gt;m_expected_failures</span>
                        &lt;&lt; " times as expected so marking it as not failed!\n";
                }
<span style = "background-color:#dfd">                if (st.failure_flags &amp; TestCaseFailureReason::TooManyFailedAsserts) {</span>
<span style = "background-color:#fdd">                    s &lt;&lt; Color::Red &lt;&lt; "Aborting - too many failed asserts!\n";</span>
                }
<span style = "background-color:#dfd">                s &lt;&lt; Color::None; // lgtm [cpp/useless-expression]
            }</span>

<span style = "background-color:#fdd">            void test_case_exception(const TestCaseException&amp; e) override {
                DOCTEST_LOCK_MUTEX(mutex)
                    if (tc-&gt;m_no_output)
                        return;</span>

<span style = "background-color:#fdd">                logTestStart();</span>

<span style = "background-color:#fdd">                file_line_to_stream(tc-&gt;m_file.c_str(), tc-&gt;m_line, " ");
                successOrFailColoredStringToStream(false, e.is_crash ? assertType::is_require :</span>
                    assertType::is_check);
<span style = "background-color:#fdd">                s &lt;&lt; Color::Red &lt;&lt; (e.is_crash ? "test case CRASHED: " : "test case THREW exception: ")</span>
                    &lt;&lt; Color::Cyan &lt;&lt; e.error_string &lt;&lt; "\n";

<span style = "background-color:#fdd">                int num_stringified_contexts = get_num_stringified_contexts();
                if (num_stringified_contexts) {
                    auto stringified_contexts = get_stringified_contexts();
                    s &lt;&lt; Color::None &lt;&lt; "  logged: ";
                    for (int i = num_stringified_contexts; i &gt; 0; --i) {
                        s &lt;&lt; (i == num_stringified_contexts ? "" : "          ")</span>
                            &lt;&lt; stringified_contexts[i - 1] &lt;&lt; "\n";
<span style = "background-color:#fdd">                    }</span>
                }
<span style = "background-color:#fdd">                s &lt;&lt; "\n" &lt;&lt; Color::None;
            }</span>

<span style = "background-color:#dfd">            void subcase_start(const SubcaseSignature&amp; subc) override {
                subcasesStack.push_back(subc);
                ++currentSubcaseLevel;
                hasLoggedCurrentTestStart = false;
            }</span>

<span style = "background-color:#dfd">            void subcase_end() override {
                --currentSubcaseLevel;
                hasLoggedCurrentTestStart = false;
            }</span>

<span style = "background-color:#dfd">            void log_assert(const AssertData&amp; rb) override {
                if ((!rb.m_failed &amp;&amp; !opt.success) || tc-&gt;m_no_output)
                    return;</span>

<span style = "background-color:#fdd">                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    logTestStart();</span>

<span style = "background-color:#fdd">                file_line_to_stream(rb.m_file, rb.m_line, " ");
                successOrFailColoredStringToStream(!rb.m_failed, rb.m_at);</span>

<span style = "background-color:#fdd">                fulltext_log_assert_to_stream(s, rb);</span>

<span style = "background-color:#fdd">                log_contexts();
            }</span>

<span style = "background-color:#fdd">            void log_message(const MessageData&amp; mb) override {
                if (tc-&gt;m_no_output)
                    return;</span>

<span style = "background-color:#fdd">                DOCTEST_LOCK_MUTEX(mutex)</span>

<span style = "background-color:#fdd">                    logTestStart();</span>

<span style = "background-color:#fdd">                file_line_to_stream(mb.m_file, mb.m_line, " ");
                s &lt;&lt; getSuccessOrFailColor(false, mb.m_severity)</span>
                    &lt;&lt; getSuccessOrFailString(mb.m_severity &amp; assertType::is_warn, mb.m_severity,
                        "MESSAGE") &lt;&lt; ": ";
<span style = "background-color:#fdd">                s &lt;&lt; Color::None &lt;&lt; mb.m_string &lt;&lt; "\n";
                log_contexts();
            }</span>

<span style = "background-color:#fdd">            void test_case_skipped(const TestCaseData&amp;) override {}</span>
        };

<span style = "background-color:#dfd">        DOCTEST_REGISTER_REPORTER("console", 0, ConsoleReporter);</span>

#ifdef DOCTEST_PLATFORM_WINDOWS
        struct DebugOutputWindowReporter : public ConsoleReporter
        {
            DOCTEST_THREAD_LOCAL static std::ostringstream oss;

<span style = "background-color:#dfd">            DebugOutputWindowReporter(const ContextOptions&amp; co)
                : ConsoleReporter(co, oss) {}</span>

#define DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(func, type, arg)                                    \
    void func(type arg) override {                                                                 \
        bool with_col = g_no_colors;                                                               \
        g_no_colors   = false;                                                                     \
        ConsoleReporter::func(arg);                                                                \
        if(oss.tellp() != std::streampos{}) {                                                      \
            DOCTEST_OUTPUT_DEBUG_STRING(oss.str().c_str());                                        \
            oss.str("");                                                                           \
        }                                                                                          \
        g_no_colors = with_col;                                                                    \
    }

<span style = "background-color:#dfd">            DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_start, DOCTEST_EMPTY, DOCTEST_EMPTY)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_end, const TestRunStats&amp;, in)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_start, const TestCaseData&amp;, in)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_reenter, const TestCaseData&amp;, in)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_end, const CurrentTestCaseStats&amp;, in)</span>
<span style = "background-color:#fdd">                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_exception, const TestCaseException&amp;, in)</span>
<span style = "background-color:#dfd">                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_start, const SubcaseSignature&amp;, in)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_end, DOCTEST_EMPTY, DOCTEST_EMPTY)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_assert, const AssertData&amp;, in)</span>
<span style = "background-color:#fdd">                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_message, const MessageData&amp;, in)
                DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_skipped, const TestCaseData&amp;, in)</span>
        };

<span style = "background-color:#dfd">        DOCTEST_THREAD_LOCAL std::ostringstream DebugOutputWindowReporter::oss;</span>
#endif // DOCTEST_PLATFORM_WINDOWS

        // the implementation of parseOption()
<span style = "background-color:#dfd">        bool parseOptionImpl(int argc, const char* const* argv, const char* pattern, String* value) {</span>
            // going from the end to the beginning and stopping on the first occurrence from the end
<span style = "background-color:#dfd">            for (int i = argc; i &gt; 0; --i) {
                auto index = i - 1;
                auto temp = std::strstr(argv[index], pattern);
                if (temp &amp;&amp; (value || strlen(temp) == strlen(pattern))) { //!OCLINT prefer early exits and continue</span>
                    // eliminate matches in which the chars before the option are not '-'
<span style = "background-color:#fdd">                    bool noBadCharsFound = true;
                    auto curr = argv[index];
                    while (curr != temp) {
                        if (*curr++ != '-') {
                            noBadCharsFound = false;
                            break;</span>
                        }
<span style = "background-color:#fdd">                    }
                    if (noBadCharsFound &amp;&amp; argv[index][0] == '-') {
                        if (value) {</span>
                            // parsing the value of an option
<span style = "background-color:#fdd">                            temp += strlen(pattern);
                            const unsigned len = strlen(temp);
                            if (len) {
                                *value = temp;
                                return true;</span>
                            }
<span style = "background-color:#fdd">                        }</span>
                        else {
                            // just a flag - no value
<span style = "background-color:#fdd">                            return true;</span>
                        }
                    }
                }
<span style = "background-color:#dfd">            }
            return false;
        }</span>

        // parses an option and returns the string after the '=' character
        bool parseOption(int argc, const char* const* argv, const char* pattern, String* value = nullptr,
<span style = "background-color:#dfd">            const String&amp; defaultVal = String()) {
            if (value)
                *value = defaultVal;</span>
#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
            // offset (normally 3 for "dt-") to skip prefix
<span style = "background-color:#dfd">            if (parseOptionImpl(argc, argv, pattern + strlen(DOCTEST_CONFIG_OPTIONS_PREFIX), value))</span>
<span style = "background-color:#fdd">                return true;</span>
#endif // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS
<span style = "background-color:#dfd">            return parseOptionImpl(argc, argv, pattern, value);
        }</span>

        // locates a flag on the command line
<span style = "background-color:#dfd">        bool parseFlag(int argc, const char* const* argv, const char* pattern) {
            return parseOption(argc, argv, pattern);
        }</span>

        // parses a comma separated list of words after a pattern in one of the arguments in argv
        bool parseCommaSepArgs(int argc, const char* const* argv, const char* pattern,
<span style = "background-color:#dfd">            std::vector&lt;String&gt;&amp; res) {
            String filtersString;
            if (parseOption(argc, argv, pattern, &amp;filtersString)) {</span>
                // tokenize with "," as a separator, unless escaped with backslash
<span style = "background-color:#fdd">                std::ostringstream s;
                auto flush = [&amp;s, &amp;res]() {
                    auto string = s.str();
                    if (string.size() &gt; 0) {
                        res.push_back(string.c_str());</span>
                    }
<span style = "background-color:#fdd">                    s.str("");
                    };</span>

<span style = "background-color:#fdd">                bool seenBackslash = false;
                const char* current = filtersString.c_str();
                const char* end = current + strlen(current);
                while (current != end) {
                    char character = *current++;
                    if (seenBackslash) {
                        seenBackslash = false;
                        if (character == ',' || character == '\\') {
                            s.put(character);
                            continue;</span>
                        }
<span style = "background-color:#fdd">                        s.put('\\');</span>
                    }
<span style = "background-color:#fdd">                    if (character == '\\') {
                        seenBackslash = true;
                    }
                    else if (character == ',') {
                        flush();
                    }</span>
                    else {
<span style = "background-color:#fdd">                        s.put(character);</span>
                    }
<span style = "background-color:#fdd">                }</span>

<span style = "background-color:#fdd">                if (seenBackslash) {
                    s.put('\\');</span>
                }
<span style = "background-color:#fdd">                flush();
                return true;</span>
            }
<span style = "background-color:#dfd">            return false;
        }</span>

        enum optionType
        {
            option_bool,
            option_int
        };

        // parses an int/bool option from the command line
        bool parseIntOption(int argc, const char* const* argv, const char* pattern, optionType type,
<span style = "background-color:#dfd">            int&amp; res) {
            String parsedValue;
            if (!parseOption(argc, argv, pattern, &amp;parsedValue))
                return false;</span>

<span style = "background-color:#fdd">            if (type) {</span>
                // integer
                // TODO: change this to use std::stoi or something else! currently it uses undefined behavior - assumes '0' on failed parse...
<span style = "background-color:#fdd">                int theInt = std::atoi(parsedValue.c_str());
                if (theInt != 0) {
                    res = theInt; //!OCLINT parameter reassignment
                    return true;</span>
                }
<span style = "background-color:#fdd">            }</span>
            else {
                // boolean
<span style = "background-color:#fdd">                const char positive[][5] = { "1", "true", "on", "yes" };  // 5 - strlen("true") + 1
                const char negative[][6] = { "0", "false", "off", "no" }; // 6 - strlen("false") + 1</span>

                // if the value matches any of the positive/negative possibilities
<span style = "background-color:#fdd">                for (unsigned i = 0; i &lt; 4; i++) {
                    if (parsedValue.compare(positive[i], true) == 0) {
                        res = 1; //!OCLINT parameter reassignment
                        return true;</span>
                    }
<span style = "background-color:#fdd">                    if (parsedValue.compare(negative[i], true) == 0) {
                        res = 0; //!OCLINT parameter reassignment
                        return true;</span>
                    }
<span style = "background-color:#fdd">                }</span>
            }
<span style = "background-color:#fdd">            return false;</span>
<span style = "background-color:#dfd">        }</span>
    } // namespace

    Context::Context(int argc, const char* const* argv)
<span style = "background-color:#dfd">        : p(new detail::ContextState) {
        parseArgs(argc, argv, true);
        if (argc)
            p-&gt;binary_name = argv[0];
    }</span>

<span style = "background-color:#dfd">    Context::~Context() {
        if (g_cs == p)</span>
<span style = "background-color:#fdd">            g_cs = nullptr;</span>
<span style = "background-color:#dfd">        delete p;
    }</span>

<span style = "background-color:#fdd">    void Context::applyCommandLine(int argc, const char* const* argv) {
        parseArgs(argc, argv);
        if (argc)
            p-&gt;binary_name = argv[0];
    }</span>

    // parses args
<span style = "background-color:#dfd">    void Context::parseArgs(int argc, const char* const* argv, bool withDefaults) {</span>
        using namespace detail;

        // clang-format off
<span style = "background-color:#dfd">        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file=", p-&gt;filters[0]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sf=", p-&gt;filters[0]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "source-file-exclude=", p-&gt;filters[1]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sfe=", p-&gt;filters[1]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite=", p-&gt;filters[2]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ts=", p-&gt;filters[2]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-suite-exclude=", p-&gt;filters[3]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tse=", p-&gt;filters[3]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case=", p-&gt;filters[4]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tc=", p-&gt;filters[4]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "test-case-exclude=", p-&gt;filters[5]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "tce=", p-&gt;filters[5]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase=", p-&gt;filters[6]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sc=", p-&gt;filters[6]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "subcase-exclude=", p-&gt;filters[7]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "sce=", p-&gt;filters[7]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "reporters=", p-&gt;filters[8]);
        parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "r=", p-&gt;filters[8]);</span>
        // clang-format on

<span style = "background-color:#dfd">        int    intRes = 0;
        String strRes;</span>

#define DOCTEST_PARSE_AS_BOOL_OR_FLAG(name, sname, var, default)                                   \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_bool, intRes) ||  \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_bool, intRes))   \
        p-&gt;var = static_cast&lt;bool&gt;(intRes);                                                        \
    else if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name) ||                           \
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname))                            \
        p-&gt;var = true;                                                                             \
    else if(withDefaults)                                                                          \
    p-&gt;var = default

#define DOCTEST_PARSE_INT_OPTION(name, sname, var, default)                                        \
    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", option_int, intRes) ||   \
       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", option_int, intRes))    \
        p-&gt;var = intRes;                                                                           \
    else if(withDefaults)                                                                          \
    p-&gt;var = default

#define DOCTEST_PARSE_STR_OPTION(name, sname, var, default)                                        \
    if(parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name "=", &amp;strRes, default) ||        \
       parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname "=", &amp;strRes, default) ||       \
       withDefaults)                                                                               \
    p-&gt;var = strRes

        // clang-format off
<span style = "background-color:#dfd">        DOCTEST_PARSE_STR_OPTION("out", "o", out, "");
        DOCTEST_PARSE_STR_OPTION("order-by", "ob", order_by, "file");
        DOCTEST_PARSE_INT_OPTION("rand-seed", "rs", rand_seed, 0);</span>

<span style = "background-color:#dfd">        DOCTEST_PARSE_INT_OPTION("first", "f", first, 0);
        DOCTEST_PARSE_INT_OPTION("last", "l", last, UINT_MAX);</span>

<span style = "background-color:#dfd">        DOCTEST_PARSE_INT_OPTION("abort-after", "aa", abort_after, 0);
        DOCTEST_PARSE_INT_OPTION("subcase-filter-levels", "scfl", subcase_filter_levels, INT_MAX);</span>

<span style = "background-color:#dfd">        DOCTEST_PARSE_AS_BOOL_OR_FLAG("success", "s", success, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("case-sensitive", "cs", case_sensitive, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("exit", "e", exit, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("duration", "d", duration, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("minimal", "m", minimal, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("quiet", "q", quiet, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-throw", "nt", no_throw, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-exitcode", "ne", no_exitcode, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-run", "nr", no_run, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-intro", "ni", no_intro, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-version", "nv", no_version, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-colors", "nc", no_colors, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("force-colors", "fc", force_colors, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-breaks", "nb", no_breaks, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skip", "ns", no_skip, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("gnu-file-line", "gfl", gnu_file_line, !bool(DOCTEST_MSVC));
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-path-filenames", "npf", no_path_in_filenames, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-line-numbers", "nln", no_line_numbers, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-debug-output", "ndo", no_debug_output, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-skipped-summary", "nss", no_skipped_summary, false);
        DOCTEST_PARSE_AS_BOOL_OR_FLAG("no-time-in-output", "ntio", no_time_in_output, false);</span>
        // clang-format on

<span style = "background-color:#dfd">        if (withDefaults) {
            p-&gt;help = false;
            p-&gt;version = false;
            p-&gt;count = false;
            p-&gt;list_test_cases = false;
            p-&gt;list_test_suites = false;
            p-&gt;list_reporters = false;</span>
        }
        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "help") ||
<span style = "background-color:#dfd">            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "h") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "?")) {
<span style = "background-color:#fdd">            p-&gt;help = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "version") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "v")) {
<span style = "background-color:#fdd">            p-&gt;version = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "count") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "c")) {
<span style = "background-color:#fdd">            p-&gt;count = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-cases") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "ltc")) {
<span style = "background-color:#fdd">            p-&gt;list_test_cases = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-test-suites") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lts")) {
<span style = "background-color:#fdd">            p-&gt;list_test_suites = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">        if (parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "list-reporters") ||</span>
            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX "lr")) {
<span style = "background-color:#fdd">            p-&gt;list_reporters = true;
            p-&gt;exit = true;</span>
        }
<span style = "background-color:#dfd">    }</span>

    // allows the user to add procedurally to the filters from the command line
<span style = "background-color:#fdd">    void Context::addFilter(const char* filter, const char* value) { setOption(filter, value); }</span>

    // allows the user to clear all filters from the command line
<span style = "background-color:#fdd">    void Context::clearFilters() {
        for (auto&amp; curr : p-&gt;filters)
            curr.clear();
    }</span>

    // allows the user to override procedurally the bool options from the command line
<span style = "background-color:#fdd">    void Context::setOption(const char* option, bool value) {
        setOption(option, value ? "true" : "false");
    }</span>

    // allows the user to override procedurally the int options from the command line
<span style = "background-color:#fdd">    void Context::setOption(const char* option, int value) {
        setOption(option, toString(value).c_str());
    }</span>

    // allows the user to override procedurally the string options from the command line
<span style = "background-color:#fdd">    void Context::setOption(const char* option, const char* value) {
        auto argv = String("-") + option + "=" + value;
        auto lvalue = argv.c_str();
        parseArgs(1, &amp;lvalue);
    }</span>

    // users should query this in their main() and exit the program if true
<span style = "background-color:#fdd">    bool Context::shouldExit() { return p-&gt;exit; }</span>

<span style = "background-color:#fdd">    void Context::setAsDefaultForAssertsOutOfTestCases() { g_cs = p; }</span>

<span style = "background-color:#fdd">    void Context::setAssertHandler(detail::assert_handler ah) { p-&gt;ah = ah; }</span>

<span style = "background-color:#fdd">    void Context::setCout(std::ostream* out) { p-&gt;cout = out; }</span>

    static class DiscardOStream : public std::ostream
    {
    private:
        class : public std::streambuf
        {
        private:
            // allowing some buffering decreases the amount of calls to overflow
            char buf[1024];

        protected:
<span style = "background-color:#fdd">            std::streamsize xsputn(const char_type*, std::streamsize count) override { return count; }</span>

<span style = "background-color:#fdd">            int_type overflow(int_type ch) override {
                setp(std::begin(buf), std::end(buf));
                return traits_type::not_eof(ch);
            }</span>
        } discardBuf;

    public:
<span style = "background-color:#dfd">        DiscardOStream()
            : std::ostream(&amp;discardBuf) {}
    } discardOut;</span>

    // the main function that does all the filtering and test running
<span style = "background-color:#dfd">    int Context::run() {</span>
        using namespace detail;

        // save the old context state in case such was setup - for using asserts out of a testing context
<span style = "background-color:#dfd">        auto old_cs = g_cs;</span>
        // this is the current contest
<span style = "background-color:#dfd">        g_cs = p;
        is_running_in_test = true;</span>

<span style = "background-color:#dfd">        g_no_colors = p-&gt;no_colors;
        p-&gt;resetRunData();</span>

<span style = "background-color:#dfd">        std::fstream fstr;
        if (p-&gt;cout == nullptr) {
            if (p-&gt;quiet) {</span>
<span style = "background-color:#fdd">                p-&gt;cout = &amp;discardOut;
            }</span>
<span style = "background-color:#dfd">            else if (p-&gt;out.size()) {</span>
                // to a file if specified
<span style = "background-color:#fdd">                fstr.open(p-&gt;out.c_str(), std::fstream::out);
                p-&gt;cout = &amp;fstr;
            }</span>
            else {
#ifndef DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
                // stdout by default
<span style = "background-color:#dfd">                p-&gt;cout = &amp;std::cout;</span>
#else // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
                return EXIT_FAILURE;
#endif // DOCTEST_CONFIG_NO_INCLUDE_IOSTREAM
            }
        }

<span style = "background-color:#dfd">        FatalConditionHandler::allocateAltStackMem();</span>

<span style = "background-color:#dfd">        auto cleanup_and_return = [&amp;]() {
            FatalConditionHandler::freeAltStackMem();</span>

<span style = "background-color:#dfd">            if (fstr.is_open())</span>
<span style = "background-color:#fdd">                fstr.close();</span>

            // restore context
<span style = "background-color:#dfd">            g_cs = old_cs;
            is_running_in_test = false;</span>

            // we have to free the reporters which were allocated when the run started
<span style = "background-color:#dfd">            for (auto&amp; curr : p-&gt;reporters_currently_used)
                delete curr;
            p-&gt;reporters_currently_used.clear();</span>

<span style = "background-color:#dfd">            if (p-&gt;numTestCasesFailed &amp;&amp; !p-&gt;no_exitcode)</span>
<span style = "background-color:#fdd">                return EXIT_FAILURE;</span>
<span style = "background-color:#dfd">            return EXIT_SUCCESS;
            };</span>

        // setup default reporter if none is given through the command line
<span style = "background-color:#dfd">        if (p-&gt;filters[8].empty())
            p-&gt;filters[8].push_back("console");</span>

        // check to see if any of the registered reporters has been selected
<span style = "background-color:#dfd">        for (auto&amp; curr : getReporters()) {
            if (matchesAny(curr.first.second.c_str(), p-&gt;filters[8], false, p-&gt;case_sensitive))
                p-&gt;reporters_currently_used.push_back(curr.second(*g_cs));
        }</span>

        // TODO: check if there is nothing in reporters_currently_used

        // prepend all listeners
<span style = "background-color:#dfd">        for (auto&amp; curr : getListeners())</span>
<span style = "background-color:#fdd">            p-&gt;reporters_currently_used.insert(p-&gt;reporters_currently_used.begin(), curr.second(*g_cs));</span>

#ifdef DOCTEST_PLATFORM_WINDOWS
<span style = "background-color:#dfd">        if (isDebuggerActive() &amp;&amp; p-&gt;no_debug_output == false)
            p-&gt;reporters_currently_used.push_back(new DebugOutputWindowReporter(*g_cs));</span>
#endif // DOCTEST_PLATFORM_WINDOWS

        // handle version, help and no_run
<span style = "background-color:#dfd">        if (p-&gt;no_run || p-&gt;version || p-&gt;help || p-&gt;list_reporters) {</span>
<span style = "background-color:#fdd">            DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, QueryData());</span>

<span style = "background-color:#fdd">            return cleanup_and_return();</span>
        }

<span style = "background-color:#dfd">        std::vector&lt;const TestCase*&gt; testArray;
        for (auto&amp; curr : getRegisteredTests())
            testArray.push_back(&amp;curr);
        p-&gt;numTestCases = testArray.size();</span>

        // sort the collected records
<span style = "background-color:#dfd">        if (!testArray.empty()) {
            if (p-&gt;order_by.compare("file", true) == 0) {
                std::sort(testArray.begin(), testArray.end(), fileOrderComparator);
            }</span>
<span style = "background-color:#fdd">            else if (p-&gt;order_by.compare("suite", true) == 0) {
                std::sort(testArray.begin(), testArray.end(), suiteOrderComparator);
            }
            else if (p-&gt;order_by.compare("name", true) == 0) {
                std::sort(testArray.begin(), testArray.end(), nameOrderComparator);
            }
            else if (p-&gt;order_by.compare("rand", true) == 0) {
                std::srand(p-&gt;rand_seed);</span>

                // random_shuffle implementation
<span style = "background-color:#fdd">                const auto first = &amp;testArray[0];
                for (size_t i = testArray.size() - 1; i &gt; 0; --i) {
                    int idxToSwap = std::rand() % (i + 1);</span>

<span style = "background-color:#fdd">                    const auto temp = first[i];</span>

<span style = "background-color:#fdd">                    first[i] = first[idxToSwap];
                    first[idxToSwap] = temp;
                }
            }
            else if (p-&gt;order_by.compare("none", true) == 0) {</span>
                // means no sorting - beneficial for death tests which call into the executable
                // with a specific test case in mind - we don't want to slow down the startup times
            }
        }

<span style = "background-color:#dfd">        std::set&lt;String&gt; testSuitesPassingFilt;</span>

<span style = "background-color:#dfd">        bool                             query_mode = p-&gt;count || p-&gt;list_test_cases || p-&gt;list_test_suites;
        std::vector&lt;const TestCaseData*&gt; queryResults;</span>

<span style = "background-color:#dfd">        if (!query_mode)
            DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_start, DOCTEST_EMPTY);</span>

        // invoke the registered functions if they match the filter criteria (or just count them)
<span style = "background-color:#dfd">        for (auto&amp; curr : testArray) {
            const auto&amp; tc = *curr;</span>

<span style = "background-color:#dfd">            bool skip_me = false;
            if (tc.m_skip &amp;&amp; !p-&gt;no_skip)</span>
<span style = "background-color:#fdd">                skip_me = true;</span>

<span style = "background-color:#dfd">            if (!matchesAny(tc.m_file.c_str(), p-&gt;filters[0], true, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>
<span style = "background-color:#dfd">            if (matchesAny(tc.m_file.c_str(), p-&gt;filters[1], false, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>
<span style = "background-color:#dfd">            if (!matchesAny(tc.m_test_suite, p-&gt;filters[2], true, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>
<span style = "background-color:#dfd">            if (matchesAny(tc.m_test_suite, p-&gt;filters[3], false, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>
<span style = "background-color:#dfd">            if (!matchesAny(tc.m_name, p-&gt;filters[4], true, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>
<span style = "background-color:#dfd">            if (matchesAny(tc.m_name, p-&gt;filters[5], false, p-&gt;case_sensitive))</span>
<span style = "background-color:#fdd">                skip_me = true;</span>

<span style = "background-color:#dfd">            if (!skip_me)
                p-&gt;numTestCasesPassingFilters++;</span>

            // skip the test if it is not in the execution range
<span style = "background-color:#dfd">            if ((p-&gt;last &lt; p-&gt;numTestCasesPassingFilters &amp;&amp; p-&gt;first &lt;= p-&gt;last) ||</span>
                (p-&gt;first &gt; p-&gt;numTestCasesPassingFilters))
<span style = "background-color:#fdd">                skip_me = true;</span>

<span style = "background-color:#dfd">            if (skip_me) {</span>
<span style = "background-color:#fdd">                if (!query_mode)
                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_skipped, tc);
                continue;</span>
            }

            // do not execute the test if we are to only count the number of filter passing tests
<span style = "background-color:#dfd">            if (p-&gt;count)</span>
<span style = "background-color:#fdd">                continue;</span>

            // print the name of the test and don't execute it
<span style = "background-color:#dfd">            if (p-&gt;list_test_cases) {</span>
<span style = "background-color:#fdd">                queryResults.push_back(&amp;tc);
                continue;</span>
            }

            // print the name of the test suite if not done already and don't execute it
<span style = "background-color:#dfd">            if (p-&gt;list_test_suites) {</span>
<span style = "background-color:#fdd">                if ((testSuitesPassingFilt.count(tc.m_test_suite) == 0) &amp;&amp; tc.m_test_suite[0] != '\0') {
                    queryResults.push_back(&amp;tc);
                    testSuitesPassingFilt.insert(tc.m_test_suite);
                    p-&gt;numTestSuitesPassingFilters++;</span>
                }
<span style = "background-color:#fdd">                continue;</span>
            }

            // execute the test if it passes all the filtering
            {
<span style = "background-color:#dfd">                p-&gt;currentTest = &amp;tc;</span>

<span style = "background-color:#dfd">                p-&gt;failure_flags = TestCaseFailureReason::None;
                p-&gt;seconds = 0;</span>

                // reset atomic counters
<span style = "background-color:#dfd">                p-&gt;numAssertsFailedCurrentTest_atomic = 0;
                p-&gt;numAssertsCurrentTest_atomic = 0;</span>

<span style = "background-color:#dfd">                p-&gt;fullyTraversedSubcases.clear();</span>

<span style = "background-color:#dfd">                DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_start, tc);</span>

<span style = "background-color:#dfd">                p-&gt;timer.start();</span>

<span style = "background-color:#dfd">                bool run_test = true;</span>

                do {
                    // reset some of the fields for subcases (except for the set of fully passed ones)
<span style = "background-color:#dfd">                    p-&gt;reachedLeaf = false;</span>
                    // May not be empty if previous subcase exited via exception.
<span style = "background-color:#dfd">                    p-&gt;subcaseStack.clear();
                    p-&gt;currentSubcaseDepth = 0;</span>

<span style = "background-color:#dfd">                    p-&gt;shouldLogCurrentException = true;</span>

                    // reset stuff for logging with INFO()
<span style = "background-color:#dfd">                    p-&gt;stringifiedContexts.clear();</span>

#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
                    try {
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS
                        // MSVC 2015 diagnoses fatalConditionHandler as unused (because reset() is a static method)
                        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4101) // unreferenced local variable
<span style = "background-color:#dfd">                            FatalConditionHandler fatalConditionHandler; // Handle signals</span>
                        // execute the test
<span style = "background-color:#dfd">                        tc.m_test();
                        fatalConditionHandler.reset();</span>
                        DOCTEST_MSVC_SUPPRESS_WARNING_POP
#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS
<span style = "background-color:#dfd">                    }</span>
<span style = "background-color:#fdd">                    catch (const TestFailureException&amp;) {
                        p-&gt;failure_flags |= TestCaseFailureReason::AssertFailure;
                    }
                    catch (...) {
                        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception,
                            { translateActiveException(), false });
                        p-&gt;failure_flags |= TestCaseFailureReason::Exception;
                    }</span>
#endif // DOCTEST_CONFIG_NO_EXCEPTIONS

                    // exit this loop if enough assertions have failed - even if there are more subcases
<span style = "background-color:#dfd">                    if (p-&gt;abort_after &gt; 0 &amp;&amp;</span>
                        p-&gt;numAssertsFailed + p-&gt;numAssertsFailedCurrentTest_atomic &gt;= p-&gt;abort_after) {
<span style = "background-color:#fdd">                        run_test = false;
                        p-&gt;failure_flags |= TestCaseFailureReason::TooManyFailedAsserts;</span>
                    }

<span style = "background-color:#dfd">                    if (!p-&gt;nextSubcaseStack.empty() &amp;&amp; run_test)
                        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_reenter, tc);
                    if (p-&gt;nextSubcaseStack.empty())
                        run_test = false;
                } while (run_test);</span>

<span style = "background-color:#dfd">                p-&gt;finalizeTestCaseData();</span>

<span style = "background-color:#dfd">                DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);</span>

<span style = "background-color:#dfd">                p-&gt;currentTest = nullptr;</span>

                // stop executing tests if enough assertions have failed
<span style = "background-color:#dfd">                if (p-&gt;abort_after &gt; 0 &amp;&amp; p-&gt;numAssertsFailed &gt;= p-&gt;abort_after)</span>
<span style = "background-color:#fdd">                    break;</span>
            }
<span style = "background-color:#dfd">        }</span>

<span style = "background-color:#dfd">        if (!query_mode) {
            DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);
        }</span>
        else {
<span style = "background-color:#fdd">            QueryData qdata;
            qdata.run_stats = g_cs;
            qdata.data = queryResults.data();
            qdata.num_data = unsigned(queryResults.size());
            DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, qdata);</span>
        }

<span style = "background-color:#dfd">        return cleanup_and_return();
    }</span>

<span style = "background-color:#dfd">    DOCTEST_DEFINE_INTERFACE(IReporter)</span>

<span style = "background-color:#fdd">        int IReporter::get_num_active_contexts() { return detail::g_infoContexts.size(); }
    const IContextScope* const* IReporter::get_active_contexts() {
        return get_num_active_contexts() ? &amp;detail::g_infoContexts[0] : nullptr;
    }</span>

<span style = "background-color:#fdd">    int IReporter::get_num_stringified_contexts() { return detail::g_cs-&gt;stringifiedContexts.size(); }
    const String* IReporter::get_stringified_contexts() {
        return get_num_stringified_contexts() ? &amp;detail::g_cs-&gt;stringifiedContexts[0] : nullptr;
    }</span>

    namespace detail {
<span style = "background-color:#dfd">        void registerReporterImpl(const char* name, int priority, reporterCreatorFunc c, bool isReporter) {
            if (isReporter)
                getReporters().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));</span>
            else
<span style = "background-color:#fdd">                getListeners().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));</span>
<span style = "background-color:#dfd">        }</span>
    } // namespace detail

    } // namespace doctest

#endif // DOCTEST_CONFIG_DISABLE

#ifdef DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4007) // 'function' : must be 'attribute' - see issue #182
<span style = "background-color:#dfd">int main(int argc, char** argv) { return doctest::Context(argc, argv).run(); }</span>
DOCTEST_MSVC_SUPPRESS_WARNING_POP
#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN

DOCTEST_CLANG_SUPPRESS_WARNING_POP
DOCTEST_MSVC_SUPPRESS_WARNING_POP
DOCTEST_GCC_SUPPRESS_WARNING_POP

DOCTEST_SUPPRESS_COMMON_WARNINGS_POP

#endif // DOCTEST_LIBRARY_IMPLEMENTATION
#endif // DOCTEST_CONFIG_IMPLEMENT

#ifdef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#undef DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN
#endif // DOCTEST_UNDEF_WIN32_LEAN_AND_MEAN

#ifdef DOCTEST_UNDEF_NOMINMAX
#undef NOMINMAX
#undef DOCTEST_UNDEF_NOMINMAX
#endif // DOCTEST_UNDEF_NOMINMAX</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>