<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Test_Logger.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#define _CRT_SECURE_NO_WARNINGS

#include "doctest.h"
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include "spdlog/sinks/daily_file_sink.h"
#include "../Main/Logger.h"

// Helper function to get the formatted output
<span style = "background-color:#dfd">std::string get_log_contents(const std::string&amp; file_path) {
    std::ifstream file(file_path);
    if (!file.is_open()) {
        return "";</span>
    }
<span style = "background-color:#dfd">    std::stringstream buffer;
    buffer &lt;&lt; file.rdbuf();</span>

<span style = "background-color:#dfd">    if (buffer.str().empty()) {</span>
<span style = "background-color:#fdd">        std::cerr &lt;&lt; "Buffer is empty, file may not contain any content or read operation failed." &lt;&lt; std::endl;</span>
    }

<span style = "background-color:#dfd">    return buffer.str();
}</span>

<span style = "background-color:#dfd">std::string get_current_date_string() {
    std::time_t now = std::time(nullptr);
    std::tm* local_tm = std::localtime(&amp;now);
    std::stringstream date_stream;
    date_stream &lt;&lt; std::put_time(local_tm, "%Y-%m-%d"); // Example format: 2024-09-08
    return date_stream.str();
}
TEST_CASE("get_log_contents handles file open failure") {</span>
    // Attempt to read from a non-existent file
<span style = "background-color:#dfd">    std::string non_existent_file = "non_existent_file.txt";
    std::string result = get_log_contents(non_existent_file);</span>

    // Check that the function returns an empty string when the file can't be opened
<span style = "background-color:#dfd">    CHECK(result.empty());
}
TEST_CASE("Logger Initialization and Formatting") {</span>
    // Initialize logger
<span style = "background-color:#dfd">    Logger::initialize_logger();</span>

    // Test logger initialization
<span style = "background-color:#dfd">    CHECK_NOTHROW(spdlog::get("daily_logger")-&gt;debug("Test message"));</span>

<span style = "background-color:#dfd">    std::string date_string = get_current_date_string();
    std::string file_path = "logs/daily_log_" + date_string + ".html";</span>

    // Check if the log file has been created and has the correct content
<span style = "background-color:#dfd">    const std::string log_content = get_log_contents(file_path);</span>

    // Print out the log content for debugging
<span style = "background-color:#dfd">    std::cout &lt;&lt; "Log Content:\n" &lt;&lt; log_content &lt;&lt; std::endl;</span>

<span style = "background-color:#dfd">    SUBCASE("Test log message formatting") {</span>
        // Ensure the log contains a message with the correct HTML structure
<span style = "background-color:#dfd">        CHECK(log_content.find("&lt;p style=\"color:blue\"&gt;") != std::string::npos);  // Debug message should be in blue
        CHECK(log_content.find("Test message") != std::string::npos);
    }
}</span>

<span style = "background-color:#dfd">TEST_CASE("HtmlFormatter: Formatting Log Messages") {
    HtmlFormatter formatter;
    spdlog::memory_buf_t buffer;</span>

<span style = "background-color:#dfd">    spdlog::details::log_msg msg;
    SUBCASE("Formatting Info Message") {
        msg.level = spdlog::level::info;
        msg.payload = spdlog::string_view_t("This is an info message");</span>

<span style = "background-color:#dfd">        formatter.format(msg, buffer);</span>

        // Check that the formatted message contains the expected HTML tags
<span style = "background-color:#dfd">        std::string result(buffer.data(), buffer.size());
        CHECK(result.find("&lt;p style=\"color:green\"&gt;") != std::string::npos);  // Info message should be in green
        CHECK(result.find("This is an info message") != std::string::npos);
    }
    SUBCASE("Formatting Warning Message") {
        msg.level = spdlog::level::warn;
        msg.payload = spdlog::string_view_t("This is a warning message");</span>

<span style = "background-color:#dfd">        formatter.format(msg, buffer);</span>

        // Check that the formatted message contains the expected HTML tags
<span style = "background-color:#dfd">        std::string result(buffer.data(), buffer.size());
        CHECK(result.find("&lt;p style=\"color:yellow\"&gt;") != std::string::npos);  // Warning message should be in yellow
        CHECK(result.find("This is a warning message") != std::string::npos);
    }
    SUBCASE("Formatting Error Message") {
        msg.level = spdlog::level::err;
        msg.payload = spdlog::string_view_t("This is an error message");</span>

<span style = "background-color:#dfd">        formatter.format(msg, buffer);</span>

        // Check that the formatted message contains the expected HTML tags
<span style = "background-color:#dfd">        std::string result(buffer.data(), buffer.size());
        CHECK(result.find("&lt;p style=\"color:red\"&gt;") != std::string::npos);  // Error message should be in red
        CHECK(result.find("This is an error message") != std::string::npos);
    }
    SUBCASE("Formatting a Default Message") {
        msg.level = spdlog::level::off;
        msg.payload = spdlog::string_view_t("This is a default message");</span>

<span style = "background-color:#dfd">        formatter.format(msg, buffer);</span>

        // Check that the formatted message contains the expected HTML tags
<span style = "background-color:#dfd">        std::string result(buffer.data(), buffer.size());
        CHECK(result.find("&lt;p style=\"color:black\"&gt;") != std::string::npos);  // Default message should be in black
        CHECK(result.find("This is a default message") != std::string::npos);
    }
}
TEST_CASE("HtmlFormatter: Clone Function") {
    HtmlFormatter original_formatter;</span>

    // Clone the formatter
<span style = "background-color:#dfd">    auto cloned_formatter = original_formatter.clone();</span>

    // Check that the cloned formatter is not null
<span style = "background-color:#dfd">    CHECK(cloned_formatter != nullptr);</span>

    // Check that the cloned formatter is a different object
<span style = "background-color:#dfd">    CHECK(&amp;original_formatter != cloned_formatter.get());</span>

    // Test that the cloned formatter behaves the same as the original
<span style = "background-color:#dfd">    spdlog::memory_buf_t original_buffer, cloned_buffer;
    spdlog::details::log_msg msg;
    msg.level = spdlog::level::info;
    msg.payload = spdlog::string_view_t("Test message");</span>

<span style = "background-color:#dfd">    original_formatter.format(msg, original_buffer);
    cloned_formatter-&gt;format(msg, cloned_buffer);</span>

<span style = "background-color:#dfd">    std::string original_result(original_buffer.data(), original_buffer.size());
    std::string cloned_result(cloned_buffer.data(), cloned_buffer.size());</span>

    // Check that both formatters produce the same output
<span style = "background-color:#dfd">    CHECK(original_result == cloned_result);
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>