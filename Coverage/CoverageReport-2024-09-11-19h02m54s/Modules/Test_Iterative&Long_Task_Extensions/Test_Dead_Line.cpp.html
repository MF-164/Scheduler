<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Test_Dead_Line.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "doctest.h"
#include "DeadLineTask.h"
#include "DeadlineTaskManager.h"
#include "Scheduler.h"
#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;memory&gt;

using namespace std;

<span style = "background-color:#dfd">TEST_CASE("Test DeadLineTask creation and management") {</span>

    // Initialize DeadlineTaskManager and Scheduler
    DeadlineTaskManager manager;
    Scheduler scheduler;

    // Test the insertion of tasks into the heap
<span style = "background-color:#dfd">    SUBCASE("Test deadline task inserts to the heap") {</span>
        // Create tasks (task1: regular task, task2: deadline task)
<span style = "background-color:#dfd">        auto task1 = std::make_shared&lt;Task&gt;(1, PrioritiesLevel::HIGHER, 15);
        auto task2 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 10), time(nullptr) + 2));</span>

        // Insert tasks into the scheduler
<span style = "background-color:#dfd">        scheduler.insertTask(task1);
        scheduler.insertTask(task2);  // Assuming insertTask accepts both Task and DeadLineTask</span>

        // Verify if the correct task is at the top of the heap
<span style = "background-color:#dfd">        auto incomingTask = manager.getUpcomingTask();
        CHECK(incomingTask-&gt;getId() == task2-&gt;getId());
    }</span>

    // Test that a deadline task becomes critical after a certain time
<span style = "background-color:#dfd">    SUBCASE("Test deadline time becomes critical") {
        auto Task1 = std::make_shared&lt;Task&gt;(1, PrioritiesLevel::HIGHER, 15);
        auto baseTaskPtr = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 10), time(nullptr) + 2));</span>

        // Insert tasks into the scheduler
<span style = "background-color:#dfd">        scheduler.insertTask(Task1);
        scheduler.insertTask(baseTaskPtr);</span>

        // Run the deadline mechanism in a separate thread
<span style = "background-color:#dfd">        std::thread deadLineThread([&amp;scheduler]() {
            cout &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; "----------------" &lt;&lt; endl;
            scheduler.getDeadlineTaskManager().deadlineMechanism();
            });</span>

        // Allow time for tasks to be processed
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(3));</span>

        // Detach the thread to finish execution
<span style = "background-color:#dfd">        deadLineThread.detach();
        cout &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; "----------------" &lt;&lt; endl;</span>

        // Verify that the task count in the real-time queue is 1
<span style = "background-color:#dfd">        CHECK(scheduler.getRealTimeScheduler().getRealTimeQueue().size() == 1);
    }</span>

    // Test the priority of tasks when popped from the heap
<span style = "background-color:#dfd">    SUBCASE("Test the pop from the heap") {</span>
        // Create deadline tasks with different deadlines
<span style = "background-color:#dfd">        auto deadlineTask1 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(1, PrioritiesLevel::LOWER, 1), time(nullptr) + 5));
        auto deadlineTask2 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 1), time(nullptr) + 1));</span>

        // Insert tasks into the scheduler
<span style = "background-color:#dfd">        scheduler.insertTask(deadlineTask1);
        scheduler.insertTask(deadlineTask2);</span>

        // Start the deadline mechanism in a separate thread
<span style = "background-color:#dfd">        std::thread deadLineThread([&amp;scheduler]() {
            cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;" &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; endl;
            scheduler.getDeadlineTaskManager().deadlineMechanism();
            });</span>

        // Detach the thread to finish execution
<span style = "background-color:#dfd">        deadLineThread.detach();</span>

        // Check the task at the top of the heap
<span style = "background-color:#dfd">        auto topTask = manager.getUpcomingTask();
        CHECK_EQ(topTask-&gt;getId(), 2);  // Task with ID 2 should be at the top</span>

        // Wait for the first task's deadline to pass
<span style = "background-color:#dfd">        std::this_thread::sleep_for(std::chrono::seconds(20));
        cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;" &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; endl;</span>

        // Check the task at the top again
<span style = "background-color:#dfd">        topTask = manager.getUpcomingTask();
        CHECK_EQ(topTask-&gt;getId(), 1);  // Task with ID 1 should now be at the top
    }
}</span>

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
////#include "doctest.h"
////#include "DeadLineTask.h"
////#include "DeadlineTaskManager.h"
////#include "Scheduler.h"
////#include &lt;chrono&gt;
////#include &lt;thread&gt;
////#include &lt;memory&gt;
////
////using namespace std;
////
////TEST_CASE("Test DeadLineTask creation and management") {
////
////    DeadlineTaskManager manager;
////    Scheduler scheduler;
////
////    SUBCASE("Test deadline task inserts to the heap") {
////        // Create
////        auto task1 = std::make_shared&lt;Task&gt;(1, PrioritiesLevel::HIGHER, 15);
////        auto task2 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 10), time(nullptr) + 2));
////
////        // Insert 
////        scheduler.insertTask(task1);
////        scheduler.insertTask(task2); // Assuming insertTask is adjusted to take Task
////
////        auto incomingTask = manager.getUpcomingTask(); 
////        CHECK(incomingTask-&gt;getId() == task2-&gt;getId());
////
////    }
////
////    SUBCASE("Test deadline time becomes critical"){
////
////        auto Task1 = std::make_shared&lt;Task&gt;(1, PrioritiesLevel::HIGHER, 15);
////        auto baseTaskPtr = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 10), time(nullptr) + 2));
////
////        // Insert 
////        scheduler.insertTask(Task1);
////        scheduler.insertTask(baseTaskPtr); // Assuming insertTask is adjusted to take Task
////
////        // Start the scheduler in a new thread
////        std::thread deadLineThread([&amp;scheduler]() {
////            cout &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; "----------------" &lt;&lt; endl;
////            scheduler.getDeadlineTaskManager().deadlineMechanism();
////            });
////        // Allow some time for tasks to be processed
////        std::this_thread::sleep_for(std::chrono::seconds(3));
////
////        // Terminate the thread by stopping its execution manually
////        deadLineThread.detach();  // Detach the thread to allow it to finish
////        cout &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; "----------------" &lt;&lt; endl;
////
////        CHECK(scheduler.getRealTimeScheduler().getRealTimeQueue().size() == 1);
////    }
////
////    SUBCASE("Test the pop from the heap") {
////
////        // Create
////        auto deadlineTask1 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(1, PrioritiesLevel::LOWER, 1), time(nullptr) + 5));
////        auto deadlineTask2 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(2, PrioritiesLevel::LOWER, 1), time(nullptr) + 1));
////        //auto deadlineTask3 = std::make_shared&lt;DeadLineTask&gt;(DeadLineTask(Task(3, PrioritiesLevel::LOWER, 1), time(nullptr) + 3));
////
////        // Insert 
////        scheduler.insertTask(deadlineTask1);
////        scheduler.insertTask(deadlineTask2); 
////        //scheduler.insertTask(deadlineTask3); 
////
////        // Start the deadlineMechanism 
////        std::thread deadLineThread([&amp;scheduler]() {
////            cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;" &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; endl;
////            scheduler.getDeadlineTaskManager().deadlineMechanism();
////            });
////        deadLineThread.detach();  // Detach the thread to allow it to finish
////
////        // Check if the expected order is maintained
////        auto topTask = manager.getUpcomingTask(); // Get the next task in queue
////
////        // Check the top of the heap 
////        CHECK_EQ(topTask-&gt;getId(), 2);
////
////        std::this_thread::sleep_for(std::chrono::seconds(20)); // Wait for the first task's deadline
////        cout &lt;&lt; "&lt;&lt;&lt;&lt;&lt;" &lt;&lt; scheduler.getRealTimeScheduler().getRealTimeQueue().size() &lt;&lt; endl;
////
////        topTask = manager.getUpcomingTask(); // Check the next task again
////        // Check the top of the heap 
////        CHECK_EQ(topTask-&gt;getId(), 1);// ID 1 should be top
////
////    }
////
////
////
////}
////
////
////</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>