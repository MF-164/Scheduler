<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Scheduler.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "Scheduler.h"
#include "Consts.h"
#include "Task.h"
#include "ReadFromJSON.h"

int Scheduler::totalRunningTask = 0;
unsigned int Scheduler::taskIds = 0;
<span style = "background-color:#dfd">mutex Scheduler::rtLock;
RealTimeScheduler Scheduler::realTimeScheduler;
WeightRoundRobinScheduler Scheduler::wrrQueuesScheduler;</span>

/**
 * @brief Executes a given task.
 *
 * This function processes a task by running it and updating its status. If the task is not critical and there are tasks in the real-time scheduler queue, the current task is preempted and a task from the real-time queue is executed. The function also handles exceptions by setting the task status to terminated and printing an error message.
 *
 * @param task Pointer to the task to be executed.
 */
<span style = "background-color:#dfd">void Scheduler::execute(shared_ptr&lt;Task&gt; task) {
  spdlog::info("Executing task with ID: {}", task-&gt;getId());
	task-&gt;setStatus(TaskStatus::RUNNING);</span>
    // Continue executing the task while it has remaining running time
<span style = "background-color:#dfd">    while (task-&gt;getRunningTime() &gt; 0) {
        if (task-&gt;getPriority() != PrioritiesLevel::CRITICAL &amp;&amp; !realTimeScheduler.getRealTimeQueue().empty()) {
            spdlog::info("Preempting task with ID: {} for real-time task.", task-&gt;getId());
            preemptive(task);
            return;</span>
        }
        try {
            // Simulate task execution by decrementing running time
<span style = "background-color:#dfd">            task-&gt;setRunningTime(task-&gt;getRunningTime() - 1); 
            std::this_thread::sleep_for(std::chrono::seconds(1));</span>
        }
<span style = "background-color:#fdd">        catch (const std::exception&amp; e) {</span>
            // Handle any exceptions that occur during execution
<span style = "background-color:#fdd">            spdlog::error("Exception occurred while executing task with ID: {}: {}", task-&gt;getId(), e.what());
            task-&gt;setStatus(TaskStatus::TERMINATED);
            break; // Exit the loop if an exception is caught
        }</span>
<span style = "background-color:#dfd">    }</span>

    // Set the task status to COMPLETED when execution is finished
<span style = "background-color:#dfd">    task-&gt;setStatus(TaskStatus::COMPLETED);
    if (task-&gt;getPriority() == PrioritiesLevel::CRITICAL&amp;&amp; !realTimeScheduler.getRealTimeQueue().empty()) {
        realTimeScheduler.getRealTimeQueue().pop();
    }
    else if(!wrrQueuesScheduler.getWrrQueues()[task-&gt;getPriority()].queue.empty()) {</span>
<span style = "background-color:#fdd">        wrrQueuesScheduler.getWrrQueues()[task-&gt;getPriority()].queue.pop();</span>
    }
  
<span style = "background-color:#dfd">    spdlog::info("Task with ID: {} completed.", task-&gt;getId());
}</span>

/**
 * @brief Displays the status of a task.
 *
 * This function prints the current status of the specified task to the standard output.
 *
 * @param task Pointer to the task whose status is to be displayed.
 */
<span style = "background-color:#dfd">void Scheduler::displayMessage(const Task* task) {
   std::cout &lt;&lt; "task " &lt;&lt; task-&gt;getId() &lt;&lt;" with priority: " &lt;&lt; task-&gt;getPriority()&lt;&lt; " is " &lt;&lt; task-&gt;getStatus() &lt;&lt; std::endl;
}</span>

/**
 * @brief Handles task preemption.
 *
 * This function sets the status of the given task to suspended and adds it to the weighted round-robin queue. This is used to preempt the current task when a higher priority task needs to be processed.
 *
 * @param task Pointer to the task to be preempted.
 */
<span style = "background-color:#dfd">void Scheduler::preemptive(shared_ptr&lt;Task&gt; task) {
    task-&gt;setStatus(TaskStatus::SUSPENDED);
    spdlog::info("Task with ID: {} suspended and added back to WRR queue.", task-&gt;getId());
}</span>



/**
 * @brief Initiates the scheduling process by creating and managing threads for various scheduler functions.
 *
 * This function creates separate threads for inserting tasks, real-time scheduling, and Weighted Round Robin scheduling.
 * It utilizes threading to allow concurrent execution of these tasks in the Scheduler class context.
 * Exceptions that may occur during thread creation are caught and handled within the function.
 */
<span style = "background-color:#fdd">void Scheduler::init() {
	Logger::initialize_logger();</span>

<span style = "background-color:#fdd">	spdlog::info(Logger::LoggerInfo::START_SCHEDULER);</span>
	try {
<span style = "background-color:#fdd">    std::thread readtasksFromJSON_Thread([this]() {
      SetThreadDescription(GetCurrentThread(), L"createTasksFromJSONWithDelay");
      spdlog::info("read tasks From JSON thread started.");
      ReadFromJSON::createTasksFromJSONWithDelay(Scenario::SCENARIO_1_FILE_PATH, 3, 15);
      });		// Create a thread for the InsertTask function
		std::thread insertTask_Thread([this]() {
			SetThreadDescription(GetCurrentThread(), L"InsertTask");
			spdlog::info(Logger::LoggerInfo::START_THREAD, "InsertTask");
			this-&gt;insertTaskFromInput();
			});</span>

		// Create a thread for real-Time Scheduler
<span style = "background-color:#fdd">		std::thread RTScheduler_Thread([this]() {
			SetThreadDescription(GetCurrentThread(), L"RealTimeScheduler");
			spdlog::info(Logger::LoggerInfo::START_THREAD, "RealTimeScheduler");
			realTimeScheduler.realTimeSchedulerFunction();
			});</span>

		// Create a thread for WRR Scheduler
<span style = "background-color:#fdd">		std::thread WRRScheduler_Thread([this]() {
			SetThreadDescription(GetCurrentThread(), L"WeightRoundRobinScheduler");
			spdlog::info(Logger::LoggerInfo::START_THREAD, "WeightRoundRobinScheduler");
			wrrQueuesScheduler.weightRoundRobinFunction();
			});</span>

<span style = "background-color:#fdd">		insertTask_Thread.join();
		RTScheduler_Thread.join();
		WRRScheduler_Thread.join();
	}
	catch (const std::exception&amp; ex) {</span>
		// Handle any exceptions that might occur during thread creation
<span style = "background-color:#fdd">		spdlog::error(Logger::LoggerError::ERROR_CREATE_THREAD, ex.what());
	}
}</span>

void Scheduler::insertTaskFromInput()
<span style = "background-color:#fdd">{
    while (true) {
        insertTask(input());
    }
}</span>



/**
 * @brief This function allows the user to input details for a new task, including priority and running time.
 *
 * @return A pointer to the newly created Task object based on the user input.
 */
shared_ptr&lt;Task&gt; Scheduler::input()
<span style = "background-color:#fdd">{
	std::string priority;</span>
	int runningTime;
<span style = "background-color:#fdd">	std::string input;</span>

<span style = "background-color:#fdd">	std::cout &lt;&lt; "Enter the priority for the task. Options: Critical, Higher, Middle, Lower: \n";
	std::cin &gt;&gt; priority;</span>

	// Input validation for priority
	while (priority != PrioritiesLevel::CRITICAL &amp;&amp; priority != PrioritiesLevel::HIGHER &amp;&amp;
<span style = "background-color:#fdd">		priority != PrioritiesLevel::MIDDLE &amp;&amp; priority != PrioritiesLevel::LOWER) {
		std::cout &lt;&lt; "Invalid priority. Please enter one of the specified options." &lt;&lt; std::endl;
		std::cout &lt;&lt; "Enter the priority for the task. Options: Critical, Higher, Middle, Lower: ";
		std::cin &gt;&gt; priority;
	}</span>

	// Input validation for runningTime
<span style = "background-color:#fdd">	while (true) {
		std::cout &lt;&lt; "Enter the task running time in seconds: \n";
		std::cin &gt;&gt; input;</span>

		// Check if the input contains only digits
<span style = "background-color:#fdd">		if (input.find_first_not_of("0123456789-") != std::string::npos) {
			std::cerr &lt;&lt; "Invalid input. Running time should contain only numeric digits." &lt;&lt; std::endl;
			continue; // Restart the loop for a valid input</span>
		}

		// Convert the input to an integer
<span style = "background-color:#fdd">		runningTime = std::stoi(input);</span>

<span style = "background-color:#fdd">		if (runningTime &lt; 0) {
			std::cerr &lt;&lt; "Invalid input: Running time cannot be negative." &lt;&lt; std::endl;
			continue; // Restart the loop for a valid input</span>
		}

<span style = "background-color:#fdd">		break; // If runningTime is valid, exit the loop
	}
	spdlog::info(Logger::LoggerInfo::CREATE_NEW_TASK, priority, runningTime);</span>
	// Assuming other fields like status and entryTime are set elsewhere

<span style = "background-color:#fdd">	return shared_ptr&lt;Task&gt;(new Task((taskIds++) % MAX_TASKS, priority, runningTime));
}</span>

/**
 * @brief Continuously prompts the user to input task details and inserts the tasks into the appropriate scheduler.
 *
 * This function loops indefinitely, prompting the user to input task details using the Input function.
 * If the input task is valid, it is added to the corresponding scheduler based on its priority level.
 * Tasks with Critical priority are added to the real-time scheduler, while others are added to the Weighted Round Robin scheduler.
 */

void Scheduler::insertTask(shared_ptr&lt;Task&gt; newTask)
<span style = "background-color:#dfd">{</span>
	try {
<span style = "background-color:#dfd">		if (newTask == nullptr) {
			throw std::invalid_argument("Invalid task input. Please try again.");</span>
		}

<span style = "background-color:#dfd">		if (newTask-&gt;getPriority() == PrioritiesLevel::CRITICAL) {
			realTimeScheduler.addTask(newTask); // Add task to real-time scheduler for real-time tasks
			spdlog::info(Logger::LoggerInfo::ADD_CRITICAL_TASK, newTask-&gt;getId());
		}</span>
		else {
<span style = "background-color:#dfd">			wrrQueuesScheduler.addTask(newTask); // Add task to Weighted Round Robin scheduler for non-real-time tasks
			spdlog::info(Logger::LoggerInfo::ADD_NON_CRITICAL_TASK, newTask-&gt;getId(), newTask-&gt;getPriority());</span>
		}
	}
<span style = "background-color:#dfd">	catch (const std::invalid_argument&amp; e) {
		std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
		spdlog::error("Error: {}", e.what());
	}
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>